{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/404.xml","path":"404.xml","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/wechatRewardImage.png","path":"images/wechatRewardImage.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/alipayRewardImage.jpg","path":"images/alipayRewardImage.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"bb24c51d3ac2716e5caa95728f73bd66d95f9238","modified":1504928675000},{"_id":"themes/next/.DS_Store","hash":"8a00ee41e9438663e117481a0254c867f9e39826","modified":1488699714000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1486730434000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1486730434000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1486730434000},{"_id":"themes/next/.gitignore","hash":"5f09fca02e030b7676c1d312cd88ce8fbccf381c","modified":1486730434000},{"_id":"themes/next/.javascript_ignore","hash":"f9ea3c5395f8feb225a24e2c32baa79afda30c16","modified":1486730434000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1486730434000},{"_id":"themes/next/README.en.md","hash":"4ece25ee5f64447cd522e54cb0fffd9a375f0bd4","modified":1486730434000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1486730434000},{"_id":"themes/next/_config.yml","hash":"685b8513caa1bfc18994b600825556c30cb8b66c","modified":1488727573000},{"_id":"themes/next/bower.json","hash":"5abc236d9cc2512f5457ed57c1fba76669eb7399","modified":1486730434000},{"_id":"themes/next/gulpfile.coffee","hash":"61ef0606a8134894d7ac796bc8d0fa4ba6a94483","modified":1486730434000},{"_id":"themes/next/package.json","hash":"877cb98025e59015532c4c9a04a33e2af4ad56f9","modified":1486730434000},{"_id":"source/_posts/.DS_Store","hash":"eb2c0f1307b46b08910c8cfe92eaa03eaa0d9e34","modified":1504347722000},{"_id":"source/_posts/IDEA-DEBUG-SLOW.md","hash":"e596b995b9591c30fc791fbdf9c14856388faaf5","modified":1503367310000},{"_id":"source/_drafts/new-draft.md","hash":"eacfee243330361756e725175b014a328f334d33","modified":1502618330000},{"_id":"source/_posts/JAVA与C-的比较.md","hash":"dafd13802243c982461d18111661a2c4167e94a3","modified":1504950076000},{"_id":"source/_posts/JIT.md","hash":"cb282a8cca5c3f28b44370d6165d45497cbe8a8b","modified":1504950138000},{"_id":"source/_posts/LINUX启动过程.md","hash":"8a83ca1e8a10b24a2b26dc7458da0fc73e6008db","modified":1504347715000},{"_id":"source/_posts/Spring-IOC.md","hash":"ab219d2224c9d3e9f0c8e72864daa40415ddcefc","modified":1505090499000},{"_id":"source/_posts/Spring-MVC.md","hash":"38265f39bae273d32335f985fea8650818419768","modified":1505648501000},{"_id":"source/_posts/c-模板.md","hash":"9ddf4d59b859f680c30a418d424aadf21d3125be","modified":1504347139000},{"_id":"source/_posts/c-的多态.md","hash":"49b38c5b7b1281f33a5bb180513ceb2d3849d7a4","modified":1504347111000},{"_id":"source/_posts/c-继承.md","hash":"270fa7880ed20a5e01ca5da306b6bcf8917bc514","modified":1504347121000},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1486727013000},{"_id":"source/_posts/c-类的四大函数.md","hash":"a1625b8dc2b8395b67bcb0af88cfc29cce7d28f2","modified":1504347131000},{"_id":"source/_posts/git-常用命令.md","hash":"5f5cd2ab5de84016166931b44abd72ecbbebff4a","modified":1504925709000},{"_id":"source/_posts/linux-基础常识.md","hash":"8d644155d0b48318226f29287af48d34268b25eb","modified":1504347162000},{"_id":"source/_posts/linux-内存管理.md","hash":"b667a987e9d86942d5f7b821d47d6d6f545d6457","modified":1504347175000},{"_id":"source/_posts/linux-文件系统.md","hash":"5fb2a19383de96ee7918b4ec0024be6027007fa8","modified":1504347186000},{"_id":"source/_posts/maven.md","hash":"c47fe70dd0e03b25e9d7fbd8080c44dfe13162b8","modified":1504926014000},{"_id":"source/_posts/spring.md","hash":"401b7c225fff5b93f38d8de0dc0314b1d2c3b30f","modified":1504950270000},{"_id":"source/_posts/linux-杂记.md","hash":"74a257a320948df16342b793157870f5f6e4bc9c","modified":1504347197000},{"_id":"source/_posts/test-18-26.md","hash":"7f68b55e9efa41b48f4e9d7ca5dbafe798f2ae73","modified":1517480939000},{"_id":"source/_posts/test2018-01-28.md","hash":"efba32c403db1f358477fd829a0916c40115296a","modified":1517148803000},{"_id":"source/_posts/代码规范与整洁之道.md","hash":"d7b8611130fc8b3740eb2f3a9772e532bd1016ec","modified":1504347100000},{"_id":"source/_posts/代码覆盖率.md","hash":"f3a2a539bf64676b0e9e3925b13f4c22491d4e78","modified":1502619752000},{"_id":"source/_posts/x86系统编译原理.md","hash":"faadcc229426c4638a485648b4f47f23e66bba63","modified":1504347218000},{"_id":"source/_posts/接口与抽象类.md","hash":"b669fa03ee97f83980b98010c1436177bf5a226e","modified":1504927572000},{"_id":"source/_posts/程序员自我修养简记.md","hash":"f029884d65696b0c7a3b4eccc2990e6076c8fbf0","modified":1504347078000},{"_id":"source/_posts/设计原则与设计模式.md","hash":"e4da3f2ae5b51ed75fea990b4ea1b601fea39851","modified":1504927815000},{"_id":"source/about/.DS_Store","hash":"af5ebac0ae2a7092d1d70e537899bbda514e438e","modified":1502616297000},{"_id":"source/about/index.md","hash":"d848e6cb0c0b646fb729819ca1fac5170c360be0","modified":1488700329000},{"_id":"source/categories/.DS_Store","hash":"53642c1f95ca628ef9910ddede65bf2833f5e088","modified":1488694682000},{"_id":"source/categories/index.md","hash":"b43cd378f3a888a136b695abd3a41e75a068c989","modified":1488690896000},{"_id":"source/sitemap/index.md","hash":"736739f9481c9b61f0884f4fff4fc4d4fe414d62","modified":1488694811000},{"_id":"source/tags/index.md","hash":"08255be5ff42db1a3698d998106acc29aab419a6","modified":1488690726000},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1486730434000},{"_id":"themes/next/.git/config","hash":"bf7d1df65cf34d0f25a7184a58c37a09f72e4be7","modified":1486730434000},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1486728447000},{"_id":"themes/next/.git/packed-refs","hash":"252de1f7786235023b0bae9d26a15b8e3dad33ad","modified":1486730434000},{"_id":"themes/next/.git/index","hash":"25cbd868d6506ee9d758f471d17aa81722608239","modified":1502619808000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1486730434000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1486730434000},{"_id":"themes/next/languages/de.yml","hash":"1fdea1f84b7f691f5b4dd4d2b43eeb27b10fa0c8","modified":1486730434000},{"_id":"themes/next/languages/default.yml","hash":"07a559df8f0d413cceb145a9bb8d6bbf72d93bcf","modified":1486730434000},{"_id":"themes/next/languages/en.yml","hash":"07a559df8f0d413cceb145a9bb8d6bbf72d93bcf","modified":1486730434000},{"_id":"themes/next/languages/fr-FR.yml","hash":"9fca01ef917d33ae2ae6bc04561ec6799dff5351","modified":1486730434000},{"_id":"themes/next/languages/ja.yml","hash":"49f12149edcc1892b26a6207328cda64da20116d","modified":1486730434000},{"_id":"themes/next/languages/id.yml","hash":"34396bef27c4ab9e9a3c5d3e3aa94b0e3b3a7b0d","modified":1486730434000},{"_id":"themes/next/languages/ko.yml","hash":"b6bc5d6b0c000deb44099b42d3aebb8c49dbfca9","modified":1486730434000},{"_id":"themes/next/languages/pt-BR.yml","hash":"7742ba4c0d682cbe1d38305332ebc928abd754b5","modified":1486730434000},{"_id":"themes/next/languages/pt.yml","hash":"6b660b117314cad93f08757601df3adb04c68beb","modified":1486730434000},{"_id":"themes/next/languages/ru.yml","hash":"55a75ca62a4fd55af288523f5f65148441b493ab","modified":1486730434000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"f6c9fafa0f5f0050cd07ca2cf5e38fbae3e28145","modified":1486730434000},{"_id":"themes/next/languages/zh-hk.yml","hash":"34c84c6d04447a25bd5eac576922a13947c000e2","modified":1486730434000},{"_id":"themes/next/languages/zh-tw.yml","hash":"c97a5c41149de9b17f33439b0ecf0eff6fdae50e","modified":1486730434000},{"_id":"themes/next/layout/.DS_Store","hash":"48bcc6b17714523b4aaa3f4fb97a667e1cf9ffa0","modified":1488697184000},{"_id":"themes/next/layout/_layout.swig","hash":"2fa3c74066843a859fac77803324a1de51044da9","modified":1486730434000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1486730434000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1486730434000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1486730434000},{"_id":"themes/next/layout/page.swig","hash":"3727fab9dadb967e9c2204edca787dc72264674a","modified":1486730434000},{"_id":"themes/next/layout/schedule.swig","hash":"1f1cdc268f4ef773fd3ae693bbdf7d0b2f45c3a3","modified":1486730434000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1486730434000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1486730434000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1486730434000},{"_id":"themes/next/scripts/.DS_Store","hash":"b282781ad05b015f473b3e3d8cb72b64865d1698","modified":1488456434000},{"_id":"themes/next/source/.DS_Store","hash":"b8e5951c497e1060bfccf7be197be3bad8cb1885","modified":1488684164000},{"_id":"themes/next/source/404.xml","hash":"d6cd47ba4ab178269d9e7be773e521a3f74a738b","modified":1488697097000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1486730434000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1486730434000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1486730434000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1486730434000},{"_id":"source/_posts/linux-文件系统/图片5.png","hash":"bd155c4055866b9bd908ba8c11859e8f26e573e3","modified":1488717668000},{"_id":"source/_posts/linux-文件系统/mbr.png","hash":"634bb31b8fae637526fea0aa83654d290534dfd7","modified":1488717130000},{"_id":"source/_posts/linux-文件系统/image1.png","hash":"c68d569da447dcd6037e32f64fae4208a281bc33","modified":1488717108000},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1486728447000},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1486728447000},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1486728447000},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1486728447000},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1486728447000},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1486728447000},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1486728447000},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1486728447000},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1486728447000},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1486728447000},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1486728447000},{"_id":"themes/next/.git/logs/HEAD","hash":"58b7c09bbbe91d087f0ad691aaf650584bd50475","modified":1486730434000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1486730434000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1486730434000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"5864f5567ba5efeabcf6ea355013c0b603ee07f2","modified":1486730434000},{"_id":"themes/next/layout/_macro/post.swig","hash":"0f67383a3501aa5151d18012cce8a3cab1fc3134","modified":1486730434000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1486730434000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"43d8830bb19da4fc7a5773866be19fa066b62645","modified":1486730434000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1486730434000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"970aa668680896262b1056bb5787fc9ec8754495","modified":1486730434000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1486730434000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1486730434000},{"_id":"themes/next/layout/_partials/header.swig","hash":"adab5c3f7b173f1b45454787f39dde07aea03483","modified":1486730434000},{"_id":"themes/next/layout/_partials/head.swig","hash":"a0eafe24d1dae30c790ae35612154b3ffbbd5cce","modified":1486730434000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"39d613e5a9f8389d4ea52d6082502af8e833b9f2","modified":1486730434000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1486730434000},{"_id":"themes/next/layout/_partials/search.swig","hash":"1431719d1dbba3f5ee385eebc46376d1a960b2d5","modified":1486730434000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1486730434000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1486730434000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1486730434000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"4512867d80d9eddfc3a0f5fea3c456f33aa9d522","modified":1486730434000},{"_id":"themes/next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1486730434000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1486730434000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1486730434000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1486730434000},{"_id":"themes/next/scripts/tags/note.js","hash":"6752925eedbdb939d8ec4d11bdfb75199f18dd70","modified":1486730434000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1486730434000},{"_id":"themes/next/source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1488698994000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1486730434000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1486730434000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1486730434000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1486730434000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1486730434000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1486730434000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1486730434000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1486730434000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1486730434000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1486730434000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1486730434000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1486730434000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1486730434000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1486730434000},{"_id":"source/_posts/linux-文件系统/图片4.png","hash":"f934eb97be0810480bdde3f03a3cd1a190d3daaf","modified":1488717690000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1486730434000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1486730434000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1486730434000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1486730434000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1486730434000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1486730434000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1486730434000},{"_id":"themes/next/source/images/avatar.jpg","hash":"d497adff34ec91741b5d3cffb49e06815be919b1","modified":1463757226000},{"_id":"themes/next/source/images/wechatRewardImage.png","hash":"7ab256f490cef25c5868ee4ecc60b0b2f5555d40","modified":1488697400000},{"_id":"source/_posts/linux-文件系统/图片6.png","hash":"b3403eaa610e561610c0a7c745604cfd1a731289","modified":1488717909000},{"_id":"themes/next/.git/refs/heads/master","hash":"786fa32781b666ee8e8267fdde94ccb0b20a1802","modified":1486730434000},{"_id":"themes/next/layout/_components/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1486730434000},{"_id":"themes/next/layout/_components/algolia-search/dom.swig","hash":"636f1181dd5887a70b4a08ca8f655d4e46635792","modified":1486730434000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1486730434000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1486730434000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1486730434000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1486730434000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1486730434000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1486730434000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1486730434000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1486730434000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1486730434000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1486730434000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1486730434000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"e46900412e28f529c26e25e6bada342006435a32","modified":1486730434000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"a279e1881208aff2f669fe235e9661ab825bc540","modified":1486730434000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"b460e27db3dcd4ab40b17d8926a5c4e624f293a9","modified":1486730434000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1486730434000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1486730434000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1486730434000},{"_id":"themes/next/layout/_scripts/third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1486730434000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1486730434000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1486730434000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1486730434000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1486730434000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c459aa6d607d8bcb747544e74f6ad0b8374aa3b1","modified":1486730434000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"fc185c6cec79593775d1c2440dbe2a71cfbe2e99","modified":1486730434000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1486730434000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"96b29f69b8b916b22f62c9959a117b5a968200a5","modified":1486730434000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1486730434000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1486730434000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1486730434000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1486730434000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1486730434000},{"_id":"themes/next/source/js/src/utils.js","hash":"384e17ff857f073060f5bf8c6e4f4b7353236331","modified":1486730434000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1486730434000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1486730434000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1486730434000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1486730434000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1486730434000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1486730434000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1486730434000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1486730434000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1486730434000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"c1072942459fa0880e8a33a1bd929176b62b4171","modified":1486730434000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1486730434000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1486730434000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1486730434000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1486730434000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1486730434000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1486730434000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1486730434000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1486730434000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1486730434000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1486730434000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1486730434000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1486730434000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1486730434000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1486730434000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1486730434000},{"_id":"themes/next/source/images/alipayRewardImage.jpg","hash":"27730c2b28bf2809209d75e48d1e24717617d13d","modified":1488697401000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1486730434000},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"58b7c09bbbe91d087f0ad691aaf650584bd50475","modified":1486730434000},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1486730434000},{"_id":"themes/next/layout/_scripts/third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1486730434000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1486730434000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1486730434000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1486730434000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1486730434000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1486730434000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1486730434000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-mta.swig","hash":"a652f202bd5b30c648c228ab8f0e997eb4928e44","modified":1486730434000},{"_id":"themes/next/layout/_scripts/third-party/analytics/vkontakte-api.swig","hash":"9fbffcdfd9b2fa9ae0e813ef01f02dea8d78271c","modified":1486730434000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"fb1d04ede838b52ca7541973f86c3810f1ad396e","modified":1486730434000},{"_id":"themes/next/layout/_scripts/third-party/comments/gentie.swig","hash":"03592d1d731592103a41ebb87437fe4b0a4c78ca","modified":1486730434000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1486730434000},{"_id":"themes/next/layout/_scripts/third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1486730434000},{"_id":"themes/next/layout/_scripts/third-party/comments/livere.swig","hash":"7240f2e5ec7115f8abbbc4c9ef73d4bed180fdc7","modified":1486730434000},{"_id":"themes/next/layout/_scripts/third-party/comments/youyan.swig","hash":"af9dd8a4aed7d06cf47b363eebff48850888566c","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1486730434000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1486730434000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1486730434000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1486730434000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1486730434000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1486730434000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1486730434000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1486730434000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1486730434000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1486730434000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1486730434000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1486730434000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1486730434000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1486730434000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1486730434000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1486730434000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1486730434000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1486730434000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1486730434000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"ff9f163bb05c0709577040a875924d36c9ab99d6","modified":1486730434000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"dcf9fe43b2ef78b923118ba39efedb38760e76b1","modified":1486730434000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"1408209dfb9a22a0982a30bdbd14842c2b53f264","modified":1486730434000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1486730434000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9b63bd8effc7cf4b96acdea4d73add7df934a222","modified":1486730434000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1486730434000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"9ccee9189c910b8a264802d7b2ec305d12dedcd0","modified":1486730434000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1486730434000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1486730434000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1486730434000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1486730434000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1486730434000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1486730434000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1486730434000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1486730434000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1486730434000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1486730434000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1486730434000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1486730434000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1486730434000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1486730434000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1486730434000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1486730434000},{"_id":"themes/next/.git/objects/pack/pack-8e964e8e51c131f17ed01c717d861a3d423bdf90.idx","hash":"8ec443e6b36cc0930c867fa3875db0cb5df9c714","modified":1486730434000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1486730434000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1486730434000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1486730434000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1486730434000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1486730434000},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"58b7c09bbbe91d087f0ad691aaf650584bd50475","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4b7f81e1006e7acee3d1c840ccba155239f830cc","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"beccb53dcd658136fb91a0c5678dea8f37d6e0b6","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"b9a2e76f019a5941191f1263b54aef7b69c48789","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"bfd806d0a9f21446a22df82ac02e37d0075cc3b5","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"3eb73cee103b810fa56901577ecb9c9bb1793cff","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"74d0ba86f698165d13402670382a822c8736a556","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"eba491ae624b4c843c8be4c94a044085dad4ba0f","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/third-party/gentie.styl","hash":"586a3ec0f1015e7207cd6a2474362e068c341744","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"637c6b32c58ecf40041be6e911471cd82671919b","modified":1486730434000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"42348219db93a85d2ee23cb06cebd4d8ab121726","modified":1486730434000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1486730434000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1486730434000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1486730434000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1486730434000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1486730434000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1486730434000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1486730434000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1486730434000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1486730434000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1486730434000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1486730434000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1486730434000},{"_id":"themes/next/.git/objects/pack/pack-8e964e8e51c131f17ed01c717d861a3d423bdf90.pack","hash":"d721e9142793719264ea95a2f439be7b350c0b8d","modified":1486730434000},{"_id":"public/search.xml","hash":"46c6a0b7c4a903bc299997a73232a73d28565456","modified":1527691432156},{"_id":"public/about/index.html","hash":"b5292e24f8bc94a024a615aaabd8ef70727ee8de","modified":1527691432196},{"_id":"public/sitemap/index.html","hash":"8593724717b6a71d42661a0a4a0919a4006d30e1","modified":1527691432196},{"_id":"public/categories/index.html","hash":"81cf89b4ef024da43143e1bbc1b8510da1d5fb29","modified":1527691432196},{"_id":"public/tags/index.html","hash":"4b075c30c2f24d11a1159f43d2d8315cdb8a8954","modified":1527691432196},{"_id":"public/2018/02/01/test-18-26/index.html","hash":"278d04bad78c83815ff675746fccb48416ac1a13","modified":1517481051407},{"_id":"public/2018/01/28/test2018-01-28/index.html","hash":"cb1c881bed7c315d8b641136b5d45ede48dbd7bc","modified":1517481051407},{"_id":"public/2017/09/17/Spring-MVC/index.html","hash":"1f2c48c547510d4365c290c6aeaaf496077d8b47","modified":1527691432196},{"_id":"public/2017/09/11/Spring-IOC/index.html","hash":"4995c58e290ca03dc50d17924c8ea5ff4f87323b","modified":1527691432196},{"_id":"public/2017/09/09/spring/index.html","hash":"fc1ce91c54d93cd0de1007defd86167bffbdc1dc","modified":1527691432196},{"_id":"public/2017/09/09/JIT/index.html","hash":"a6649befbaa72a2a8f1cb5b86fae6736488ab67d","modified":1527691432196},{"_id":"public/2017/09/09/JAVA与C-的比较/index.html","hash":"5f0863e3ceb03f72b958e32bfa7b648ba8bd6c1b","modified":1527691432197},{"_id":"public/2017/09/09/设计原则与设计模式/index.html","hash":"7c928bae436954f8f7322828c69aa5487b8bd339","modified":1527691432196},{"_id":"public/2017/09/09/接口与抽象类/index.html","hash":"9002953b5ffbe4c4e2bd8a9755b710cf12b43453","modified":1527691432196},{"_id":"public/2017/09/09/maven/index.html","hash":"032b47b8a2e7c3506e9a9b72bae0b4a590b4f71a","modified":1527691432197},{"_id":"public/2017/09/09/git-常用命令/index.html","hash":"e213fbc3442099c4f6c74311d36de1d4838a303d","modified":1527691432197},{"_id":"public/2017/09/02/LINUX启动过程/index.html","hash":"136a64c69a1fc1ab3c50c24ca3c56d393ef2d062","modified":1527691432197},{"_id":"public/2017/08/27/代码规范与整洁之道/index.html","hash":"999fa416597993c6992393bf041b015b10aff8b3","modified":1527691432197},{"_id":"public/2017/08/22/IDEA-DEBUG-SLOW/index.html","hash":"ed6c8049d9203909c148470959e2222bb587acad","modified":1527691432197},{"_id":"public/2017/08/13/代码覆盖率/index.html","hash":"4ab0390ba70ca42851c8f3879e3bc38407b68263","modified":1527691432197},{"_id":"public/2017/03/05/x86系统编译原理/index.html","hash":"1b53efc1ea95f7c2d4864b156818fe2dfb3bd0f7","modified":1527691432197},{"_id":"public/2017/03/05/程序员自我修养简记/index.html","hash":"24d3339d7e76d3009676757150c042fbfe8197e7","modified":1527691432197},{"_id":"public/2017/03/05/linux-基础常识/index.html","hash":"069fc31ac419c66cb784ea4cf562c22550cc60d0","modified":1527691432197},{"_id":"public/2017/03/05/linux-杂记/index.html","hash":"9689edceeea6de4ed8a4f493500a45d15b038a29","modified":1527691432197},{"_id":"public/2017/03/05/linux-文件系统/index.html","hash":"93690199d6b5e408b62a32a80955e0e7d858a537","modified":1527691432197},{"_id":"public/2017/03/05/linux-内存管理/index.html","hash":"73b57acec5a323aa98af142dfbd3e38459fd5af7","modified":1527691432197},{"_id":"public/2017/03/05/c-类的四大函数/index.html","hash":"72c88ff1bc259e7dcd73447444cd6c3523ac5e0f","modified":1527691432197},{"_id":"public/2017/03/05/c-继承/index.html","hash":"744b5fe9c3cab8fe386da281ae44b9f590679f9f","modified":1527691432197},{"_id":"public/2017/03/05/c-的多态/index.html","hash":"82c477ad667475be4a2f9b6dd49fb281b5188213","modified":1527691432197},{"_id":"public/2017/03/05/c-模板/index.html","hash":"08f5df0e82612899eb5585296c3c6726c8f75f24","modified":1527691432197},{"_id":"public/2017/02/10/hello-world/index.html","hash":"c8a1685f14fa076b448627da99c554787d54eff5","modified":1527691432198},{"_id":"public/archives/index.html","hash":"212cf045d9fb0bcdfe5649027d8f3be562a3c6b9","modified":1527691432198},{"_id":"public/archives/page/2/index.html","hash":"059295ca3f00189b2114f56f5c141fd6ab8b5bc9","modified":1527691432198},{"_id":"public/archives/page/3/index.html","hash":"acfbfa66dc4ea3695f5a8b56ab7c78aadbf620aa","modified":1527691432198},{"_id":"public/archives/2017/index.html","hash":"5d88388bf12133c9dba226e6035f9a7488b358dc","modified":1527691432198},{"_id":"public/archives/2017/page/2/index.html","hash":"8081ebbc8c9db969c47b54707d80e33331f5cef2","modified":1527691432198},{"_id":"public/archives/2017/page/3/index.html","hash":"0981e97342ea20efed55a37c10515483a6f89a62","modified":1527691432198},{"_id":"public/archives/2017/02/index.html","hash":"3fbee62bebbc6a085f3aa5599f6e570a2c8fe0d4","modified":1527691432198},{"_id":"public/archives/2017/03/index.html","hash":"fe0d247e90308c348b95673149f450f81a1488b6","modified":1527691432198},{"_id":"public/archives/2017/08/index.html","hash":"fed04be8f7ef5c37d4984d73b2cdda091db43d59","modified":1527691432198},{"_id":"public/archives/2017/09/index.html","hash":"12f205902b1a6304e7af099611f2eed7e6618f33","modified":1527691432198},{"_id":"public/archives/2018/index.html","hash":"8ee3241fdf9459f9ae542b1a582126b060b627c0","modified":1517481051409},{"_id":"public/archives/2018/01/index.html","hash":"9ec447f3d04ae960a163c1c1d9a11358ca348c89","modified":1517481051409},{"_id":"public/archives/2018/02/index.html","hash":"0b02be258348cadf429f2c6c5dbd5404bacefc4e","modified":1517481051409},{"_id":"public/categories/IDEA/index.html","hash":"f580afa28d6708f580d6227658ccb4531c941a0a","modified":1527691432198},{"_id":"public/categories/C/index.html","hash":"220f58a84460a2a8b29908e0f28dd5a756bd4a55","modified":1527691432198},{"_id":"public/categories/JAVA/index.html","hash":"f11442b4114ac5aa2ac68c6e4b02697cd7c5e7ec","modified":1527691432198},{"_id":"public/categories/LINUX/index.html","hash":"73e0409ddb43d5966ae973bd5cbbe28ef5c27605","modified":1527691432198},{"_id":"public/categories/SPRING/index.html","hash":"cb3a9ac05c12e350e46a40667dd6905ff9e12435","modified":1527691432198},{"_id":"public/categories/C/JAVA/index.html","hash":"648800aae2f8af4925dbadb751216c6e96d09dfe","modified":1527691432199},{"_id":"public/categories/GIT/index.html","hash":"f1e68815035e8331cabd1118edf17bdb5c17c04e","modified":1527691432199},{"_id":"public/categories/MAVEN/index.html","hash":"af4163b22330e0c552c74b014cb0f927a9ea6f25","modified":1527691432199},{"_id":"public/categories/p1/index.html","hash":"da8095c85267a3f9b754c904de8a5eee7e8611c6","modified":1517481051409},{"_id":"public/categories/p1/p2/index.html","hash":"1b2b6c64b6b11a9d738811eeb6b604bf8cb5cd08","modified":1517481051409},{"_id":"public/categories/设计模式/index.html","hash":"6a1eeceef7d43f075e5e7d1379526176e141e363","modified":1527691432199},{"_id":"public/index.html","hash":"b3d056c075b787575301064d293ee4211c0c06e1","modified":1527691432199},{"_id":"public/page/2/index.html","hash":"748f47177927402a1887d6df82bf5d98d679d565","modified":1527691432199},{"_id":"public/page/3/index.html","hash":"1a679008a9c6542ea4e12caabca57574d8619e8c","modified":1527691432199},{"_id":"public/tags/IDEA/index.html","hash":"829bcc4e55337fb9b60607c3a83f55ffad28f93c","modified":1527691432199},{"_id":"public/tags/DEBUG/index.html","hash":"fc393a2f1d2f9af463cfd736a72a3fd5c6275159","modified":1527691432199},{"_id":"public/tags/C/index.html","hash":"e8149f8bb058d6ef70d77e369d21bdb062b4845b","modified":1527691432199},{"_id":"public/tags/JAVA/index.html","hash":"0768e3d4ab8e7645e22b7dc6ba3c7a927cb32907","modified":1527691432199},{"_id":"public/tags/JVM/index.html","hash":"dd37918bb94d761d0646f24ca1ecdf71f74c1574","modified":1527691432199},{"_id":"public/tags/JIT/index.html","hash":"5391b93cf864d917f17fce87216ffcc56cd0895d","modified":1527691432199},{"_id":"public/tags/LINUX/index.html","hash":"90bee22d5d89372e9b442b144d289ce89d86c2a7","modified":1527691432199},{"_id":"public/tags/启动过程/index.html","hash":"b78a09d33f69a8fa35f69cfa84775d0754b07eea","modified":1527691432199},{"_id":"public/tags/Spring/index.html","hash":"6deb639490ecccb66065b89abf2ad9e6e0027c2f","modified":1527691432199},{"_id":"public/tags/IOC/index.html","hash":"1b5fa20862d1f78b7a377fb2864e8a1f0f60f29e","modified":1527691432199},{"_id":"public/tags/spring/index.html","hash":"a898ab1891d93215e2d6720f8093ed3e3d371e03","modified":1527691432199},{"_id":"public/tags/mvc/index.html","hash":"f99313ebb439f3a2e65c687ed1636fb5b211bda3","modified":1527691432200},{"_id":"public/tags/模板/index.html","hash":"576cf81ec03ba1f0268dceea779d5df0d052ca2f","modified":1527691432199},{"_id":"public/tags/多态/index.html","hash":"4480c676c8a81ef04df3336f1af10416f568114e","modified":1527691432200},{"_id":"public/tags/面向对象/index.html","hash":"7493d26f4582ab08f36777b1dd04ee78e9f3e9fa","modified":1527691432200},{"_id":"public/tags/继承/index.html","hash":"e70cd4aa7d54ef4d637658529b76b2658c22bd87","modified":1527691432200},{"_id":"public/tags/类/index.html","hash":"43a11c5a611e56092e83460b8b279ac9f9338bb0","modified":1527691432200},{"_id":"public/tags/git/index.html","hash":"2ddbc10097c16c044538a78dd9aead610b6ec4c8","modified":1527691432200},{"_id":"public/tags/内存管理/index.html","hash":"195cd7380609e7e9de43f9689852c0ab5b617bd0","modified":1527691432200},{"_id":"public/tags/文件系统/index.html","hash":"4236447dd98772bf3cfba55b443df127fda705e9","modified":1527691432200},{"_id":"public/tags/maven/index.html","hash":"f4f512a486322a7f5021e660bc84720a7e1d05aa","modified":1527691432200},{"_id":"public/tags/进程/index.html","hash":"6b0dfd4e8b075827e2498d5d020c80f18ddec881","modified":1527691432200},{"_id":"public/tags/线程/index.html","hash":"43c9da6b19c1d2530fa4d62d5cacbbe6f8e7a2c7","modified":1527691432200},{"_id":"public/tags/tag1/index.html","hash":"d8e59b1d7d4ea391c94da360bd07b73d3f36b93f","modified":1517481051410},{"_id":"public/tags/tag2/index.html","hash":"0e93f7d41220d08cc17d6255744c58a5a8cdd3b2","modified":1517481051410},{"_id":"public/tags/代码规范/index.html","hash":"cb1cb2f3e0028867ecad343aba2a4fccbfd3df7f","modified":1527691432200},{"_id":"public/tags/单元测试/index.html","hash":"a54cf43af5e3ff53de9e1cf9912de274269e25d7","modified":1527691432200},{"_id":"public/tags/JACOCO/index.html","hash":"113f5aa8de047ec5c16ca568a98d8403e7ebeedc","modified":1527691432200},{"_id":"public/tags/X86/index.html","hash":"16e4e8fb96f539fb2e76737ecee9811729286c17","modified":1527691432200},{"_id":"public/tags/编译原理/index.html","hash":"4ec0eb5c2fe7185127ec6e91c3a0d7aef666b3ff","modified":1527691432200},{"_id":"public/tags/接口/index.html","hash":"18d30ee6a08e3130026f9acbbcb5cba39e8494d8","modified":1527691432200},{"_id":"public/tags/抽象类/index.html","hash":"5e499ce367c28297096ed94e9bfa8576f84eabe6","modified":1527691432200},{"_id":"public/tags/设计模式/index.html","hash":"2cd5d1276fe95f802eb3b9e038706e1e1f79ffad","modified":1527691432200},{"_id":"public/tags/程序员自我修养/index.html","hash":"42eb94ade15331faff4f882f5635017888ad7eb4","modified":1527691432200},{"_id":"public/404.xml","hash":"d6cd47ba4ab178269d9e7be773e521a3f74a738b","modified":1517481051418},{"_id":"public/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1517481051418},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1517481051418},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1517481051418},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1517481051418},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1517481051418},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1517481051419},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1517481051419},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1517481051419},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1517481051419},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1517481051419},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1517481051419},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1517481051419},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1517481051419},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1517481051419},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1517481051419},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1517481051419},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1517481051419},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1517481051419},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1517481051419},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1517481051420},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1517481051420},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1517481051420},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1517481051420},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1517481051420},{"_id":"public/2017/03/05/linux-文件系统/image1.png","hash":"c68d569da447dcd6037e32f64fae4208a281bc33","modified":1517481051420},{"_id":"public/2017/03/05/linux-文件系统/mbr.png","hash":"634bb31b8fae637526fea0aa83654d290534dfd7","modified":1517481051420},{"_id":"public/2017/03/05/linux-文件系统/图片5.png","hash":"bd155c4055866b9bd908ba8c11859e8f26e573e3","modified":1517481051420},{"_id":"public/images/avatar.jpg","hash":"d497adff34ec91741b5d3cffb49e06815be919b1","modified":1517481051956},{"_id":"public/images/wechatRewardImage.png","hash":"7ab256f490cef25c5868ee4ecc60b0b2f5555d40","modified":1517481051957},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1517481051962},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1517481051962},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1517481051962},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1517481051962},{"_id":"public/2017/03/05/linux-文件系统/图片4.png","hash":"f934eb97be0810480bdde3f03a3cd1a190d3daaf","modified":1517481051962},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1517481051970},{"_id":"public/js/src/algolia-search.js","hash":"96b29f69b8b916b22f62c9959a117b5a968200a5","modified":1517481051970},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1517481051970},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1517481051970},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1517481051970},{"_id":"public/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1517481051970},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1517481051970},{"_id":"public/js/src/utils.js","hash":"384e17ff857f073060f5bf8c6e4f4b7353236331","modified":1517481051970},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1517481051970},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1517481051970},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1517481051970},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1517481051970},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1517481051971},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1517481051971},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1517481051971},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1517481051971},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1517481051971},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1517481051971},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1517481051971},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1517481051971},{"_id":"public/js/src/schemes/pisces.js","hash":"9ccee9189c910b8a264802d7b2ec305d12dedcd0","modified":1517481051971},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1517481051971},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1517481051971},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1517481051971},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1517481051971},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1517481051971},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1517481051971},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1517481051971},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1517481051971},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1517481051971},{"_id":"public/css/main.css","hash":"ffce9249edb93e4be2a7980c613f95de3f35c6b3","modified":1517481051971},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1517481051971},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1517481051971},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1517481051971},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1517481051972},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1517481051972},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1517481051972},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1517481051972},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1517481051972},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1517481051972},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1517481051972},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1517481051972},{"_id":"public/2017/03/05/linux-文件系统/图片6.png","hash":"b3403eaa610e561610c0a7c745604cfd1a731289","modified":1517481051972},{"_id":"public/images/alipayRewardImage.jpg","hash":"27730c2b28bf2809209d75e48d1e24717617d13d","modified":1517481051973},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1517481051982}],"Category":[{"name":"IDEA","_id":"cjd4d19zj0004ryx4g5zsh2vu"},{"name":"C++","_id":"cjd4d19zo000bryx4d49a659z"},{"name":"JAVA","_id":"cjd4d19zt000gryx4ixbxhe5m"},{"name":"LINUX","_id":"cjd4d19zw000mryx43l5bx77n"},{"name":"SPRING","_id":"cjd4d1a00000sryx4okn04cf5"},{"name":"JAVA","parent":"cjd4d19zo000bryx4d49a659z","_id":"cjd4d1a080012ryx496bigu8n"},{"name":"GIT","_id":"cjd4d1a0f001dryx4pbr8p0qh"},{"name":"MAVEN","_id":"cjd4d1a0j001lryx468db8iao"},{"name":"p1","_id":"cjd4d1a0l001tryx4hjg91bmg"},{"name":"p2","parent":"cjd4d1a0l001tryx4hjg91bmg","_id":"cjd4d1a0t0028ryx4n4giw0xz"},{"name":"设计模式","_id":"cjd4d1a0u002eryx493wmue1v"}],"Data":[],"Page":[{"title":"about","date":"2017-03-05T05:15:41.000Z","_content":"\n# 自我介绍\n## 基本信息\n>姓名: 王旭  \n手机: +86 183 0294 3553   \ngithub: https://github.com/onaple  \ncsdn: my.csdn.net/aoo_wangxu   \nsvn: onaple  \nqq: 247975260  \nemail: onaple@qq.com  \n住址: 西安市雁塔路13号  \t\t    \n学习经历: 本科  |  2013.09—2017.07 |  西安建筑科技大学  |  自动化\n\n## 荣誉奖励/证书 \n>1. 2016.01美国大学生数学建模竞赛一等奖。主要负责建立模型以及MATLAB编程求解。  \n具有优秀的分析和解决问题的能力；能在短时间内完成具有挑战性的任务；善于与团队合作。\r2. 其他荣誉：科技创新类奖6次、全国计算机等级证书3张、奖学金4次。\r\r\r## 专业技能\n>1.\t熟练掌握C/C++；熟悉JAVA、MATLAB；了解Python；了解STL库；\r2.\t深刻理解Linux操作系统原理（进程线程管理、内存管理、文件系统）；\r3.\t深刻理解数据结构与算法（skiplist、set、map、各种排序算法、一致性哈希）；\r4.\t熟悉TCP/IP；Socket编程；I/O复用；I/O模型；了解HTTP；DNS；\r5.\t熟悉Redis；了解MySQL；Memcached；\n6. 了解spring、mybatis、springMVC、maven等java组件；\r7. 了解Ceph；集群；了解消息中间件；Hadoop；MapReduce；虚拟化技术。\n\n## 自我评价\n\n>醉心计算机、痴迷互联网，曾觅志同学友共立程序爱好者协会，强交流，优彼此; 善组织，耐苦寒，研难题于深夜，查 bug 于鸡鸣，于研发分毫必究、锱铢必较; 觅研发，研代码，键盘手指诉衷肠，起比鸡早亦无怨，不见天日又何妨!悦书籍，快速检索在馆藏;善长跑，周每三次在操场。\n\n## 兴趣特长\n>1. 常研习他人代码并帮助他人调试程序；对优秀代码和debug有自己的学习笔记；\n2. 熟练阅读原版英文书籍和技术文档及快速检索资料；可以快速学习新技术，并应用到实际项目中。动手能力强;\r4. 经常阅读GitHub、CSDN以及一些有名的微信公众号上的文章；也坚持写自己的博客;\n5. 具有高并发、高性能服务器开发的常识和意识，对后端架构感兴趣;\n6. 热衷于研究开源项目以及其设计框架；期望工作后能加入开源项目的团队。\r\n\n\n## 校园经历\n>- 实践经历1：2014.09-2015.07；**创办程序爱好者协会并担任会长职务**；策划过校级程序设计大赛；举办日常社团活动；辅导过全国计算机等级考试。具有较强的沟通能力和领导组织能力。  \r- 实践经历2：2014.09-2015.07；担任勤工助学协会会员；每周花费 5-10 小时在图书馆勤工俭学；主要负责书籍整理与上架；具备很强的责任心与服务意识。\n\n## 阅读书籍\n>- 《Linux就是这个范儿》\n- 《UNIX网络编程 卷1/卷2》\n- 《Linux高性能服务器编程》 \n- 《Redis 设计与实现》\n- 《黑客与画家》\n- 《程序员的自我修养》\n- 《Effective C++》\n\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2017-03-05 13:15:41\n---\n\n# 自我介绍\n## 基本信息\n>姓名: 王旭  \n手机: +86 183 0294 3553   \ngithub: https://github.com/onaple  \ncsdn: my.csdn.net/aoo_wangxu   \nsvn: onaple  \nqq: 247975260  \nemail: onaple@qq.com  \n住址: 西安市雁塔路13号  \t\t    \n学习经历: 本科  |  2013.09—2017.07 |  西安建筑科技大学  |  自动化\n\n## 荣誉奖励/证书 \n>1. 2016.01美国大学生数学建模竞赛一等奖。主要负责建立模型以及MATLAB编程求解。  \n具有优秀的分析和解决问题的能力；能在短时间内完成具有挑战性的任务；善于与团队合作。\r2. 其他荣誉：科技创新类奖6次、全国计算机等级证书3张、奖学金4次。\r\r\r## 专业技能\n>1.\t熟练掌握C/C++；熟悉JAVA、MATLAB；了解Python；了解STL库；\r2.\t深刻理解Linux操作系统原理（进程线程管理、内存管理、文件系统）；\r3.\t深刻理解数据结构与算法（skiplist、set、map、各种排序算法、一致性哈希）；\r4.\t熟悉TCP/IP；Socket编程；I/O复用；I/O模型；了解HTTP；DNS；\r5.\t熟悉Redis；了解MySQL；Memcached；\n6. 了解spring、mybatis、springMVC、maven等java组件；\r7. 了解Ceph；集群；了解消息中间件；Hadoop；MapReduce；虚拟化技术。\n\n## 自我评价\n\n>醉心计算机、痴迷互联网，曾觅志同学友共立程序爱好者协会，强交流，优彼此; 善组织，耐苦寒，研难题于深夜，查 bug 于鸡鸣，于研发分毫必究、锱铢必较; 觅研发，研代码，键盘手指诉衷肠，起比鸡早亦无怨，不见天日又何妨!悦书籍，快速检索在馆藏;善长跑，周每三次在操场。\n\n## 兴趣特长\n>1. 常研习他人代码并帮助他人调试程序；对优秀代码和debug有自己的学习笔记；\n2. 熟练阅读原版英文书籍和技术文档及快速检索资料；可以快速学习新技术，并应用到实际项目中。动手能力强;\r4. 经常阅读GitHub、CSDN以及一些有名的微信公众号上的文章；也坚持写自己的博客;\n5. 具有高并发、高性能服务器开发的常识和意识，对后端架构感兴趣;\n6. 热衷于研究开源项目以及其设计框架；期望工作后能加入开源项目的团队。\r\n\n\n## 校园经历\n>- 实践经历1：2014.09-2015.07；**创办程序爱好者协会并担任会长职务**；策划过校级程序设计大赛；举办日常社团活动；辅导过全国计算机等级考试。具有较强的沟通能力和领导组织能力。  \r- 实践经历2：2014.09-2015.07；担任勤工助学协会会员；每周花费 5-10 小时在图书馆勤工俭学；主要负责书籍整理与上架；具备很强的责任心与服务意识。\n\n## 阅读书籍\n>- 《Linux就是这个范儿》\n- 《UNIX网络编程 卷1/卷2》\n- 《Linux高性能服务器编程》 \n- 《Redis 设计与实现》\n- 《黑客与画家》\n- 《程序员的自我修养》\n- 《Effective C++》\n\n","updated":"2017-03-05T07:52:09.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjd4d19zg0001ryx4hf8sy3jv","content":"<h1 id=\"自我介绍\"><a href=\"#自我介绍\" class=\"headerlink\" title=\"自我介绍\"></a>自我介绍</h1><h2 id=\"基本信息\"><a href=\"#基本信息\" class=\"headerlink\" title=\"基本信息\"></a>基本信息</h2><blockquote>\n<p>姓名: 王旭<br>手机: +86 183 0294 3553<br>github: <a href=\"https://github.com/onaple\" target=\"_blank\" rel=\"external\">https://github.com/onaple</a><br>csdn: my.csdn.net/aoo_wangxu<br>svn: onaple<br>qq: 247975260<br>email: onaple@qq.com<br>住址: 西安市雁塔路13号<br>学习经历: 本科  |  2013.09—2017.07 |  西安建筑科技大学  |  自动化</p>\n</blockquote>\n<h2 id=\"荣誉奖励-证书\"><a href=\"#荣誉奖励-证书\" class=\"headerlink\" title=\"荣誉奖励/证书\"></a>荣誉奖励/证书</h2><blockquote>\n<ol>\n<li>2016.01美国大学生数学建模竞赛一等奖。主要负责建立模型以及MATLAB编程求解。<br>具有优秀的分析和解决问题的能力；能在短时间内完成具有挑战性的任务；善于与团队合作。</li>\n<li>其他荣誉：科技创新类奖6次、全国计算机等级证书3张、奖学金4次。</li>\n</ol>\n</blockquote>\n<h2 id=\"专业技能\"><a href=\"#专业技能\" class=\"headerlink\" title=\"专业技能\"></a>专业技能</h2><blockquote>\n<ol>\n<li>熟练掌握C/C++；熟悉JAVA、MATLAB；了解Python；了解STL库；</li>\n<li>深刻理解Linux操作系统原理（进程线程管理、内存管理、文件系统）；</li>\n<li>深刻理解数据结构与算法（skiplist、set、map、各种排序算法、一致性哈希）；</li>\n<li>熟悉TCP/IP；Socket编程；I/O复用；I/O模型；了解HTTP；DNS；</li>\n<li>熟悉Redis；了解MySQL；Memcached；</li>\n<li>了解spring、mybatis、springMVC、maven等java组件；</li>\n<li>了解Ceph；集群；了解消息中间件；Hadoop；MapReduce；虚拟化技术。</li>\n</ol>\n</blockquote>\n<h2 id=\"自我评价\"><a href=\"#自我评价\" class=\"headerlink\" title=\"自我评价\"></a>自我评价</h2><blockquote>\n<p>醉心计算机、痴迷互联网，曾觅志同学友共立程序爱好者协会，强交流，优彼此; 善组织，耐苦寒，研难题于深夜，查 bug 于鸡鸣，于研发分毫必究、锱铢必较; 觅研发，研代码，键盘手指诉衷肠，起比鸡早亦无怨，不见天日又何妨!悦书籍，快速检索在馆藏;善长跑，周每三次在操场。</p>\n</blockquote>\n<h2 id=\"兴趣特长\"><a href=\"#兴趣特长\" class=\"headerlink\" title=\"兴趣特长\"></a>兴趣特长</h2><blockquote>\n<ol>\n<li>常研习他人代码并帮助他人调试程序；对优秀代码和debug有自己的学习笔记；</li>\n<li>熟练阅读原版英文书籍和技术文档及快速检索资料；可以快速学习新技术，并应用到实际项目中。动手能力强;</li>\n<li>经常阅读GitHub、CSDN以及一些有名的微信公众号上的文章；也坚持写自己的博客;</li>\n<li>具有高并发、高性能服务器开发的常识和意识，对后端架构感兴趣;</li>\n<li>热衷于研究开源项目以及其设计框架；期望工作后能加入开源项目的团队。</li>\n</ol>\n</blockquote>\n<h2 id=\"校园经历\"><a href=\"#校园经历\" class=\"headerlink\" title=\"校园经历\"></a>校园经历</h2><blockquote>\n<ul>\n<li>实践经历1：2014.09-2015.07；<strong>创办程序爱好者协会并担任会长职务</strong>；策划过校级程序设计大赛；举办日常社团活动；辅导过全国计算机等级考试。具有较强的沟通能力和领导组织能力。  </li>\n<li>实践经历2：2014.09-2015.07；担任勤工助学协会会员；每周花费 5-10 小时在图书馆勤工俭学；主要负责书籍整理与上架；具备很强的责任心与服务意识。</li>\n</ul>\n</blockquote>\n<h2 id=\"阅读书籍\"><a href=\"#阅读书籍\" class=\"headerlink\" title=\"阅读书籍\"></a>阅读书籍</h2><blockquote>\n<ul>\n<li>《Linux就是这个范儿》</li>\n<li>《UNIX网络编程 卷1/卷2》</li>\n<li>《Linux高性能服务器编程》 </li>\n<li>《Redis 设计与实现》</li>\n<li>《黑客与画家》</li>\n<li>《程序员的自我修养》</li>\n<li>《Effective C++》</li>\n</ul>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"自我介绍\"><a href=\"#自我介绍\" class=\"headerlink\" title=\"自我介绍\"></a>自我介绍</h1><h2 id=\"基本信息\"><a href=\"#基本信息\" class=\"headerlink\" title=\"基本信息\"></a>基本信息</h2><blockquote>\n<p>姓名: 王旭<br>手机: +86 183 0294 3553<br>github: <a href=\"https://github.com/onaple\" target=\"_blank\" rel=\"external\">https://github.com/onaple</a><br>csdn: my.csdn.net/aoo_wangxu<br>svn: onaple<br>qq: 247975260<br>email: onaple@qq.com<br>住址: 西安市雁塔路13号<br>学习经历: 本科  |  2013.09—2017.07 |  西安建筑科技大学  |  自动化</p>\n</blockquote>\n<h2 id=\"荣誉奖励-证书\"><a href=\"#荣誉奖励-证书\" class=\"headerlink\" title=\"荣誉奖励/证书\"></a>荣誉奖励/证书</h2><blockquote>\n<ol>\n<li>2016.01美国大学生数学建模竞赛一等奖。主要负责建立模型以及MATLAB编程求解。<br>具有优秀的分析和解决问题的能力；能在短时间内完成具有挑战性的任务；善于与团队合作。</li>\n<li>其他荣誉：科技创新类奖6次、全国计算机等级证书3张、奖学金4次。</li>\n</ol>\n</blockquote>\n<h2 id=\"专业技能\"><a href=\"#专业技能\" class=\"headerlink\" title=\"专业技能\"></a>专业技能</h2><blockquote>\n<ol>\n<li>熟练掌握C/C++；熟悉JAVA、MATLAB；了解Python；了解STL库；</li>\n<li>深刻理解Linux操作系统原理（进程线程管理、内存管理、文件系统）；</li>\n<li>深刻理解数据结构与算法（skiplist、set、map、各种排序算法、一致性哈希）；</li>\n<li>熟悉TCP/IP；Socket编程；I/O复用；I/O模型；了解HTTP；DNS；</li>\n<li>熟悉Redis；了解MySQL；Memcached；</li>\n<li>了解spring、mybatis、springMVC、maven等java组件；</li>\n<li>了解Ceph；集群；了解消息中间件；Hadoop；MapReduce；虚拟化技术。</li>\n</ol>\n</blockquote>\n<h2 id=\"自我评价\"><a href=\"#自我评价\" class=\"headerlink\" title=\"自我评价\"></a>自我评价</h2><blockquote>\n<p>醉心计算机、痴迷互联网，曾觅志同学友共立程序爱好者协会，强交流，优彼此; 善组织，耐苦寒，研难题于深夜，查 bug 于鸡鸣，于研发分毫必究、锱铢必较; 觅研发，研代码，键盘手指诉衷肠，起比鸡早亦无怨，不见天日又何妨!悦书籍，快速检索在馆藏;善长跑，周每三次在操场。</p>\n</blockquote>\n<h2 id=\"兴趣特长\"><a href=\"#兴趣特长\" class=\"headerlink\" title=\"兴趣特长\"></a>兴趣特长</h2><blockquote>\n<ol>\n<li>常研习他人代码并帮助他人调试程序；对优秀代码和debug有自己的学习笔记；</li>\n<li>熟练阅读原版英文书籍和技术文档及快速检索资料；可以快速学习新技术，并应用到实际项目中。动手能力强;</li>\n<li>经常阅读GitHub、CSDN以及一些有名的微信公众号上的文章；也坚持写自己的博客;</li>\n<li>具有高并发、高性能服务器开发的常识和意识，对后端架构感兴趣;</li>\n<li>热衷于研究开源项目以及其设计框架；期望工作后能加入开源项目的团队。</li>\n</ol>\n</blockquote>\n<h2 id=\"校园经历\"><a href=\"#校园经历\" class=\"headerlink\" title=\"校园经历\"></a>校园经历</h2><blockquote>\n<ul>\n<li>实践经历1：2014.09-2015.07；<strong>创办程序爱好者协会并担任会长职务</strong>；策划过校级程序设计大赛；举办日常社团活动；辅导过全国计算机等级考试。具有较强的沟通能力和领导组织能力。  </li>\n<li>实践经历2：2014.09-2015.07；担任勤工助学协会会员；每周花费 5-10 小时在图书馆勤工俭学；主要负责书籍整理与上架；具备很强的责任心与服务意识。</li>\n</ul>\n</blockquote>\n<h2 id=\"阅读书籍\"><a href=\"#阅读书籍\" class=\"headerlink\" title=\"阅读书籍\"></a>阅读书籍</h2><blockquote>\n<ul>\n<li>《Linux就是这个范儿》</li>\n<li>《UNIX网络编程 卷1/卷2》</li>\n<li>《Linux高性能服务器编程》 </li>\n<li>《Redis 设计与实现》</li>\n<li>《黑客与画家》</li>\n<li>《程序员的自我修养》</li>\n<li>《Effective C++》</li>\n</ul>\n</blockquote>\n"},{"title":"sitemap","date":"2017-03-05T06:18:38.000Z","type":"sitemap","_content":"","source":"sitemap/index.md","raw":"---\ntitle: sitemap\ndate: 2017-03-05 14:18:38\ntype: \"sitemap\"\n\n---\n","updated":"2017-03-05T06:20:11.000Z","path":"sitemap/index.html","comments":1,"layout":"page","_id":"cjd4d19zi0003ryx4enebee63","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2017-03-05T05:13:40.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-03-05 13:13:40\ntype: \"categories\"\n---\n","updated":"2017-03-05T05:14:56.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjd4d19zl0007ryx4jqqq820z","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2017-03-05T05:10:34.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-03-05 13:10:34\ntype: \"tags\"\n---\n","updated":"2017-03-05T05:12:06.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjd4d19zn0009ryx42na4z66p","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"IDEA DEBUG SLOW","comments":1,"date":"2017-08-22T01:55:37.000Z","update":"2017-08-22T01:55:37.000Z","_content":"\n\nhi, all \n\n我之前做单元覆盖率时遇到了两个问题。\n1.跑测试时，运行特别慢。\n2.debug根本进入不了断点。无法debug。\n\n之前以前一直知道不到解决方法，昨天在苦苦查寻下，找到了，解决方法。如果你的test跑的很慢可以借鉴，希望对大家有帮助，帮大家节约一些宝贵的时间。\n\n## 问题一\n\n### 产生的原因：\n升级到macOS Sierra后，造成的。\n\n### 解决方法：\n\n命令行运行一下命令：\nsudo sed -i bak \"s^127\\.0\\.0\\.1.*^127.0.0.1 localhost $(hostname)^g\" /etc/hosts\nsudo sed -i bak \"s^::1.*^::1 localhost $(hostname)^g\" /etc/hosts\nsudo ifconfig en0 down\nsudo ifconfig en0 up\n\n其他方法参考下面链接\n\n[参考链接：](https://stackoverflow.com/questions/39636792/jvm-takes-a-long-time-to-resolve-ip-address-for-localhost/39698914#39698914)\n\n\n\n\n## 问题二\n\n### 产生的原因：\n\n设置了方法断点，idea会提示：method breakpoint may dramatically slow debugging\n\n### 解决方法：\n\n去除所有方法断点\n\n[参考链接：](http://blog.csdn.net/yanziit/article/details/73459795)\n","source":"_posts/IDEA-DEBUG-SLOW.md","raw":"---\n\ntitle: IDEA DEBUG SLOW\ncomments: true\ntags:\n  - IDEA\n  - DEBUG\ncategories:\n  - IDEA\ndate: 2017-08-22 09:55:37\nupdate: 2017-08-22 09:55:37\n\n---\n\n\nhi, all \n\n我之前做单元覆盖率时遇到了两个问题。\n1.跑测试时，运行特别慢。\n2.debug根本进入不了断点。无法debug。\n\n之前以前一直知道不到解决方法，昨天在苦苦查寻下，找到了，解决方法。如果你的test跑的很慢可以借鉴，希望对大家有帮助，帮大家节约一些宝贵的时间。\n\n## 问题一\n\n### 产生的原因：\n升级到macOS Sierra后，造成的。\n\n### 解决方法：\n\n命令行运行一下命令：\nsudo sed -i bak \"s^127\\.0\\.0\\.1.*^127.0.0.1 localhost $(hostname)^g\" /etc/hosts\nsudo sed -i bak \"s^::1.*^::1 localhost $(hostname)^g\" /etc/hosts\nsudo ifconfig en0 down\nsudo ifconfig en0 up\n\n其他方法参考下面链接\n\n[参考链接：](https://stackoverflow.com/questions/39636792/jvm-takes-a-long-time-to-resolve-ip-address-for-localhost/39698914#39698914)\n\n\n\n\n## 问题二\n\n### 产生的原因：\n\n设置了方法断点，idea会提示：method breakpoint may dramatically slow debugging\n\n### 解决方法：\n\n去除所有方法断点\n\n[参考链接：](http://blog.csdn.net/yanziit/article/details/73459795)\n","slug":"IDEA-DEBUG-SLOW","published":1,"updated":"2017-08-22T02:01:50.000Z","layout":"post","photos":[],"link":"","_id":"cjd4d19zb0000ryx4vpd414b4","content":"<p>hi, all </p>\n<p>我之前做单元覆盖率时遇到了两个问题。<br>1.跑测试时，运行特别慢。<br>2.debug根本进入不了断点。无法debug。</p>\n<p>之前以前一直知道不到解决方法，昨天在苦苦查寻下，找到了，解决方法。如果你的test跑的很慢可以借鉴，希望对大家有帮助，帮大家节约一些宝贵的时间。</p>\n<h2 id=\"问题一\"><a href=\"#问题一\" class=\"headerlink\" title=\"问题一\"></a>问题一</h2><h3 id=\"产生的原因：\"><a href=\"#产生的原因：\" class=\"headerlink\" title=\"产生的原因：\"></a>产生的原因：</h3><p>升级到macOS Sierra后，造成的。</p>\n<h3 id=\"解决方法：\"><a href=\"#解决方法：\" class=\"headerlink\" title=\"解决方法：\"></a>解决方法：</h3><p>命令行运行一下命令：<br>sudo sed -i bak “s^127.0.0.1.<em>^127.0.0.1 localhost $(hostname)^g” /etc/hosts<br>sudo sed -i bak “s^::1.</em>^::1 localhost $(hostname)^g” /etc/hosts<br>sudo ifconfig en0 down<br>sudo ifconfig en0 up</p>\n<p>其他方法参考下面链接</p>\n<p><a href=\"https://stackoverflow.com/questions/39636792/jvm-takes-a-long-time-to-resolve-ip-address-for-localhost/39698914#39698914\" target=\"_blank\" rel=\"external\">参考链接：</a></p>\n<h2 id=\"问题二\"><a href=\"#问题二\" class=\"headerlink\" title=\"问题二\"></a>问题二</h2><h3 id=\"产生的原因：-1\"><a href=\"#产生的原因：-1\" class=\"headerlink\" title=\"产生的原因：\"></a>产生的原因：</h3><p>设置了方法断点，idea会提示：method breakpoint may dramatically slow debugging</p>\n<h3 id=\"解决方法：-1\"><a href=\"#解决方法：-1\" class=\"headerlink\" title=\"解决方法：\"></a>解决方法：</h3><p>去除所有方法断点</p>\n<p><a href=\"http://blog.csdn.net/yanziit/article/details/73459795\" target=\"_blank\" rel=\"external\">参考链接：</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>hi, all </p>\n<p>我之前做单元覆盖率时遇到了两个问题。<br>1.跑测试时，运行特别慢。<br>2.debug根本进入不了断点。无法debug。</p>\n<p>之前以前一直知道不到解决方法，昨天在苦苦查寻下，找到了，解决方法。如果你的test跑的很慢可以借鉴，希望对大家有帮助，帮大家节约一些宝贵的时间。</p>\n<h2 id=\"问题一\"><a href=\"#问题一\" class=\"headerlink\" title=\"问题一\"></a>问题一</h2><h3 id=\"产生的原因：\"><a href=\"#产生的原因：\" class=\"headerlink\" title=\"产生的原因：\"></a>产生的原因：</h3><p>升级到macOS Sierra后，造成的。</p>\n<h3 id=\"解决方法：\"><a href=\"#解决方法：\" class=\"headerlink\" title=\"解决方法：\"></a>解决方法：</h3><p>命令行运行一下命令：<br>sudo sed -i bak “s^127.0.0.1.<em>^127.0.0.1 localhost $(hostname)^g” /etc/hosts<br>sudo sed -i bak “s^::1.</em>^::1 localhost $(hostname)^g” /etc/hosts<br>sudo ifconfig en0 down<br>sudo ifconfig en0 up</p>\n<p>其他方法参考下面链接</p>\n<p><a href=\"https://stackoverflow.com/questions/39636792/jvm-takes-a-long-time-to-resolve-ip-address-for-localhost/39698914#39698914\" target=\"_blank\" rel=\"external\">参考链接：</a></p>\n<h2 id=\"问题二\"><a href=\"#问题二\" class=\"headerlink\" title=\"问题二\"></a>问题二</h2><h3 id=\"产生的原因：-1\"><a href=\"#产生的原因：-1\" class=\"headerlink\" title=\"产生的原因：\"></a>产生的原因：</h3><p>设置了方法断点，idea会提示：method breakpoint may dramatically slow debugging</p>\n<h3 id=\"解决方法：-1\"><a href=\"#解决方法：-1\" class=\"headerlink\" title=\"解决方法：\"></a>解决方法：</h3><p>去除所有方法断点</p>\n<p><a href=\"http://blog.csdn.net/yanziit/article/details/73459795\" target=\"_blank\" rel=\"external\">参考链接：</a></p>\n"},{"title":"new draft","_content":"","source":"_drafts/new-draft.md","raw":"---\ntitle: new draft\ntags:\n---\n","slug":"new-draft","published":0,"date":"2017-08-13T09:58:50.000Z","updated":"2017-08-13T09:58:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd4d19zh0002ryx4k4fvqtli","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"JAVA与C++的比较","comments":1,"date":"2017-09-09T09:39:50.000Z","update":"2017-09-09T09:39:50.000Z","_content":"\n\nJava其实也是由C++发展而来，保留了C++的大部分内容，其编程方式类似于C++，但是摒弃了C++的诸多不合理之处，从根本上解决了C++的固有缺陷。使得Java句法更清晰，规模更小，更易学，同时更趋于健壮性，安全性和平台无关性。\n\n## 全局变量\n1. C++将函数和变量定义为全局的，而不加封装，增加了程序的负担 ，并且往往会由于使用不当而造成系统的崩溃。\n2. Java是完全面向对象的语言，类将方法和数据封装在其内，不能在所 用的类之外定义程序的全局变量，只能通过在一个类中定义public static的变量来实现一个全局变量，使得其它类可以访问和修改该变量。这种完善的包装保证了系统的安全性。\n\n## 字符串\n1. C++不支持字符串变量，使用“Null”终止符代表字符串的结束。\n2. Java字符串类作为Java语言的一部分定义，而不是作为外加的延伸部分，在整个系统中建立字符串和访问字符串元素的方法是一致的。\n\n## 函数\n1. 在C中，代码组织在函数中，函数可以访问程序的全局变量; C++增加了类，提供了类方法，但由于C++仍然支持C，所以C++程序中仍然可以使用C的函数，结果导致函数和方法混合使用，使得程序比较混乱 。\n2. Java没有函数。作为一种比C++更纯的面向对象的语言，强迫开发人员把所有例行程序包括在类中，可以更好的组织编码。\n\n## 操作符重载\n1. 操作符重载被认为是C++的突出特征。\n2. 为了保持Java语言尽可能的简单，Java不支持操作符重载。\n\n## 多重继承\n\n1. C++支持多重继承,允许许多父类派生一个子类，虽然功能强大,但使用复杂，而且会引起许多麻烦，编译程序实现也很不易。\n2. Java不支持多重继承，但允许一个类实现多个接口，即实现了C++的多重继承功能，又避免了C++的缺陷。\n\n## 预处理\n\n1. C++在编译过程中都有一个预编译阶段，即预处理器，为开发人员提供了方便，但也增加了编译的复杂性。\n2. Java允许预处理,但不支持预处理器功能，提供import语句实现类似的功能。\n\n## 结构和联合\n\n1. C++中用结构和联合来表示一定的数据结构，其成员的公有性带来了安全隐患。\n2. Java不支持结构和联合，通过类把数据结构及对该数据的操作封装在类中\n\n## 头文件\n\n1. 在C++语言中使用头文件声明类的原型和全局变量及库函数等，使得在大系统中对头文件的维护非常困难。\n2. Java不支持头文件，类成员的类型和访问权限都封装在类中，运行时 系统对访问进行控制，防止非法访问。\n\n## 类型转换\n1. 在C++中，会出现数据类型的隐含转换,涉及到自动强制类型转换，使得不安全因素大大增加。\n2. Java中系统要对对象的处理进行严格的相容性检查，防止不安全的转换。如果需要，必须由程序显式进行强制类型转换。\n\n## 数据类型的一致性\n\n1. 在C++语言中，不同的平台上，编译器对简单数据类型分别分配不同的字节数，导致了代码数据的不可移植性。\n2. 在Java中，采用基于IEEE标准的数据类型，无论任何硬件平台上对数据类型的位数分配总是固定的。\n\n\n## 内存管理\n\n1. C++语言中必须通过程序释放内存资源，增加了程序设计者的负担，再次释放已释放的内存块或释放未分配的内存块会造成系统崩溃，忘记释放不再使用的内存块也会逐渐耗尽系统资源。\n2. Java自动进行内存回收操作，当一个对象不再被用到时，无须使用内存回收器，只需要给它加上标签以示删除。无用内存的回收器在后台运行，利用空闲时间工作，保证了系统资源的完整性，避免了内存管理不周而引起的系统崩溃。\n\n## 指针\n\n1. 指针是C++语言中最灵活也最容易出错的数据类型，易出现由于指针误操作而导致的系统崩溃，同时指针操作内存时也经常出错。\n2. Java没有指针的概念，更有利于程序的安全。\n\n## goto语句\n\n1. goto语句一般用于无条件转移子程序和多结构分支技术，是C++中的合法语句，造成了程序结构的混乱，不易理解。\n2. Java不提供goto语句，使得程序更简洁易读，增强了程序的健壮性。\n\n\n# 对象分配\njava语言的对象是在堆上分配，只有方法的局部变量才在栈上分配。而C/C++语言有多种分配方式，既可以在堆上分配，又可以在栈上分配，减轻了内存回收的压力。另外C/C++语言主要由用户代码回收内存，不存在无用对象筛选的过程，效率要比垃圾回收机制要高。\n\n# 性能\n* Java语言在性能上的劣势都是为了换取开发效率上的优势而付出的代价。动态安全，动态扩展，垃圾回收这些“拖后腿”的特性都是为JAVA的开发效率做出了很大的贡献。\n* 何况java即时编译器能做的，C/C++的静态优化编译器不一定能够做：由于C/C++的静态编译，以运行性能监控为基础的优化措施它都无法进行，如调用频率预测，分支频率预测，裁剪未使用分支等，这些都是称为java语言独有的性能优势。\n\n## 实现\nJVM 的话是 C++ 实现的。Java 类库是 Java 实现的。java主要面向于实现，而c和c++则需要考虑效率了。","source":"_posts/JAVA与C-的比较.md","raw":"---\ntitle: JAVA与C++的比较\ncomments: true\ntags:\n  - C++\n  - JAVA\ncategories:\n  - C++\n  - JAVA\ndate: 2017-09-09 17:39:50\nupdate: 2017-09-09 17:39:50\n---\n\n\nJava其实也是由C++发展而来，保留了C++的大部分内容，其编程方式类似于C++，但是摒弃了C++的诸多不合理之处，从根本上解决了C++的固有缺陷。使得Java句法更清晰，规模更小，更易学，同时更趋于健壮性，安全性和平台无关性。\n\n## 全局变量\n1. C++将函数和变量定义为全局的，而不加封装，增加了程序的负担 ，并且往往会由于使用不当而造成系统的崩溃。\n2. Java是完全面向对象的语言，类将方法和数据封装在其内，不能在所 用的类之外定义程序的全局变量，只能通过在一个类中定义public static的变量来实现一个全局变量，使得其它类可以访问和修改该变量。这种完善的包装保证了系统的安全性。\n\n## 字符串\n1. C++不支持字符串变量，使用“Null”终止符代表字符串的结束。\n2. Java字符串类作为Java语言的一部分定义，而不是作为外加的延伸部分，在整个系统中建立字符串和访问字符串元素的方法是一致的。\n\n## 函数\n1. 在C中，代码组织在函数中，函数可以访问程序的全局变量; C++增加了类，提供了类方法，但由于C++仍然支持C，所以C++程序中仍然可以使用C的函数，结果导致函数和方法混合使用，使得程序比较混乱 。\n2. Java没有函数。作为一种比C++更纯的面向对象的语言，强迫开发人员把所有例行程序包括在类中，可以更好的组织编码。\n\n## 操作符重载\n1. 操作符重载被认为是C++的突出特征。\n2. 为了保持Java语言尽可能的简单，Java不支持操作符重载。\n\n## 多重继承\n\n1. C++支持多重继承,允许许多父类派生一个子类，虽然功能强大,但使用复杂，而且会引起许多麻烦，编译程序实现也很不易。\n2. Java不支持多重继承，但允许一个类实现多个接口，即实现了C++的多重继承功能，又避免了C++的缺陷。\n\n## 预处理\n\n1. C++在编译过程中都有一个预编译阶段，即预处理器，为开发人员提供了方便，但也增加了编译的复杂性。\n2. Java允许预处理,但不支持预处理器功能，提供import语句实现类似的功能。\n\n## 结构和联合\n\n1. C++中用结构和联合来表示一定的数据结构，其成员的公有性带来了安全隐患。\n2. Java不支持结构和联合，通过类把数据结构及对该数据的操作封装在类中\n\n## 头文件\n\n1. 在C++语言中使用头文件声明类的原型和全局变量及库函数等，使得在大系统中对头文件的维护非常困难。\n2. Java不支持头文件，类成员的类型和访问权限都封装在类中，运行时 系统对访问进行控制，防止非法访问。\n\n## 类型转换\n1. 在C++中，会出现数据类型的隐含转换,涉及到自动强制类型转换，使得不安全因素大大增加。\n2. Java中系统要对对象的处理进行严格的相容性检查，防止不安全的转换。如果需要，必须由程序显式进行强制类型转换。\n\n## 数据类型的一致性\n\n1. 在C++语言中，不同的平台上，编译器对简单数据类型分别分配不同的字节数，导致了代码数据的不可移植性。\n2. 在Java中，采用基于IEEE标准的数据类型，无论任何硬件平台上对数据类型的位数分配总是固定的。\n\n\n## 内存管理\n\n1. C++语言中必须通过程序释放内存资源，增加了程序设计者的负担，再次释放已释放的内存块或释放未分配的内存块会造成系统崩溃，忘记释放不再使用的内存块也会逐渐耗尽系统资源。\n2. Java自动进行内存回收操作，当一个对象不再被用到时，无须使用内存回收器，只需要给它加上标签以示删除。无用内存的回收器在后台运行，利用空闲时间工作，保证了系统资源的完整性，避免了内存管理不周而引起的系统崩溃。\n\n## 指针\n\n1. 指针是C++语言中最灵活也最容易出错的数据类型，易出现由于指针误操作而导致的系统崩溃，同时指针操作内存时也经常出错。\n2. Java没有指针的概念，更有利于程序的安全。\n\n## goto语句\n\n1. goto语句一般用于无条件转移子程序和多结构分支技术，是C++中的合法语句，造成了程序结构的混乱，不易理解。\n2. Java不提供goto语句，使得程序更简洁易读，增强了程序的健壮性。\n\n\n# 对象分配\njava语言的对象是在堆上分配，只有方法的局部变量才在栈上分配。而C/C++语言有多种分配方式，既可以在堆上分配，又可以在栈上分配，减轻了内存回收的压力。另外C/C++语言主要由用户代码回收内存，不存在无用对象筛选的过程，效率要比垃圾回收机制要高。\n\n# 性能\n* Java语言在性能上的劣势都是为了换取开发效率上的优势而付出的代价。动态安全，动态扩展，垃圾回收这些“拖后腿”的特性都是为JAVA的开发效率做出了很大的贡献。\n* 何况java即时编译器能做的，C/C++的静态优化编译器不一定能够做：由于C/C++的静态编译，以运行性能监控为基础的优化措施它都无法进行，如调用频率预测，分支频率预测，裁剪未使用分支等，这些都是称为java语言独有的性能优势。\n\n## 实现\nJVM 的话是 C++ 实现的。Java 类库是 Java 实现的。java主要面向于实现，而c和c++则需要考虑效率了。","slug":"JAVA与C-的比较","published":1,"updated":"2017-09-09T09:41:16.000Z","layout":"post","photos":[],"link":"","_id":"cjd4d19zk0006ryx42z578232","content":"<p>Java其实也是由C++发展而来，保留了C++的大部分内容，其编程方式类似于C++，但是摒弃了C++的诸多不合理之处，从根本上解决了C++的固有缺陷。使得Java句法更清晰，规模更小，更易学，同时更趋于健壮性，安全性和平台无关性。</p>\n<h2 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h2><ol>\n<li>C++将函数和变量定义为全局的，而不加封装，增加了程序的负担 ，并且往往会由于使用不当而造成系统的崩溃。</li>\n<li>Java是完全面向对象的语言，类将方法和数据封装在其内，不能在所 用的类之外定义程序的全局变量，只能通过在一个类中定义public static的变量来实现一个全局变量，使得其它类可以访问和修改该变量。这种完善的包装保证了系统的安全性。</li>\n</ol>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><ol>\n<li>C++不支持字符串变量，使用“Null”终止符代表字符串的结束。</li>\n<li>Java字符串类作为Java语言的一部分定义，而不是作为外加的延伸部分，在整个系统中建立字符串和访问字符串元素的方法是一致的。</li>\n</ol>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><ol>\n<li>在C中，代码组织在函数中，函数可以访问程序的全局变量; C++增加了类，提供了类方法，但由于C++仍然支持C，所以C++程序中仍然可以使用C的函数，结果导致函数和方法混合使用，使得程序比较混乱 。</li>\n<li>Java没有函数。作为一种比C++更纯的面向对象的语言，强迫开发人员把所有例行程序包括在类中，可以更好的组织编码。</li>\n</ol>\n<h2 id=\"操作符重载\"><a href=\"#操作符重载\" class=\"headerlink\" title=\"操作符重载\"></a>操作符重载</h2><ol>\n<li>操作符重载被认为是C++的突出特征。</li>\n<li>为了保持Java语言尽可能的简单，Java不支持操作符重载。</li>\n</ol>\n<h2 id=\"多重继承\"><a href=\"#多重继承\" class=\"headerlink\" title=\"多重继承\"></a>多重继承</h2><ol>\n<li>C++支持多重继承,允许许多父类派生一个子类，虽然功能强大,但使用复杂，而且会引起许多麻烦，编译程序实现也很不易。</li>\n<li>Java不支持多重继承，但允许一个类实现多个接口，即实现了C++的多重继承功能，又避免了C++的缺陷。</li>\n</ol>\n<h2 id=\"预处理\"><a href=\"#预处理\" class=\"headerlink\" title=\"预处理\"></a>预处理</h2><ol>\n<li>C++在编译过程中都有一个预编译阶段，即预处理器，为开发人员提供了方便，但也增加了编译的复杂性。</li>\n<li>Java允许预处理,但不支持预处理器功能，提供import语句实现类似的功能。</li>\n</ol>\n<h2 id=\"结构和联合\"><a href=\"#结构和联合\" class=\"headerlink\" title=\"结构和联合\"></a>结构和联合</h2><ol>\n<li>C++中用结构和联合来表示一定的数据结构，其成员的公有性带来了安全隐患。</li>\n<li>Java不支持结构和联合，通过类把数据结构及对该数据的操作封装在类中</li>\n</ol>\n<h2 id=\"头文件\"><a href=\"#头文件\" class=\"headerlink\" title=\"头文件\"></a>头文件</h2><ol>\n<li>在C++语言中使用头文件声明类的原型和全局变量及库函数等，使得在大系统中对头文件的维护非常困难。</li>\n<li>Java不支持头文件，类成员的类型和访问权限都封装在类中，运行时 系统对访问进行控制，防止非法访问。</li>\n</ol>\n<h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h2><ol>\n<li>在C++中，会出现数据类型的隐含转换,涉及到自动强制类型转换，使得不安全因素大大增加。</li>\n<li>Java中系统要对对象的处理进行严格的相容性检查，防止不安全的转换。如果需要，必须由程序显式进行强制类型转换。</li>\n</ol>\n<h2 id=\"数据类型的一致性\"><a href=\"#数据类型的一致性\" class=\"headerlink\" title=\"数据类型的一致性\"></a>数据类型的一致性</h2><ol>\n<li>在C++语言中，不同的平台上，编译器对简单数据类型分别分配不同的字节数，导致了代码数据的不可移植性。</li>\n<li>在Java中，采用基于IEEE标准的数据类型，无论任何硬件平台上对数据类型的位数分配总是固定的。</li>\n</ol>\n<h2 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h2><ol>\n<li>C++语言中必须通过程序释放内存资源，增加了程序设计者的负担，再次释放已释放的内存块或释放未分配的内存块会造成系统崩溃，忘记释放不再使用的内存块也会逐渐耗尽系统资源。</li>\n<li>Java自动进行内存回收操作，当一个对象不再被用到时，无须使用内存回收器，只需要给它加上标签以示删除。无用内存的回收器在后台运行，利用空闲时间工作，保证了系统资源的完整性，避免了内存管理不周而引起的系统崩溃。</li>\n</ol>\n<h2 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h2><ol>\n<li>指针是C++语言中最灵活也最容易出错的数据类型，易出现由于指针误操作而导致的系统崩溃，同时指针操作内存时也经常出错。</li>\n<li>Java没有指针的概念，更有利于程序的安全。</li>\n</ol>\n<h2 id=\"goto语句\"><a href=\"#goto语句\" class=\"headerlink\" title=\"goto语句\"></a>goto语句</h2><ol>\n<li>goto语句一般用于无条件转移子程序和多结构分支技术，是C++中的合法语句，造成了程序结构的混乱，不易理解。</li>\n<li>Java不提供goto语句，使得程序更简洁易读，增强了程序的健壮性。</li>\n</ol>\n<h1 id=\"对象分配\"><a href=\"#对象分配\" class=\"headerlink\" title=\"对象分配\"></a>对象分配</h1><p>java语言的对象是在堆上分配，只有方法的局部变量才在栈上分配。而C/C++语言有多种分配方式，既可以在堆上分配，又可以在栈上分配，减轻了内存回收的压力。另外C/C++语言主要由用户代码回收内存，不存在无用对象筛选的过程，效率要比垃圾回收机制要高。</p>\n<h1 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h1><ul>\n<li>Java语言在性能上的劣势都是为了换取开发效率上的优势而付出的代价。动态安全，动态扩展，垃圾回收这些“拖后腿”的特性都是为JAVA的开发效率做出了很大的贡献。</li>\n<li>何况java即时编译器能做的，C/C++的静态优化编译器不一定能够做：由于C/C++的静态编译，以运行性能监控为基础的优化措施它都无法进行，如调用频率预测，分支频率预测，裁剪未使用分支等，这些都是称为java语言独有的性能优势。</li>\n</ul>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>JVM 的话是 C++ 实现的。Java 类库是 Java 实现的。java主要面向于实现，而c和c++则需要考虑效率了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Java其实也是由C++发展而来，保留了C++的大部分内容，其编程方式类似于C++，但是摒弃了C++的诸多不合理之处，从根本上解决了C++的固有缺陷。使得Java句法更清晰，规模更小，更易学，同时更趋于健壮性，安全性和平台无关性。</p>\n<h2 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h2><ol>\n<li>C++将函数和变量定义为全局的，而不加封装，增加了程序的负担 ，并且往往会由于使用不当而造成系统的崩溃。</li>\n<li>Java是完全面向对象的语言，类将方法和数据封装在其内，不能在所 用的类之外定义程序的全局变量，只能通过在一个类中定义public static的变量来实现一个全局变量，使得其它类可以访问和修改该变量。这种完善的包装保证了系统的安全性。</li>\n</ol>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><ol>\n<li>C++不支持字符串变量，使用“Null”终止符代表字符串的结束。</li>\n<li>Java字符串类作为Java语言的一部分定义，而不是作为外加的延伸部分，在整个系统中建立字符串和访问字符串元素的方法是一致的。</li>\n</ol>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><ol>\n<li>在C中，代码组织在函数中，函数可以访问程序的全局变量; C++增加了类，提供了类方法，但由于C++仍然支持C，所以C++程序中仍然可以使用C的函数，结果导致函数和方法混合使用，使得程序比较混乱 。</li>\n<li>Java没有函数。作为一种比C++更纯的面向对象的语言，强迫开发人员把所有例行程序包括在类中，可以更好的组织编码。</li>\n</ol>\n<h2 id=\"操作符重载\"><a href=\"#操作符重载\" class=\"headerlink\" title=\"操作符重载\"></a>操作符重载</h2><ol>\n<li>操作符重载被认为是C++的突出特征。</li>\n<li>为了保持Java语言尽可能的简单，Java不支持操作符重载。</li>\n</ol>\n<h2 id=\"多重继承\"><a href=\"#多重继承\" class=\"headerlink\" title=\"多重继承\"></a>多重继承</h2><ol>\n<li>C++支持多重继承,允许许多父类派生一个子类，虽然功能强大,但使用复杂，而且会引起许多麻烦，编译程序实现也很不易。</li>\n<li>Java不支持多重继承，但允许一个类实现多个接口，即实现了C++的多重继承功能，又避免了C++的缺陷。</li>\n</ol>\n<h2 id=\"预处理\"><a href=\"#预处理\" class=\"headerlink\" title=\"预处理\"></a>预处理</h2><ol>\n<li>C++在编译过程中都有一个预编译阶段，即预处理器，为开发人员提供了方便，但也增加了编译的复杂性。</li>\n<li>Java允许预处理,但不支持预处理器功能，提供import语句实现类似的功能。</li>\n</ol>\n<h2 id=\"结构和联合\"><a href=\"#结构和联合\" class=\"headerlink\" title=\"结构和联合\"></a>结构和联合</h2><ol>\n<li>C++中用结构和联合来表示一定的数据结构，其成员的公有性带来了安全隐患。</li>\n<li>Java不支持结构和联合，通过类把数据结构及对该数据的操作封装在类中</li>\n</ol>\n<h2 id=\"头文件\"><a href=\"#头文件\" class=\"headerlink\" title=\"头文件\"></a>头文件</h2><ol>\n<li>在C++语言中使用头文件声明类的原型和全局变量及库函数等，使得在大系统中对头文件的维护非常困难。</li>\n<li>Java不支持头文件，类成员的类型和访问权限都封装在类中，运行时 系统对访问进行控制，防止非法访问。</li>\n</ol>\n<h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h2><ol>\n<li>在C++中，会出现数据类型的隐含转换,涉及到自动强制类型转换，使得不安全因素大大增加。</li>\n<li>Java中系统要对对象的处理进行严格的相容性检查，防止不安全的转换。如果需要，必须由程序显式进行强制类型转换。</li>\n</ol>\n<h2 id=\"数据类型的一致性\"><a href=\"#数据类型的一致性\" class=\"headerlink\" title=\"数据类型的一致性\"></a>数据类型的一致性</h2><ol>\n<li>在C++语言中，不同的平台上，编译器对简单数据类型分别分配不同的字节数，导致了代码数据的不可移植性。</li>\n<li>在Java中，采用基于IEEE标准的数据类型，无论任何硬件平台上对数据类型的位数分配总是固定的。</li>\n</ol>\n<h2 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h2><ol>\n<li>C++语言中必须通过程序释放内存资源，增加了程序设计者的负担，再次释放已释放的内存块或释放未分配的内存块会造成系统崩溃，忘记释放不再使用的内存块也会逐渐耗尽系统资源。</li>\n<li>Java自动进行内存回收操作，当一个对象不再被用到时，无须使用内存回收器，只需要给它加上标签以示删除。无用内存的回收器在后台运行，利用空闲时间工作，保证了系统资源的完整性，避免了内存管理不周而引起的系统崩溃。</li>\n</ol>\n<h2 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h2><ol>\n<li>指针是C++语言中最灵活也最容易出错的数据类型，易出现由于指针误操作而导致的系统崩溃，同时指针操作内存时也经常出错。</li>\n<li>Java没有指针的概念，更有利于程序的安全。</li>\n</ol>\n<h2 id=\"goto语句\"><a href=\"#goto语句\" class=\"headerlink\" title=\"goto语句\"></a>goto语句</h2><ol>\n<li>goto语句一般用于无条件转移子程序和多结构分支技术，是C++中的合法语句，造成了程序结构的混乱，不易理解。</li>\n<li>Java不提供goto语句，使得程序更简洁易读，增强了程序的健壮性。</li>\n</ol>\n<h1 id=\"对象分配\"><a href=\"#对象分配\" class=\"headerlink\" title=\"对象分配\"></a>对象分配</h1><p>java语言的对象是在堆上分配，只有方法的局部变量才在栈上分配。而C/C++语言有多种分配方式，既可以在堆上分配，又可以在栈上分配，减轻了内存回收的压力。另外C/C++语言主要由用户代码回收内存，不存在无用对象筛选的过程，效率要比垃圾回收机制要高。</p>\n<h1 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h1><ul>\n<li>Java语言在性能上的劣势都是为了换取开发效率上的优势而付出的代价。动态安全，动态扩展，垃圾回收这些“拖后腿”的特性都是为JAVA的开发效率做出了很大的贡献。</li>\n<li>何况java即时编译器能做的，C/C++的静态优化编译器不一定能够做：由于C/C++的静态编译，以运行性能监控为基础的优化措施它都无法进行，如调用频率预测，分支频率预测，裁剪未使用分支等，这些都是称为java语言独有的性能优势。</li>\n</ul>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>JVM 的话是 C++ 实现的。Java 类库是 Java 实现的。java主要面向于实现，而c和c++则需要考虑效率了。</p>\n"},{"title":"JIT","comments":1,"date":"2017-09-09T09:41:33.000Z","update":"2017-09-09T09:41:33.000Z","_content":"\n# JIT（just in time,即时编译技术）  \n\n## JIT的出现\n\n通常javac将程序源代码编译，转换成java字节码，JVM通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢。为了提高执行速度，引入了JIT技术。\n\n## JVM的三种执行模式\n\n1. 解释模式：对于解释执行，不经过jit直接由解释器解释执行所有字节码，执行效率不高。\n2. 编译模式：编译执行不加筛选的将全部代码进行编译机器码不论其执行频率是否有编译价值，在程序响应时间的限制下，编译器没法采用编译耗时较高的优化技术（因为JIT的编译是首次运行或启动的时候进行的！），所以，在纯编译执行模式下的java程序执行效率跟C/C++也是具有较大差距的。\n3. 混合模式：源代码经javac编译成字节码，class文件；程序字节码经过JIT环境变量进行判断，是否属于“热点代码”（多次调用的方法，或循环等）；如是，走JIT编译为具体硬件处理器（如sparc、intel）机器码；如否，则直接由解释器解释执行。\n\n新版本的jvm默认都是采用混合执行模式，优势：当程序需要迅速启动和执行的时候，解析器首先发挥作用，省去编译的时间，立即执行。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。\n \n## JIT编辑器（即时编译器（Just In Time Compiler) 简称JIT）\n\n1. Java JIT（just in time）即时编译器。但此编译器与通常说的javac那个编译器不同，它其实是将字节码编译为硬件可执行的机器码的。\n2. JIT编译器（即时编译器），当虚拟机发现某个方法或代码块运行特别频繁时，就会把这些代码认定为“Hot Spot Code”（热点代码），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，完成这项任务的正是JIT编译器。\n3. HotSpot虚拟机中内置了两个JIT编译器：Client Complier和Server Complier，分别用在客户端和服务端，目前主流的HotSpot虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作。\n4. Client Compiler和Server Compiler会实现分层编译（JDK 1.7默认有）。\n\t* 第0层 程序解析执行，解析器不开启性能监控，可触发第一层编译。\n\t* 第1层 编译成本地相关代码，进行简单优化\n\t* 第2层 除编译成本地相关代码外，还进行成编译耗时较长的优化。\n\t* Client Compiler获得更高的编译速度 Server Compiler获得更好的编译质量，无须承担性能监控的任务\n4. 编译器编译的“热点代码”有两类：两种情况，编译器都是以整个方法作为编译对象。\n\t* 被多次调用的方法。\n\t* 被多次调用的循环体。\n\n5. Hot Spot Detection（热点探测）是不是需要触发即时编译，需要进行热点探测。  \n \t目前主要的热点 判定方式有以下两种\n \t\n * 基于采样的热点探测：采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那这段方法代码就是“热点代码”。这种探测方法的好处是实现简单高效，还可以很容易地获取方法调用关系，缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。\n * 基于计数器的热点探测：采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，如果执行次数超过一定的阀值，就认为它是“热点方法”。这种统计方法实现复杂一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果相对更加精确严谨。\n\n6. 在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两个计数器：方法调用计数器和回边计数器。\n * 方法调用计数器用来统计方法调用的次数，在默认设置下，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间内方法被调用的次数。\n * 回边计数器用于统计一个方法中循环体代码执行的次数（准确地说，应该是回边的次数，因为并非所有的循环都是回边），在字节码中遇到控制流向后跳转的指令就称为“回边”。\n \n  在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阀值，当计数器的值超过了阀值，就会触发JIT编译。触发了JIT编译后，在默认设置下，执行引擎并不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被编译器编译完成为止（编译工作在后台线程中进行）。当编译工作完成后，下一次调用该方法或代码时，就会使用已编译的版本。\n \n  \n## 作用\n\n能够加速java程序的执行速度。由于JIT对每条字节码都进行编译，造成了编译过程负担过重。为了避免这种情况，当前的JIT只对经常执行的字节码进行编译，如循环等。\n \n \n## JVM编译优化技术-----逃逸分析\n\n逃逸分析：当一个对象被定义后，可能被外部方法引用，例如被当作参数传递到其他方法中，称为方法逃逸。可以被其他线程访问，这个称为线程逃逸。若能证明这个对象不会逃逸到其他方法或线程中，就可以进行高效的优化。\n\n1. 栈上分配　 在堆上分配对象内存，回收整理内存需要消耗时间，若在栈上分配内存将是个不错的主意。被对象占用的空间就可以随帧栈的就出栈而销毁。大量的对象随方法的结束而自动销毁，GC也减轻压力。\n2. 同步消除　　 若不会线程逃逸，不会有竞争，方法上的同步措施就会消除。\n3. 标量替换　 JAVA的原始类型无法再分就是一个标量，对象就是聚合量。对象若可以被拆分成标量，直接在栈上分配，就是类似栈上分配内存，甚至分配到高速缓存中。\n\n逃逸分析不成熟的原因：不能保证逃逸分析的性能收益大于它的消耗。\n\n## 其他优化技术\nJDK设计团队，几乎把所有的优化措施都集中在即时编译器中。一般认为，编译器的本地会比javac的产生的字节码更优秀。\n常见的优化技术很多：例如公共表达式的消除，数组边界检查的消除，方法的内联（最重要的优化技术）。\n","source":"_posts/JIT.md","raw":"---\ntitle: JIT\ncomments: true\ntags:\n  - JAVA\n  - JVM\n  - JIT\ncategories:\n  - JAVA\ndate: 2017-09-09 17:41:33\nupdate: 2017-09-09 17:41:33\n\n---\n\n# JIT（just in time,即时编译技术）  \n\n## JIT的出现\n\n通常javac将程序源代码编译，转换成java字节码，JVM通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢。为了提高执行速度，引入了JIT技术。\n\n## JVM的三种执行模式\n\n1. 解释模式：对于解释执行，不经过jit直接由解释器解释执行所有字节码，执行效率不高。\n2. 编译模式：编译执行不加筛选的将全部代码进行编译机器码不论其执行频率是否有编译价值，在程序响应时间的限制下，编译器没法采用编译耗时较高的优化技术（因为JIT的编译是首次运行或启动的时候进行的！），所以，在纯编译执行模式下的java程序执行效率跟C/C++也是具有较大差距的。\n3. 混合模式：源代码经javac编译成字节码，class文件；程序字节码经过JIT环境变量进行判断，是否属于“热点代码”（多次调用的方法，或循环等）；如是，走JIT编译为具体硬件处理器（如sparc、intel）机器码；如否，则直接由解释器解释执行。\n\n新版本的jvm默认都是采用混合执行模式，优势：当程序需要迅速启动和执行的时候，解析器首先发挥作用，省去编译的时间，立即执行。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。\n \n## JIT编辑器（即时编译器（Just In Time Compiler) 简称JIT）\n\n1. Java JIT（just in time）即时编译器。但此编译器与通常说的javac那个编译器不同，它其实是将字节码编译为硬件可执行的机器码的。\n2. JIT编译器（即时编译器），当虚拟机发现某个方法或代码块运行特别频繁时，就会把这些代码认定为“Hot Spot Code”（热点代码），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，完成这项任务的正是JIT编译器。\n3. HotSpot虚拟机中内置了两个JIT编译器：Client Complier和Server Complier，分别用在客户端和服务端，目前主流的HotSpot虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作。\n4. Client Compiler和Server Compiler会实现分层编译（JDK 1.7默认有）。\n\t* 第0层 程序解析执行，解析器不开启性能监控，可触发第一层编译。\n\t* 第1层 编译成本地相关代码，进行简单优化\n\t* 第2层 除编译成本地相关代码外，还进行成编译耗时较长的优化。\n\t* Client Compiler获得更高的编译速度 Server Compiler获得更好的编译质量，无须承担性能监控的任务\n4. 编译器编译的“热点代码”有两类：两种情况，编译器都是以整个方法作为编译对象。\n\t* 被多次调用的方法。\n\t* 被多次调用的循环体。\n\n5. Hot Spot Detection（热点探测）是不是需要触发即时编译，需要进行热点探测。  \n \t目前主要的热点 判定方式有以下两种\n \t\n * 基于采样的热点探测：采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那这段方法代码就是“热点代码”。这种探测方法的好处是实现简单高效，还可以很容易地获取方法调用关系，缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。\n * 基于计数器的热点探测：采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，如果执行次数超过一定的阀值，就认为它是“热点方法”。这种统计方法实现复杂一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果相对更加精确严谨。\n\n6. 在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两个计数器：方法调用计数器和回边计数器。\n * 方法调用计数器用来统计方法调用的次数，在默认设置下，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间内方法被调用的次数。\n * 回边计数器用于统计一个方法中循环体代码执行的次数（准确地说，应该是回边的次数，因为并非所有的循环都是回边），在字节码中遇到控制流向后跳转的指令就称为“回边”。\n \n  在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阀值，当计数器的值超过了阀值，就会触发JIT编译。触发了JIT编译后，在默认设置下，执行引擎并不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被编译器编译完成为止（编译工作在后台线程中进行）。当编译工作完成后，下一次调用该方法或代码时，就会使用已编译的版本。\n \n  \n## 作用\n\n能够加速java程序的执行速度。由于JIT对每条字节码都进行编译，造成了编译过程负担过重。为了避免这种情况，当前的JIT只对经常执行的字节码进行编译，如循环等。\n \n \n## JVM编译优化技术-----逃逸分析\n\n逃逸分析：当一个对象被定义后，可能被外部方法引用，例如被当作参数传递到其他方法中，称为方法逃逸。可以被其他线程访问，这个称为线程逃逸。若能证明这个对象不会逃逸到其他方法或线程中，就可以进行高效的优化。\n\n1. 栈上分配　 在堆上分配对象内存，回收整理内存需要消耗时间，若在栈上分配内存将是个不错的主意。被对象占用的空间就可以随帧栈的就出栈而销毁。大量的对象随方法的结束而自动销毁，GC也减轻压力。\n2. 同步消除　　 若不会线程逃逸，不会有竞争，方法上的同步措施就会消除。\n3. 标量替换　 JAVA的原始类型无法再分就是一个标量，对象就是聚合量。对象若可以被拆分成标量，直接在栈上分配，就是类似栈上分配内存，甚至分配到高速缓存中。\n\n逃逸分析不成熟的原因：不能保证逃逸分析的性能收益大于它的消耗。\n\n## 其他优化技术\nJDK设计团队，几乎把所有的优化措施都集中在即时编译器中。一般认为，编译器的本地会比javac的产生的字节码更优秀。\n常见的优化技术很多：例如公共表达式的消除，数组边界检查的消除，方法的内联（最重要的优化技术）。\n","slug":"JIT","published":1,"updated":"2017-09-09T09:42:18.000Z","layout":"post","photos":[],"link":"","_id":"cjd4d19zm0008ryx4gkeqyiet","content":"<h1 id=\"JIT（just-in-time-即时编译技术）\"><a href=\"#JIT（just-in-time-即时编译技术）\" class=\"headerlink\" title=\"JIT（just in time,即时编译技术）\"></a>JIT（just in time,即时编译技术）</h1><h2 id=\"JIT的出现\"><a href=\"#JIT的出现\" class=\"headerlink\" title=\"JIT的出现\"></a>JIT的出现</h2><p>通常javac将程序源代码编译，转换成java字节码，JVM通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢。为了提高执行速度，引入了JIT技术。</p>\n<h2 id=\"JVM的三种执行模式\"><a href=\"#JVM的三种执行模式\" class=\"headerlink\" title=\"JVM的三种执行模式\"></a>JVM的三种执行模式</h2><ol>\n<li>解释模式：对于解释执行，不经过jit直接由解释器解释执行所有字节码，执行效率不高。</li>\n<li>编译模式：编译执行不加筛选的将全部代码进行编译机器码不论其执行频率是否有编译价值，在程序响应时间的限制下，编译器没法采用编译耗时较高的优化技术（因为JIT的编译是首次运行或启动的时候进行的！），所以，在纯编译执行模式下的java程序执行效率跟C/C++也是具有较大差距的。</li>\n<li>混合模式：源代码经javac编译成字节码，class文件；程序字节码经过JIT环境变量进行判断，是否属于“热点代码”（多次调用的方法，或循环等）；如是，走JIT编译为具体硬件处理器（如sparc、intel）机器码；如否，则直接由解释器解释执行。</li>\n</ol>\n<p>新版本的jvm默认都是采用混合执行模式，优势：当程序需要迅速启动和执行的时候，解析器首先发挥作用，省去编译的时间，立即执行。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</p>\n<h2 id=\"JIT编辑器（即时编译器（Just-In-Time-Compiler-简称JIT）\"><a href=\"#JIT编辑器（即时编译器（Just-In-Time-Compiler-简称JIT）\" class=\"headerlink\" title=\"JIT编辑器（即时编译器（Just In Time Compiler) 简称JIT）\"></a>JIT编辑器（即时编译器（Just In Time Compiler) 简称JIT）</h2><ol>\n<li>Java JIT（just in time）即时编译器。但此编译器与通常说的javac那个编译器不同，它其实是将字节码编译为硬件可执行的机器码的。</li>\n<li>JIT编译器（即时编译器），当虚拟机发现某个方法或代码块运行特别频繁时，就会把这些代码认定为“Hot Spot Code”（热点代码），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，完成这项任务的正是JIT编译器。</li>\n<li>HotSpot虚拟机中内置了两个JIT编译器：Client Complier和Server Complier，分别用在客户端和服务端，目前主流的HotSpot虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作。</li>\n<li>Client Compiler和Server Compiler会实现分层编译（JDK 1.7默认有）。<ul>\n<li>第0层 程序解析执行，解析器不开启性能监控，可触发第一层编译。</li>\n<li>第1层 编译成本地相关代码，进行简单优化</li>\n<li>第2层 除编译成本地相关代码外，还进行成编译耗时较长的优化。</li>\n<li>Client Compiler获得更高的编译速度 Server Compiler获得更好的编译质量，无须承担性能监控的任务</li>\n</ul>\n</li>\n<li><p>编译器编译的“热点代码”有两类：两种情况，编译器都是以整个方法作为编译对象。</p>\n<ul>\n<li>被多次调用的方法。</li>\n<li>被多次调用的循环体。</li>\n</ul>\n</li>\n<li><p>Hot Spot Detection（热点探测）是不是需要触发即时编译，需要进行热点探测。<br>  目前主要的热点 判定方式有以下两种</p>\n<ul>\n<li>基于采样的热点探测：采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那这段方法代码就是“热点代码”。这种探测方法的好处是实现简单高效，还可以很容易地获取方法调用关系，缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</li>\n<li>基于计数器的热点探测：采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，如果执行次数超过一定的阀值，就认为它是“热点方法”。这种统计方法实现复杂一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果相对更加精确严谨。</li>\n</ul>\n</li>\n<li><p>在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两个计数器：方法调用计数器和回边计数器。</p>\n<ul>\n<li>方法调用计数器用来统计方法调用的次数，在默认设置下，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间内方法被调用的次数。</li>\n<li>回边计数器用于统计一个方法中循环体代码执行的次数（准确地说，应该是回边的次数，因为并非所有的循环都是回边），在字节码中遇到控制流向后跳转的指令就称为“回边”。</li>\n</ul>\n<p>在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阀值，当计数器的值超过了阀值，就会触发JIT编译。触发了JIT编译后，在默认设置下，执行引擎并不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被编译器编译完成为止（编译工作在后台线程中进行）。当编译工作完成后，下一次调用该方法或代码时，就会使用已编译的版本。</p>\n</li>\n</ol>\n<h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>能够加速java程序的执行速度。由于JIT对每条字节码都进行编译，造成了编译过程负担过重。为了避免这种情况，当前的JIT只对经常执行的字节码进行编译，如循环等。</p>\n<h2 id=\"JVM编译优化技术—–逃逸分析\"><a href=\"#JVM编译优化技术—–逃逸分析\" class=\"headerlink\" title=\"JVM编译优化技术—–逃逸分析\"></a>JVM编译优化技术—–逃逸分析</h2><p>逃逸分析：当一个对象被定义后，可能被外部方法引用，例如被当作参数传递到其他方法中，称为方法逃逸。可以被其他线程访问，这个称为线程逃逸。若能证明这个对象不会逃逸到其他方法或线程中，就可以进行高效的优化。</p>\n<ol>\n<li>栈上分配　 在堆上分配对象内存，回收整理内存需要消耗时间，若在栈上分配内存将是个不错的主意。被对象占用的空间就可以随帧栈的就出栈而销毁。大量的对象随方法的结束而自动销毁，GC也减轻压力。</li>\n<li>同步消除　　 若不会线程逃逸，不会有竞争，方法上的同步措施就会消除。</li>\n<li>标量替换　 JAVA的原始类型无法再分就是一个标量，对象就是聚合量。对象若可以被拆分成标量，直接在栈上分配，就是类似栈上分配内存，甚至分配到高速缓存中。</li>\n</ol>\n<p>逃逸分析不成熟的原因：不能保证逃逸分析的性能收益大于它的消耗。</p>\n<h2 id=\"其他优化技术\"><a href=\"#其他优化技术\" class=\"headerlink\" title=\"其他优化技术\"></a>其他优化技术</h2><p>JDK设计团队，几乎把所有的优化措施都集中在即时编译器中。一般认为，编译器的本地会比javac的产生的字节码更优秀。<br>常见的优化技术很多：例如公共表达式的消除，数组边界检查的消除，方法的内联（最重要的优化技术）。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JIT（just-in-time-即时编译技术）\"><a href=\"#JIT（just-in-time-即时编译技术）\" class=\"headerlink\" title=\"JIT（just in time,即时编译技术）\"></a>JIT（just in time,即时编译技术）</h1><h2 id=\"JIT的出现\"><a href=\"#JIT的出现\" class=\"headerlink\" title=\"JIT的出现\"></a>JIT的出现</h2><p>通常javac将程序源代码编译，转换成java字节码，JVM通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢。为了提高执行速度，引入了JIT技术。</p>\n<h2 id=\"JVM的三种执行模式\"><a href=\"#JVM的三种执行模式\" class=\"headerlink\" title=\"JVM的三种执行模式\"></a>JVM的三种执行模式</h2><ol>\n<li>解释模式：对于解释执行，不经过jit直接由解释器解释执行所有字节码，执行效率不高。</li>\n<li>编译模式：编译执行不加筛选的将全部代码进行编译机器码不论其执行频率是否有编译价值，在程序响应时间的限制下，编译器没法采用编译耗时较高的优化技术（因为JIT的编译是首次运行或启动的时候进行的！），所以，在纯编译执行模式下的java程序执行效率跟C/C++也是具有较大差距的。</li>\n<li>混合模式：源代码经javac编译成字节码，class文件；程序字节码经过JIT环境变量进行判断，是否属于“热点代码”（多次调用的方法，或循环等）；如是，走JIT编译为具体硬件处理器（如sparc、intel）机器码；如否，则直接由解释器解释执行。</li>\n</ol>\n<p>新版本的jvm默认都是采用混合执行模式，优势：当程序需要迅速启动和执行的时候，解析器首先发挥作用，省去编译的时间，立即执行。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</p>\n<h2 id=\"JIT编辑器（即时编译器（Just-In-Time-Compiler-简称JIT）\"><a href=\"#JIT编辑器（即时编译器（Just-In-Time-Compiler-简称JIT）\" class=\"headerlink\" title=\"JIT编辑器（即时编译器（Just In Time Compiler) 简称JIT）\"></a>JIT编辑器（即时编译器（Just In Time Compiler) 简称JIT）</h2><ol>\n<li>Java JIT（just in time）即时编译器。但此编译器与通常说的javac那个编译器不同，它其实是将字节码编译为硬件可执行的机器码的。</li>\n<li>JIT编译器（即时编译器），当虚拟机发现某个方法或代码块运行特别频繁时，就会把这些代码认定为“Hot Spot Code”（热点代码），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，完成这项任务的正是JIT编译器。</li>\n<li>HotSpot虚拟机中内置了两个JIT编译器：Client Complier和Server Complier，分别用在客户端和服务端，目前主流的HotSpot虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作。</li>\n<li>Client Compiler和Server Compiler会实现分层编译（JDK 1.7默认有）。<ul>\n<li>第0层 程序解析执行，解析器不开启性能监控，可触发第一层编译。</li>\n<li>第1层 编译成本地相关代码，进行简单优化</li>\n<li>第2层 除编译成本地相关代码外，还进行成编译耗时较长的优化。</li>\n<li>Client Compiler获得更高的编译速度 Server Compiler获得更好的编译质量，无须承担性能监控的任务</li>\n</ul>\n</li>\n<li><p>编译器编译的“热点代码”有两类：两种情况，编译器都是以整个方法作为编译对象。</p>\n<ul>\n<li>被多次调用的方法。</li>\n<li>被多次调用的循环体。</li>\n</ul>\n</li>\n<li><p>Hot Spot Detection（热点探测）是不是需要触发即时编译，需要进行热点探测。<br>  目前主要的热点 判定方式有以下两种</p>\n<ul>\n<li>基于采样的热点探测：采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那这段方法代码就是“热点代码”。这种探测方法的好处是实现简单高效，还可以很容易地获取方法调用关系，缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</li>\n<li>基于计数器的热点探测：采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，如果执行次数超过一定的阀值，就认为它是“热点方法”。这种统计方法实现复杂一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果相对更加精确严谨。</li>\n</ul>\n</li>\n<li><p>在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两个计数器：方法调用计数器和回边计数器。</p>\n<ul>\n<li>方法调用计数器用来统计方法调用的次数，在默认设置下，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间内方法被调用的次数。</li>\n<li>回边计数器用于统计一个方法中循环体代码执行的次数（准确地说，应该是回边的次数，因为并非所有的循环都是回边），在字节码中遇到控制流向后跳转的指令就称为“回边”。</li>\n</ul>\n<p>在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阀值，当计数器的值超过了阀值，就会触发JIT编译。触发了JIT编译后，在默认设置下，执行引擎并不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被编译器编译完成为止（编译工作在后台线程中进行）。当编译工作完成后，下一次调用该方法或代码时，就会使用已编译的版本。</p>\n</li>\n</ol>\n<h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>能够加速java程序的执行速度。由于JIT对每条字节码都进行编译，造成了编译过程负担过重。为了避免这种情况，当前的JIT只对经常执行的字节码进行编译，如循环等。</p>\n<h2 id=\"JVM编译优化技术—–逃逸分析\"><a href=\"#JVM编译优化技术—–逃逸分析\" class=\"headerlink\" title=\"JVM编译优化技术—–逃逸分析\"></a>JVM编译优化技术—–逃逸分析</h2><p>逃逸分析：当一个对象被定义后，可能被外部方法引用，例如被当作参数传递到其他方法中，称为方法逃逸。可以被其他线程访问，这个称为线程逃逸。若能证明这个对象不会逃逸到其他方法或线程中，就可以进行高效的优化。</p>\n<ol>\n<li>栈上分配　 在堆上分配对象内存，回收整理内存需要消耗时间，若在栈上分配内存将是个不错的主意。被对象占用的空间就可以随帧栈的就出栈而销毁。大量的对象随方法的结束而自动销毁，GC也减轻压力。</li>\n<li>同步消除　　 若不会线程逃逸，不会有竞争，方法上的同步措施就会消除。</li>\n<li>标量替换　 JAVA的原始类型无法再分就是一个标量，对象就是聚合量。对象若可以被拆分成标量，直接在栈上分配，就是类似栈上分配内存，甚至分配到高速缓存中。</li>\n</ol>\n<p>逃逸分析不成熟的原因：不能保证逃逸分析的性能收益大于它的消耗。</p>\n<h2 id=\"其他优化技术\"><a href=\"#其他优化技术\" class=\"headerlink\" title=\"其他优化技术\"></a>其他优化技术</h2><p>JDK设计团队，几乎把所有的优化措施都集中在即时编译器中。一般认为，编译器的本地会比javac的产生的字节码更优秀。<br>常见的优化技术很多：例如公共表达式的消除，数组边界检查的消除，方法的内联（最重要的优化技术）。</p>\n"},{"title":"LINUX启动过程","comments":1,"date":"2017-09-02T07:34:27.000Z","update":"2017-09-02T07:34:27.000Z","_content":"\n\n> linux开机启动过程,必须经过加载BOIS、读取MBR、Boot Loader、加载内核、启动init进程并确定运行等级、执行初始化脚本、启动内核模块、执行对应运行等级的初始化脚本、个性化设置、进入登录状态的这十个步骤\n\n# 一、 BIOS (Basic Input Output System)基本输入输出系统\n\n1. 按下电源按钮触发CPU的reset引脚。CS寄存器会设值为0xffff;eip = 0x0000\t。此时CPU会从内存的0xffff0处执行代码。此处就是一条跳转到BIOS的指令\n2. BIOS读取CMOS了解硬件情况，开机自检，并对硬件初始化，然后将控制权交给MBR程序。\n\n# 二、MBR（Master Boot Record）主引导记录\n\n0. MBR是在Boot Sector（512字节）里的446字节。那Boot Sector是什么呢，他是引导扇区，在磁盘上占512字节，其中包括MBR（446字节）、DPT（磁盘分区表64子节）、BRID（引导记录表示2字节）。\n1. BIOS会将Boot Sector里的所有内容读到地址是0x7c00的内存位置。（Boot Sector就是BIOS在读取CMOS时被设为启动设备的第一扇区）\n2. BIOS首先会检验BRID是不是0x55AA,是的话才会将控制权交给MBR。\n3. 由于MBR只有446个字节，所以它只是个跳板，然后把控制权交给GRUB\n\n# 三、 GRUB （Grand Unified BootLoader）牛逼的统一引导加载器\n\n1. BootLoader是什么呢？他是在操作系统内核运行前运行的一小段程序，他负责将操作系统的内核加载到内存，然后将电脑的控制权交给操作系统。同时还会搜集电脑的硬件信息、初始化硬件设备、安排内存布局等。\n2. GRUB的特点：\n\t* 动态可配置化的，它在启动时读取配置信息，且允许启动时修改。\n\t* 提供菜单供用户选择要启动的操作系统。\n\t* 支持多种语言、支持链式启动。\n\t* 拥有丰富的控制台命令与用户交互、支持的操作系统非常广泛。\n\t\n3. GRUB2的工作流程\n\n     它比较霸道，必须提供1M的内存空间，来放置他的核心代码，位置无所谓，但必须在2T以内，否则找不到。\n\n\t* 第一阶段：占用MBR的坑（这是对付BISO的唯一方法）。编译好的代码叫boot.img（512字节）；他去那1M的空间找diskboot.img代码。\n\t* 第二阶段：diskboot.img是第二阶段的代码，大小也是512字节。是GRUB核心文件的第一个扇区。这个阶段的代码就是继续将core.img文件余下的部分读到内存，然后继续执行。\n\t* 第三阶段：开始加载GRUB内核模块。这样做的好处是core.img可以做的很小，可配置性和可扩展性非常高。\n\t* 第四阶段：启动操作界面，供用户选择要启动的操作系统。\n\t\n\t（内核启动参数的的传递）\n\n# 四、加载内核\n\n0. Bootloader在保护模式下（32位字长、32位寻址）直接交权给内核。\n1. 内核调用startup\\_32对自己解压缩。\n2. 跳转到startup\\_32这个函数继续执行。（注：这两个函数虽然同名，但是是不一样的）。 \n>  这个startup\\_32函数它代表了Linux的第一个进程process0的开始。这里，他会决定Linux的布局；Linux了解了自己将要与什么样的CPU在一起；会把由BIOS提供和BootLoader们整理的资料放入内存的第一个分页；同时为中断做好准备；如果是64位系统，将把长模式开启，最后会跳到Linux内核的主函数start\\_kernel。开启内核的生命之旅。\n\n3. start\\_kernel函数位于init/mian.c这个文件中。它大部分时间是在为Linux内核准备必要的数据结构。比如：用于内存管理的数据结构，用于任务调度的数据结构，用于处理中断的数据结构，用于处理文件系统的数据结构。经过这些初始化后，Linux此时已经具有了一个操作系统应该具备的功能。\n4. start\\_kernel内核线程会创建一个名为kernel\\_init的内核线程。然后进入自己的归宿cpu\\_idle函数,进入无休止的循环当中。这个cpu\\_idle函数就是我们常见的CPU占用率经常是99%的进程。进程PID为0.它会一直调用CPU的idle指令，让CPU降温且省电，优先级是很低的。\n5. kernel\\_init内核线程是新的Linux这么叫的，老得叫init内核线程。这是Linux的第二个进程，也是init的PID一定是1的由来。（在新的内核代码中，由于必须在创建kernel\\_init之前创建另一个内核线程来做一些更重要的事，所以不得不先创建kernel\\_init，并把它锁起来，然后再创建新的内核线程，然后等他执行完后再解锁。否则init的PID会变为2）。\n6. kernel\\_init内核线程比较重要的工作就是让Linux内核开始与外面进行沟通。比如：给硬件加载驱动程序、初始化网络堆栈、在多CPU系统中让其他CPU开始工作，寻找用户的根文件系统。\n7. kernel\\_init内核线程等一切都稳妥后，会调用用户空间的第一个进程init程序。此时，内核初始化完成。\n\n\n# 五、 启动init进程并确定运行等级\n\n1. 内核通过initramfs启动init进程。\n2. initramfs是一个使用gzip压缩的cpi\\_o打包文件，内核会将它的内容装入一个tmpfs，这就不需要附带任何文件系统驱动就能工作了。\n3. initramfs直接启动init进程，initramfs是由bootloader准备好，告诉内核它在什么位置。内核知道后，直接启动initramfs中的init进程。接下来找根文件系统就交给init进程了。\n4. init进程会根据用户设定的一个运行级别来对Linux系统进行初始化。比如：启动对应运行级别的服务进程，配置网络等。init进程会接受用户的 CTRL + Alt + Del 令Linux系统重新启动；也可以切换运行级别。当用户要关闭Linux系统时，init进程会将未来得及保存的文件保存好。init会收养孤儿进程。还可以保护某些进程不被kill。是Linux的守护神。","source":"_posts/LINUX启动过程.md","raw":"---\n\ntitle: LINUX启动过程\ncomments: true\ntags:\n  - LINUX\n  - 启动过程\ncategories:\n  - LINUX\ndate: 2017-09-02 15:34:27\nupdate: 2017-09-02 15:34:27\n\n---\n\n\n> linux开机启动过程,必须经过加载BOIS、读取MBR、Boot Loader、加载内核、启动init进程并确定运行等级、执行初始化脚本、启动内核模块、执行对应运行等级的初始化脚本、个性化设置、进入登录状态的这十个步骤\n\n# 一、 BIOS (Basic Input Output System)基本输入输出系统\n\n1. 按下电源按钮触发CPU的reset引脚。CS寄存器会设值为0xffff;eip = 0x0000\t。此时CPU会从内存的0xffff0处执行代码。此处就是一条跳转到BIOS的指令\n2. BIOS读取CMOS了解硬件情况，开机自检，并对硬件初始化，然后将控制权交给MBR程序。\n\n# 二、MBR（Master Boot Record）主引导记录\n\n0. MBR是在Boot Sector（512字节）里的446字节。那Boot Sector是什么呢，他是引导扇区，在磁盘上占512字节，其中包括MBR（446字节）、DPT（磁盘分区表64子节）、BRID（引导记录表示2字节）。\n1. BIOS会将Boot Sector里的所有内容读到地址是0x7c00的内存位置。（Boot Sector就是BIOS在读取CMOS时被设为启动设备的第一扇区）\n2. BIOS首先会检验BRID是不是0x55AA,是的话才会将控制权交给MBR。\n3. 由于MBR只有446个字节，所以它只是个跳板，然后把控制权交给GRUB\n\n# 三、 GRUB （Grand Unified BootLoader）牛逼的统一引导加载器\n\n1. BootLoader是什么呢？他是在操作系统内核运行前运行的一小段程序，他负责将操作系统的内核加载到内存，然后将电脑的控制权交给操作系统。同时还会搜集电脑的硬件信息、初始化硬件设备、安排内存布局等。\n2. GRUB的特点：\n\t* 动态可配置化的，它在启动时读取配置信息，且允许启动时修改。\n\t* 提供菜单供用户选择要启动的操作系统。\n\t* 支持多种语言、支持链式启动。\n\t* 拥有丰富的控制台命令与用户交互、支持的操作系统非常广泛。\n\t\n3. GRUB2的工作流程\n\n     它比较霸道，必须提供1M的内存空间，来放置他的核心代码，位置无所谓，但必须在2T以内，否则找不到。\n\n\t* 第一阶段：占用MBR的坑（这是对付BISO的唯一方法）。编译好的代码叫boot.img（512字节）；他去那1M的空间找diskboot.img代码。\n\t* 第二阶段：diskboot.img是第二阶段的代码，大小也是512字节。是GRUB核心文件的第一个扇区。这个阶段的代码就是继续将core.img文件余下的部分读到内存，然后继续执行。\n\t* 第三阶段：开始加载GRUB内核模块。这样做的好处是core.img可以做的很小，可配置性和可扩展性非常高。\n\t* 第四阶段：启动操作界面，供用户选择要启动的操作系统。\n\t\n\t（内核启动参数的的传递）\n\n# 四、加载内核\n\n0. Bootloader在保护模式下（32位字长、32位寻址）直接交权给内核。\n1. 内核调用startup\\_32对自己解压缩。\n2. 跳转到startup\\_32这个函数继续执行。（注：这两个函数虽然同名，但是是不一样的）。 \n>  这个startup\\_32函数它代表了Linux的第一个进程process0的开始。这里，他会决定Linux的布局；Linux了解了自己将要与什么样的CPU在一起；会把由BIOS提供和BootLoader们整理的资料放入内存的第一个分页；同时为中断做好准备；如果是64位系统，将把长模式开启，最后会跳到Linux内核的主函数start\\_kernel。开启内核的生命之旅。\n\n3. start\\_kernel函数位于init/mian.c这个文件中。它大部分时间是在为Linux内核准备必要的数据结构。比如：用于内存管理的数据结构，用于任务调度的数据结构，用于处理中断的数据结构，用于处理文件系统的数据结构。经过这些初始化后，Linux此时已经具有了一个操作系统应该具备的功能。\n4. start\\_kernel内核线程会创建一个名为kernel\\_init的内核线程。然后进入自己的归宿cpu\\_idle函数,进入无休止的循环当中。这个cpu\\_idle函数就是我们常见的CPU占用率经常是99%的进程。进程PID为0.它会一直调用CPU的idle指令，让CPU降温且省电，优先级是很低的。\n5. kernel\\_init内核线程是新的Linux这么叫的，老得叫init内核线程。这是Linux的第二个进程，也是init的PID一定是1的由来。（在新的内核代码中，由于必须在创建kernel\\_init之前创建另一个内核线程来做一些更重要的事，所以不得不先创建kernel\\_init，并把它锁起来，然后再创建新的内核线程，然后等他执行完后再解锁。否则init的PID会变为2）。\n6. kernel\\_init内核线程比较重要的工作就是让Linux内核开始与外面进行沟通。比如：给硬件加载驱动程序、初始化网络堆栈、在多CPU系统中让其他CPU开始工作，寻找用户的根文件系统。\n7. kernel\\_init内核线程等一切都稳妥后，会调用用户空间的第一个进程init程序。此时，内核初始化完成。\n\n\n# 五、 启动init进程并确定运行等级\n\n1. 内核通过initramfs启动init进程。\n2. initramfs是一个使用gzip压缩的cpi\\_o打包文件，内核会将它的内容装入一个tmpfs，这就不需要附带任何文件系统驱动就能工作了。\n3. initramfs直接启动init进程，initramfs是由bootloader准备好，告诉内核它在什么位置。内核知道后，直接启动initramfs中的init进程。接下来找根文件系统就交给init进程了。\n4. init进程会根据用户设定的一个运行级别来对Linux系统进行初始化。比如：启动对应运行级别的服务进程，配置网络等。init进程会接受用户的 CTRL + Alt + Del 令Linux系统重新启动；也可以切换运行级别。当用户要关闭Linux系统时，init进程会将未来得及保存的文件保存好。init会收养孤儿进程。还可以保护某些进程不被kill。是Linux的守护神。","slug":"LINUX启动过程","published":1,"updated":"2017-09-02T10:21:55.000Z","layout":"post","photos":[],"link":"","_id":"cjd4d19zo000aryx4euuudxgh","content":"<blockquote>\n<p>linux开机启动过程,必须经过加载BOIS、读取MBR、Boot Loader、加载内核、启动init进程并确定运行等级、执行初始化脚本、启动内核模块、执行对应运行等级的初始化脚本、个性化设置、进入登录状态的这十个步骤</p>\n</blockquote>\n<h1 id=\"一、-BIOS-Basic-Input-Output-System-基本输入输出系统\"><a href=\"#一、-BIOS-Basic-Input-Output-System-基本输入输出系统\" class=\"headerlink\" title=\"一、 BIOS (Basic Input Output System)基本输入输出系统\"></a>一、 BIOS (Basic Input Output System)基本输入输出系统</h1><ol>\n<li>按下电源按钮触发CPU的reset引脚。CS寄存器会设值为0xffff;eip = 0x0000    。此时CPU会从内存的0xffff0处执行代码。此处就是一条跳转到BIOS的指令</li>\n<li>BIOS读取CMOS了解硬件情况，开机自检，并对硬件初始化，然后将控制权交给MBR程序。</li>\n</ol>\n<h1 id=\"二、MBR（Master-Boot-Record）主引导记录\"><a href=\"#二、MBR（Master-Boot-Record）主引导记录\" class=\"headerlink\" title=\"二、MBR（Master Boot Record）主引导记录\"></a>二、MBR（Master Boot Record）主引导记录</h1><ol>\n<li>MBR是在Boot Sector（512字节）里的446字节。那Boot Sector是什么呢，他是引导扇区，在磁盘上占512字节，其中包括MBR（446字节）、DPT（磁盘分区表64子节）、BRID（引导记录表示2字节）。</li>\n<li>BIOS会将Boot Sector里的所有内容读到地址是0x7c00的内存位置。（Boot Sector就是BIOS在读取CMOS时被设为启动设备的第一扇区）</li>\n<li>BIOS首先会检验BRID是不是0x55AA,是的话才会将控制权交给MBR。</li>\n<li>由于MBR只有446个字节，所以它只是个跳板，然后把控制权交给GRUB</li>\n</ol>\n<h1 id=\"三、-GRUB-（Grand-Unified-BootLoader）牛逼的统一引导加载器\"><a href=\"#三、-GRUB-（Grand-Unified-BootLoader）牛逼的统一引导加载器\" class=\"headerlink\" title=\"三、 GRUB （Grand Unified BootLoader）牛逼的统一引导加载器\"></a>三、 GRUB （Grand Unified BootLoader）牛逼的统一引导加载器</h1><ol>\n<li>BootLoader是什么呢？他是在操作系统内核运行前运行的一小段程序，他负责将操作系统的内核加载到内存，然后将电脑的控制权交给操作系统。同时还会搜集电脑的硬件信息、初始化硬件设备、安排内存布局等。</li>\n<li><p>GRUB的特点：</p>\n<ul>\n<li>动态可配置化的，它在启动时读取配置信息，且允许启动时修改。</li>\n<li>提供菜单供用户选择要启动的操作系统。</li>\n<li>支持多种语言、支持链式启动。</li>\n<li>拥有丰富的控制台命令与用户交互、支持的操作系统非常广泛。</li>\n</ul>\n</li>\n<li><p>GRUB2的工作流程</p>\n<p>  它比较霸道，必须提供1M的内存空间，来放置他的核心代码，位置无所谓，但必须在2T以内，否则找不到。</p>\n<ul>\n<li>第一阶段：占用MBR的坑（这是对付BISO的唯一方法）。编译好的代码叫boot.img（512字节）；他去那1M的空间找diskboot.img代码。</li>\n<li>第二阶段：diskboot.img是第二阶段的代码，大小也是512字节。是GRUB核心文件的第一个扇区。这个阶段的代码就是继续将core.img文件余下的部分读到内存，然后继续执行。</li>\n<li>第三阶段：开始加载GRUB内核模块。这样做的好处是core.img可以做的很小，可配置性和可扩展性非常高。</li>\n<li><p>第四阶段：启动操作界面，供用户选择要启动的操作系统。</p>\n<p>（内核启动参数的的传递）</p>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"四、加载内核\"><a href=\"#四、加载内核\" class=\"headerlink\" title=\"四、加载内核\"></a>四、加载内核</h1><ol>\n<li>Bootloader在保护模式下（32位字长、32位寻址）直接交权给内核。</li>\n<li>内核调用startup_32对自己解压缩。</li>\n<li><p>跳转到startup_32这个函数继续执行。（注：这两个函数虽然同名，但是是不一样的）。 </p>\n<blockquote>\n<p> 这个startup_32函数它代表了Linux的第一个进程process0的开始。这里，他会决定Linux的布局；Linux了解了自己将要与什么样的CPU在一起；会把由BIOS提供和BootLoader们整理的资料放入内存的第一个分页；同时为中断做好准备；如果是64位系统，将把长模式开启，最后会跳到Linux内核的主函数start_kernel。开启内核的生命之旅。</p>\n</blockquote>\n</li>\n<li><p>start_kernel函数位于init/mian.c这个文件中。它大部分时间是在为Linux内核准备必要的数据结构。比如：用于内存管理的数据结构，用于任务调度的数据结构，用于处理中断的数据结构，用于处理文件系统的数据结构。经过这些初始化后，Linux此时已经具有了一个操作系统应该具备的功能。</p>\n</li>\n<li>start_kernel内核线程会创建一个名为kernel_init的内核线程。然后进入自己的归宿cpu_idle函数,进入无休止的循环当中。这个cpu_idle函数就是我们常见的CPU占用率经常是99%的进程。进程PID为0.它会一直调用CPU的idle指令，让CPU降温且省电，优先级是很低的。</li>\n<li>kernel_init内核线程是新的Linux这么叫的，老得叫init内核线程。这是Linux的第二个进程，也是init的PID一定是1的由来。（在新的内核代码中，由于必须在创建kernel_init之前创建另一个内核线程来做一些更重要的事，所以不得不先创建kernel_init，并把它锁起来，然后再创建新的内核线程，然后等他执行完后再解锁。否则init的PID会变为2）。</li>\n<li>kernel_init内核线程比较重要的工作就是让Linux内核开始与外面进行沟通。比如：给硬件加载驱动程序、初始化网络堆栈、在多CPU系统中让其他CPU开始工作，寻找用户的根文件系统。</li>\n<li>kernel_init内核线程等一切都稳妥后，会调用用户空间的第一个进程init程序。此时，内核初始化完成。</li>\n</ol>\n<h1 id=\"五、-启动init进程并确定运行等级\"><a href=\"#五、-启动init进程并确定运行等级\" class=\"headerlink\" title=\"五、 启动init进程并确定运行等级\"></a>五、 启动init进程并确定运行等级</h1><ol>\n<li>内核通过initramfs启动init进程。</li>\n<li>initramfs是一个使用gzip压缩的cpi_o打包文件，内核会将它的内容装入一个tmpfs，这就不需要附带任何文件系统驱动就能工作了。</li>\n<li>initramfs直接启动init进程，initramfs是由bootloader准备好，告诉内核它在什么位置。内核知道后，直接启动initramfs中的init进程。接下来找根文件系统就交给init进程了。</li>\n<li>init进程会根据用户设定的一个运行级别来对Linux系统进行初始化。比如：启动对应运行级别的服务进程，配置网络等。init进程会接受用户的 CTRL + Alt + Del 令Linux系统重新启动；也可以切换运行级别。当用户要关闭Linux系统时，init进程会将未来得及保存的文件保存好。init会收养孤儿进程。还可以保护某些进程不被kill。是Linux的守护神。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>linux开机启动过程,必须经过加载BOIS、读取MBR、Boot Loader、加载内核、启动init进程并确定运行等级、执行初始化脚本、启动内核模块、执行对应运行等级的初始化脚本、个性化设置、进入登录状态的这十个步骤</p>\n</blockquote>\n<h1 id=\"一、-BIOS-Basic-Input-Output-System-基本输入输出系统\"><a href=\"#一、-BIOS-Basic-Input-Output-System-基本输入输出系统\" class=\"headerlink\" title=\"一、 BIOS (Basic Input Output System)基本输入输出系统\"></a>一、 BIOS (Basic Input Output System)基本输入输出系统</h1><ol>\n<li>按下电源按钮触发CPU的reset引脚。CS寄存器会设值为0xffff;eip = 0x0000    。此时CPU会从内存的0xffff0处执行代码。此处就是一条跳转到BIOS的指令</li>\n<li>BIOS读取CMOS了解硬件情况，开机自检，并对硬件初始化，然后将控制权交给MBR程序。</li>\n</ol>\n<h1 id=\"二、MBR（Master-Boot-Record）主引导记录\"><a href=\"#二、MBR（Master-Boot-Record）主引导记录\" class=\"headerlink\" title=\"二、MBR（Master Boot Record）主引导记录\"></a>二、MBR（Master Boot Record）主引导记录</h1><ol>\n<li>MBR是在Boot Sector（512字节）里的446字节。那Boot Sector是什么呢，他是引导扇区，在磁盘上占512字节，其中包括MBR（446字节）、DPT（磁盘分区表64子节）、BRID（引导记录表示2字节）。</li>\n<li>BIOS会将Boot Sector里的所有内容读到地址是0x7c00的内存位置。（Boot Sector就是BIOS在读取CMOS时被设为启动设备的第一扇区）</li>\n<li>BIOS首先会检验BRID是不是0x55AA,是的话才会将控制权交给MBR。</li>\n<li>由于MBR只有446个字节，所以它只是个跳板，然后把控制权交给GRUB</li>\n</ol>\n<h1 id=\"三、-GRUB-（Grand-Unified-BootLoader）牛逼的统一引导加载器\"><a href=\"#三、-GRUB-（Grand-Unified-BootLoader）牛逼的统一引导加载器\" class=\"headerlink\" title=\"三、 GRUB （Grand Unified BootLoader）牛逼的统一引导加载器\"></a>三、 GRUB （Grand Unified BootLoader）牛逼的统一引导加载器</h1><ol>\n<li>BootLoader是什么呢？他是在操作系统内核运行前运行的一小段程序，他负责将操作系统的内核加载到内存，然后将电脑的控制权交给操作系统。同时还会搜集电脑的硬件信息、初始化硬件设备、安排内存布局等。</li>\n<li><p>GRUB的特点：</p>\n<ul>\n<li>动态可配置化的，它在启动时读取配置信息，且允许启动时修改。</li>\n<li>提供菜单供用户选择要启动的操作系统。</li>\n<li>支持多种语言、支持链式启动。</li>\n<li>拥有丰富的控制台命令与用户交互、支持的操作系统非常广泛。</li>\n</ul>\n</li>\n<li><p>GRUB2的工作流程</p>\n<p>  它比较霸道，必须提供1M的内存空间，来放置他的核心代码，位置无所谓，但必须在2T以内，否则找不到。</p>\n<ul>\n<li>第一阶段：占用MBR的坑（这是对付BISO的唯一方法）。编译好的代码叫boot.img（512字节）；他去那1M的空间找diskboot.img代码。</li>\n<li>第二阶段：diskboot.img是第二阶段的代码，大小也是512字节。是GRUB核心文件的第一个扇区。这个阶段的代码就是继续将core.img文件余下的部分读到内存，然后继续执行。</li>\n<li>第三阶段：开始加载GRUB内核模块。这样做的好处是core.img可以做的很小，可配置性和可扩展性非常高。</li>\n<li><p>第四阶段：启动操作界面，供用户选择要启动的操作系统。</p>\n<p>（内核启动参数的的传递）</p>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"四、加载内核\"><a href=\"#四、加载内核\" class=\"headerlink\" title=\"四、加载内核\"></a>四、加载内核</h1><ol>\n<li>Bootloader在保护模式下（32位字长、32位寻址）直接交权给内核。</li>\n<li>内核调用startup_32对自己解压缩。</li>\n<li><p>跳转到startup_32这个函数继续执行。（注：这两个函数虽然同名，但是是不一样的）。 </p>\n<blockquote>\n<p> 这个startup_32函数它代表了Linux的第一个进程process0的开始。这里，他会决定Linux的布局；Linux了解了自己将要与什么样的CPU在一起；会把由BIOS提供和BootLoader们整理的资料放入内存的第一个分页；同时为中断做好准备；如果是64位系统，将把长模式开启，最后会跳到Linux内核的主函数start_kernel。开启内核的生命之旅。</p>\n</blockquote>\n</li>\n<li><p>start_kernel函数位于init/mian.c这个文件中。它大部分时间是在为Linux内核准备必要的数据结构。比如：用于内存管理的数据结构，用于任务调度的数据结构，用于处理中断的数据结构，用于处理文件系统的数据结构。经过这些初始化后，Linux此时已经具有了一个操作系统应该具备的功能。</p>\n</li>\n<li>start_kernel内核线程会创建一个名为kernel_init的内核线程。然后进入自己的归宿cpu_idle函数,进入无休止的循环当中。这个cpu_idle函数就是我们常见的CPU占用率经常是99%的进程。进程PID为0.它会一直调用CPU的idle指令，让CPU降温且省电，优先级是很低的。</li>\n<li>kernel_init内核线程是新的Linux这么叫的，老得叫init内核线程。这是Linux的第二个进程，也是init的PID一定是1的由来。（在新的内核代码中，由于必须在创建kernel_init之前创建另一个内核线程来做一些更重要的事，所以不得不先创建kernel_init，并把它锁起来，然后再创建新的内核线程，然后等他执行完后再解锁。否则init的PID会变为2）。</li>\n<li>kernel_init内核线程比较重要的工作就是让Linux内核开始与外面进行沟通。比如：给硬件加载驱动程序、初始化网络堆栈、在多CPU系统中让其他CPU开始工作，寻找用户的根文件系统。</li>\n<li>kernel_init内核线程等一切都稳妥后，会调用用户空间的第一个进程init程序。此时，内核初始化完成。</li>\n</ol>\n<h1 id=\"五、-启动init进程并确定运行等级\"><a href=\"#五、-启动init进程并确定运行等级\" class=\"headerlink\" title=\"五、 启动init进程并确定运行等级\"></a>五、 启动init进程并确定运行等级</h1><ol>\n<li>内核通过initramfs启动init进程。</li>\n<li>initramfs是一个使用gzip压缩的cpi_o打包文件，内核会将它的内容装入一个tmpfs，这就不需要附带任何文件系统驱动就能工作了。</li>\n<li>initramfs直接启动init进程，initramfs是由bootloader准备好，告诉内核它在什么位置。内核知道后，直接启动initramfs中的init进程。接下来找根文件系统就交给init进程了。</li>\n<li>init进程会根据用户设定的一个运行级别来对Linux系统进行初始化。比如：启动对应运行级别的服务进程，配置网络等。init进程会接受用户的 CTRL + Alt + Del 令Linux系统重新启动；也可以切换运行级别。当用户要关闭Linux系统时，init进程会将未来得及保存的文件保存好。init会收养孤儿进程。还可以保护某些进程不被kill。是Linux的守护神。</li>\n</ol>\n"},{"title":"Spring IOC","comments":1,"date":"2017-09-11T00:39:59.000Z","update":"2017-09-11T00:39:59.000Z","_content":"\n## Spring是什么\n\n* Spring是一个容器，负责对象的创建。\n* Spring的核心是控制反转(IoC)和面向切面(AOP)。\n* 简单来说，Spring 是一个分层的 JavaSE/EEfull-stack(一站式) 轻量级 开源框架。\n\n## Spring的优势\n1. 方便解耦，简化开发：\nSpring就是一个大工厂，可以将所有对象创建和依赖关系维护，交给 Spring 管理。\n2. AOP编程的支持：Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。\n3. 声明式事务的支持：只需要通过配置就可以完成对事务的管理，而无需手动编程。\n4. 方便程序的测试：Spring对Junit4支持，可以通过注解方便的测试Spring程序。\n5. 方便集成各种优秀框架：Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架(如:Struts、Hibernate、MyBatis、Quartz 等)的直接支持 降低 JavaEE API 的使用难度。          \nSpring对JavaEE开发中非常难用的一些API(JDBC、JavaMail、远程调用等)，都提供了封装，使这些 API 应用难度大大降低。\n\n## IOC \n1. IOC控制反转,将对象的创建权交给了Spring。\n2. DI Dependency Injection 依赖注入，需要有 IOC 的环境，Spring创建这个类的过程中,Spring将类的依赖的属性设置进去.\n\n## BeanFactory 和 ApplicationContext 的区别\n1. BeanFactory（已过时）:Spring原始接口。针对原始接口的实现类功能较为单一；BeanFactory接口实现类的容器。特点是每次在获得对象时才会创建对象，适应与手机端这种内存小的环境。\n2. ApplicationContext（继承与BeanFactory）: 在加载applicationContext.xml(容器启动)时候就会创建。适用于web项目。\n3. ApplicatioContext 接口有两个实现类:每次容器启动时就会创建容器中配置的所有对象.并提供更多功能。\n * ClassPathXmlApplicationContext :加载类路径下Spring的配置文件。\n * FileSystemXmlApplicationContext :加载本地磁盘下Spring的配置文件。\n\n \n## bean的配置\n1. id :Bean起个名字；在约束中采用ID的唯一约束。必须以字母开始，可以使用字母、数字、连字符、下划线、句号、冒号。 **id:不能出现特殊字符**。\n2. name:Bean起个名字；没有采用ID的约束。name:出现特殊字符.如果<bean>没有id的话 , name可以当做id使用。推荐使用name。\n\n## scope 属性:Bean 的作用范围\n* singleton:默认值，单例的。\n* prototype:多例的。\n* request:WEB项目中，Spring创建一个Bean的对象,将对象存入到request域中。\n* session :WEB项目中，Spring创建一个Bean的对象，将对象存入到session域中。\n* globalSession :WEB项目中,应用在Porlet环境.如果没有Porlet环境globalSession相当于session.\n\n## Bean 的生命周期的配置\n通过配置<bean>标签上的 init-method 作为 Bean的初始化的时候执行的方法，配置destroy-method作为Bean的销毁的时候执行的方法。销毁方法想要执行，需要是单例创建的 Bean 而且在工厂关闭的时候，Bean 才会被销毁。\n\n##  Spring 生成 Bean 的时候三种方式\n```\n <!-- 方式一:无参数的构造方法的实例化 -->\n <bean id=\"bean1\" class=\"spring.demo3.Bean1\"></bean>\n\n <!-- 方式二:静态工厂实例化 Bean -->\n <bean id=\"bean2\" class=\"spring.demo3.Bean2Factory\" factory-method=\"getBean2\"/>\n\n <!-- 方式三:实例工厂实例化 Bean -->\n <bean id=\"bean3Factory\" class=\"spring.demo3.Bean3Factory\"></bean> \n <bean id=\"bean3\" factory-bean=\"bean3Factory\" factory-method=\"getBean3\"></bean>\n\n```\n\n## Spring 的 Bean 的属性注入:\n\n```\n<!-- 第一种:构造方法的方式 -->\n<bean id=\"car\" class=\"spring.demo4.Car\">\n<constructor-arg name=\"name\" value=\"保时捷\"/>\n<constructor-arg name=\"price\" value=\"1000000\"/> </bean>\n\n<!-- 第二种:set 方法的方式 -->\n<bean id=\"car2\" class=\"spring.demo4.Car2\">\n<property name=\"name\" value=\"奇瑞 QQ\"/>\n<property name=\"price\" value=\"40000\"/> </bean>\n\n<!-- p名称空间的属性注入的方式 -->\n<bean id=\"car2\" class=\"spring.demo4.Car2\" p:name=\"宝马7\" p:price=\"1200000\"/>\n<bean id=\"person\" class=\"spring.demo4.Person\" p:name=\"张三\" p:car2-ref=\"car2\"/>\n\n\nSpEL:Spring Expression Language. 语法:#{ SpEL }\n<!-- SpEL 的注入的方式 -->\n<bean id=\"car2\" class=\"spring.demo4.Car2\">\n<property name=\"name\" value=\"#{'奔驰'}\"/>\n<property name=\"price\" value=\"#{800000}\"/> </bean>\n<bean id=\"person\" class=\"spring.demo4.Person\"> \n<property name=\"name\" value=\"#{'冠希'}\"/>\n<property name=\"car2\" value=\"#{car2}\"/>\n</bean>\n\n<bean id=\"carInfo\" class=\"spring.demo4.CarInfo\"></bean>\n引用了另一个类的属性\n<bean id=\"car2\" class=\" \nspring.demo4.Car2\"> <!-- <property name=\"name\" value=\"#{'奔驰'}\"/> -->\n        <property name=\"name\" value=\"#{carInfo.carName}\"/>\n        <property name=\"price\" value=\"#{carInfo.calculatePrice()}\"/>\n</bean>\n\n\n<!-- Spring 的复杂类型的注入===================== -->\n<bean id=\"collectionBean\" class=\"spring.demo5.CollectionBean\">\n<!-- 数组类型的属性 --> \n<property name=\"arrs\">\n<list>\n <value>会希</value>\n <value>冠希</value>\n <value>天一</value>\n</list>\n</property>\n<!-- 注入 List 集合的数据 --> <property name=\"list\">\n<list>\n <value>芙蓉</value> <value>如花</value> <value>凤姐</value>\n</list>\n</property>\n<!-- 注入 Map 集合 --> <property name=\"map\">\n<map>\n<entry key=\"aaa\" value=\"111\"/> <entry key=\"bbb\" value=\"222\"/> <entry key=\"ccc\" value=\"333\"/>\n</map>\n</property>\n\n<!-- Properties 的注入 --> <property name=\"properties\">\n<props>\n<prop key=\"username\">root</prop>\n <prop key=\"password\">123</prop>\n</props>\n</property>\n</bean>\n\n\n\n<!-- 注入对象类型的属性 -->\n<bean id=\"person\" class=\"spring.demo4.Person\">\n<property name=\"name\" value=\"会希\"/>\n<!-- ref 属性:引用另一个 bean 的 id 或 name --> <property name=\"car2\" ref=\"car2\"/>\n</bean>\n```\n\n\n## Spring 的分配置文件的开发\n一种:创建工厂的时候加载多个配置文件:\n\n```\nApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\",\"applicationContext2.xml\");\n```\n二种:在一个配置文件中包含另一个配置文件:\n\n```\n<import resource=\"applicationContext2.xml\"></import>\n```\n\n\n### Spring要导入的基础包\n1. beans\n2. context\n3. core\n4. expression\n5. commons-logging\n6. log4j\n\n\n\n## 注解\n1. @Component:组件.(作用在类上)\rSpring 中提供@Component 的三个衍生注解:(功能目前来讲是一致的)\n * @Controller\r * @Service\r * @Repository\r这三个注解是为了让标注类本身的用途清晰，Spring在后续版本会对其增强\n\n2. 属性注入的注解:(使用注解注入的方式,可以不用提供 set 方法.)\r * @Value :用于注入普通类型.\r * @Autowired :自动装配: 默认按类型进行装配. \n * 按名称注入:@Qualifier:强制使用名称注入. \n * @Resource 相当于: @Autowired 和@Qualifier 一起使用.","source":"_posts/Spring-IOC.md","raw":"---\ntitle: Spring IOC\ncomments: true\ntags:\n  - Spring\n  - IOC\ncategories:\n  - SPRING\ndate: 2017-09-11 08:39:59\nupdate: 2017-09-11 08:39:59\n\n---\n\n## Spring是什么\n\n* Spring是一个容器，负责对象的创建。\n* Spring的核心是控制反转(IoC)和面向切面(AOP)。\n* 简单来说，Spring 是一个分层的 JavaSE/EEfull-stack(一站式) 轻量级 开源框架。\n\n## Spring的优势\n1. 方便解耦，简化开发：\nSpring就是一个大工厂，可以将所有对象创建和依赖关系维护，交给 Spring 管理。\n2. AOP编程的支持：Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。\n3. 声明式事务的支持：只需要通过配置就可以完成对事务的管理，而无需手动编程。\n4. 方便程序的测试：Spring对Junit4支持，可以通过注解方便的测试Spring程序。\n5. 方便集成各种优秀框架：Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架(如:Struts、Hibernate、MyBatis、Quartz 等)的直接支持 降低 JavaEE API 的使用难度。          \nSpring对JavaEE开发中非常难用的一些API(JDBC、JavaMail、远程调用等)，都提供了封装，使这些 API 应用难度大大降低。\n\n## IOC \n1. IOC控制反转,将对象的创建权交给了Spring。\n2. DI Dependency Injection 依赖注入，需要有 IOC 的环境，Spring创建这个类的过程中,Spring将类的依赖的属性设置进去.\n\n## BeanFactory 和 ApplicationContext 的区别\n1. BeanFactory（已过时）:Spring原始接口。针对原始接口的实现类功能较为单一；BeanFactory接口实现类的容器。特点是每次在获得对象时才会创建对象，适应与手机端这种内存小的环境。\n2. ApplicationContext（继承与BeanFactory）: 在加载applicationContext.xml(容器启动)时候就会创建。适用于web项目。\n3. ApplicatioContext 接口有两个实现类:每次容器启动时就会创建容器中配置的所有对象.并提供更多功能。\n * ClassPathXmlApplicationContext :加载类路径下Spring的配置文件。\n * FileSystemXmlApplicationContext :加载本地磁盘下Spring的配置文件。\n\n \n## bean的配置\n1. id :Bean起个名字；在约束中采用ID的唯一约束。必须以字母开始，可以使用字母、数字、连字符、下划线、句号、冒号。 **id:不能出现特殊字符**。\n2. name:Bean起个名字；没有采用ID的约束。name:出现特殊字符.如果<bean>没有id的话 , name可以当做id使用。推荐使用name。\n\n## scope 属性:Bean 的作用范围\n* singleton:默认值，单例的。\n* prototype:多例的。\n* request:WEB项目中，Spring创建一个Bean的对象,将对象存入到request域中。\n* session :WEB项目中，Spring创建一个Bean的对象，将对象存入到session域中。\n* globalSession :WEB项目中,应用在Porlet环境.如果没有Porlet环境globalSession相当于session.\n\n## Bean 的生命周期的配置\n通过配置<bean>标签上的 init-method 作为 Bean的初始化的时候执行的方法，配置destroy-method作为Bean的销毁的时候执行的方法。销毁方法想要执行，需要是单例创建的 Bean 而且在工厂关闭的时候，Bean 才会被销毁。\n\n##  Spring 生成 Bean 的时候三种方式\n```\n <!-- 方式一:无参数的构造方法的实例化 -->\n <bean id=\"bean1\" class=\"spring.demo3.Bean1\"></bean>\n\n <!-- 方式二:静态工厂实例化 Bean -->\n <bean id=\"bean2\" class=\"spring.demo3.Bean2Factory\" factory-method=\"getBean2\"/>\n\n <!-- 方式三:实例工厂实例化 Bean -->\n <bean id=\"bean3Factory\" class=\"spring.demo3.Bean3Factory\"></bean> \n <bean id=\"bean3\" factory-bean=\"bean3Factory\" factory-method=\"getBean3\"></bean>\n\n```\n\n## Spring 的 Bean 的属性注入:\n\n```\n<!-- 第一种:构造方法的方式 -->\n<bean id=\"car\" class=\"spring.demo4.Car\">\n<constructor-arg name=\"name\" value=\"保时捷\"/>\n<constructor-arg name=\"price\" value=\"1000000\"/> </bean>\n\n<!-- 第二种:set 方法的方式 -->\n<bean id=\"car2\" class=\"spring.demo4.Car2\">\n<property name=\"name\" value=\"奇瑞 QQ\"/>\n<property name=\"price\" value=\"40000\"/> </bean>\n\n<!-- p名称空间的属性注入的方式 -->\n<bean id=\"car2\" class=\"spring.demo4.Car2\" p:name=\"宝马7\" p:price=\"1200000\"/>\n<bean id=\"person\" class=\"spring.demo4.Person\" p:name=\"张三\" p:car2-ref=\"car2\"/>\n\n\nSpEL:Spring Expression Language. 语法:#{ SpEL }\n<!-- SpEL 的注入的方式 -->\n<bean id=\"car2\" class=\"spring.demo4.Car2\">\n<property name=\"name\" value=\"#{'奔驰'}\"/>\n<property name=\"price\" value=\"#{800000}\"/> </bean>\n<bean id=\"person\" class=\"spring.demo4.Person\"> \n<property name=\"name\" value=\"#{'冠希'}\"/>\n<property name=\"car2\" value=\"#{car2}\"/>\n</bean>\n\n<bean id=\"carInfo\" class=\"spring.demo4.CarInfo\"></bean>\n引用了另一个类的属性\n<bean id=\"car2\" class=\" \nspring.demo4.Car2\"> <!-- <property name=\"name\" value=\"#{'奔驰'}\"/> -->\n        <property name=\"name\" value=\"#{carInfo.carName}\"/>\n        <property name=\"price\" value=\"#{carInfo.calculatePrice()}\"/>\n</bean>\n\n\n<!-- Spring 的复杂类型的注入===================== -->\n<bean id=\"collectionBean\" class=\"spring.demo5.CollectionBean\">\n<!-- 数组类型的属性 --> \n<property name=\"arrs\">\n<list>\n <value>会希</value>\n <value>冠希</value>\n <value>天一</value>\n</list>\n</property>\n<!-- 注入 List 集合的数据 --> <property name=\"list\">\n<list>\n <value>芙蓉</value> <value>如花</value> <value>凤姐</value>\n</list>\n</property>\n<!-- 注入 Map 集合 --> <property name=\"map\">\n<map>\n<entry key=\"aaa\" value=\"111\"/> <entry key=\"bbb\" value=\"222\"/> <entry key=\"ccc\" value=\"333\"/>\n</map>\n</property>\n\n<!-- Properties 的注入 --> <property name=\"properties\">\n<props>\n<prop key=\"username\">root</prop>\n <prop key=\"password\">123</prop>\n</props>\n</property>\n</bean>\n\n\n\n<!-- 注入对象类型的属性 -->\n<bean id=\"person\" class=\"spring.demo4.Person\">\n<property name=\"name\" value=\"会希\"/>\n<!-- ref 属性:引用另一个 bean 的 id 或 name --> <property name=\"car2\" ref=\"car2\"/>\n</bean>\n```\n\n\n## Spring 的分配置文件的开发\n一种:创建工厂的时候加载多个配置文件:\n\n```\nApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\",\"applicationContext2.xml\");\n```\n二种:在一个配置文件中包含另一个配置文件:\n\n```\n<import resource=\"applicationContext2.xml\"></import>\n```\n\n\n### Spring要导入的基础包\n1. beans\n2. context\n3. core\n4. expression\n5. commons-logging\n6. log4j\n\n\n\n## 注解\n1. @Component:组件.(作用在类上)\rSpring 中提供@Component 的三个衍生注解:(功能目前来讲是一致的)\n * @Controller\r * @Service\r * @Repository\r这三个注解是为了让标注类本身的用途清晰，Spring在后续版本会对其增强\n\n2. 属性注入的注解:(使用注解注入的方式,可以不用提供 set 方法.)\r * @Value :用于注入普通类型.\r * @Autowired :自动装配: 默认按类型进行装配. \n * 按名称注入:@Qualifier:强制使用名称注入. \n * @Resource 相当于: @Autowired 和@Qualifier 一起使用.","slug":"Spring-IOC","published":1,"updated":"2017-09-11T00:41:39.000Z","layout":"post","photos":[],"link":"","_id":"cjd4d19zq000dryx42ow7qeyf","content":"<h2 id=\"Spring是什么\"><a href=\"#Spring是什么\" class=\"headerlink\" title=\"Spring是什么\"></a>Spring是什么</h2><ul>\n<li>Spring是一个容器，负责对象的创建。</li>\n<li>Spring的核心是控制反转(IoC)和面向切面(AOP)。</li>\n<li>简单来说，Spring 是一个分层的 JavaSE/EEfull-stack(一站式) 轻量级 开源框架。</li>\n</ul>\n<h2 id=\"Spring的优势\"><a href=\"#Spring的优势\" class=\"headerlink\" title=\"Spring的优势\"></a>Spring的优势</h2><ol>\n<li>方便解耦，简化开发：<br>Spring就是一个大工厂，可以将所有对象创建和依赖关系维护，交给 Spring 管理。</li>\n<li>AOP编程的支持：Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。</li>\n<li>声明式事务的支持：只需要通过配置就可以完成对事务的管理，而无需手动编程。</li>\n<li>方便程序的测试：Spring对Junit4支持，可以通过注解方便的测试Spring程序。</li>\n<li>方便集成各种优秀框架：Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架(如:Struts、Hibernate、MyBatis、Quartz 等)的直接支持 降低 JavaEE API 的使用难度。<br>Spring对JavaEE开发中非常难用的一些API(JDBC、JavaMail、远程调用等)，都提供了封装，使这些 API 应用难度大大降低。</li>\n</ol>\n<h2 id=\"IOC\"><a href=\"#IOC\" class=\"headerlink\" title=\"IOC\"></a>IOC</h2><ol>\n<li>IOC控制反转,将对象的创建权交给了Spring。</li>\n<li>DI Dependency Injection 依赖注入，需要有 IOC 的环境，Spring创建这个类的过程中,Spring将类的依赖的属性设置进去.</li>\n</ol>\n<h2 id=\"BeanFactory-和-ApplicationContext-的区别\"><a href=\"#BeanFactory-和-ApplicationContext-的区别\" class=\"headerlink\" title=\"BeanFactory 和 ApplicationContext 的区别\"></a>BeanFactory 和 ApplicationContext 的区别</h2><ol>\n<li>BeanFactory（已过时）:Spring原始接口。针对原始接口的实现类功能较为单一；BeanFactory接口实现类的容器。特点是每次在获得对象时才会创建对象，适应与手机端这种内存小的环境。</li>\n<li>ApplicationContext（继承与BeanFactory）: 在加载applicationContext.xml(容器启动)时候就会创建。适用于web项目。</li>\n<li>ApplicatioContext 接口有两个实现类:每次容器启动时就会创建容器中配置的所有对象.并提供更多功能。<ul>\n<li>ClassPathXmlApplicationContext :加载类路径下Spring的配置文件。</li>\n<li>FileSystemXmlApplicationContext :加载本地磁盘下Spring的配置文件。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"bean的配置\"><a href=\"#bean的配置\" class=\"headerlink\" title=\"bean的配置\"></a>bean的配置</h2><ol>\n<li>id :Bean起个名字；在约束中采用ID的唯一约束。必须以字母开始，可以使用字母、数字、连字符、下划线、句号、冒号。 <strong>id:不能出现特殊字符</strong>。</li>\n<li>name:Bean起个名字；没有采用ID的约束。name:出现特殊字符.如果<bean>没有id的话 , name可以当做id使用。推荐使用name。</bean></li>\n</ol>\n<h2 id=\"scope-属性-Bean-的作用范围\"><a href=\"#scope-属性-Bean-的作用范围\" class=\"headerlink\" title=\"scope 属性:Bean 的作用范围\"></a>scope 属性:Bean 的作用范围</h2><ul>\n<li>singleton:默认值，单例的。</li>\n<li>prototype:多例的。</li>\n<li>request:WEB项目中，Spring创建一个Bean的对象,将对象存入到request域中。</li>\n<li>session :WEB项目中，Spring创建一个Bean的对象，将对象存入到session域中。</li>\n<li>globalSession :WEB项目中,应用在Porlet环境.如果没有Porlet环境globalSession相当于session.</li>\n</ul>\n<h2 id=\"Bean-的生命周期的配置\"><a href=\"#Bean-的生命周期的配置\" class=\"headerlink\" title=\"Bean 的生命周期的配置\"></a>Bean 的生命周期的配置</h2><p>通过配置<bean>标签上的 init-method 作为 Bean的初始化的时候执行的方法，配置destroy-method作为Bean的销毁的时候执行的方法。销毁方法想要执行，需要是单例创建的 Bean 而且在工厂关闭的时候，Bean 才会被销毁。</bean></p>\n<h2 id=\"Spring-生成-Bean-的时候三种方式\"><a href=\"#Spring-生成-Bean-的时候三种方式\" class=\"headerlink\" title=\"Spring 生成 Bean 的时候三种方式\"></a>Spring 生成 Bean 的时候三种方式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- 方式一:无参数的构造方法的实例化 --&gt;</div><div class=\"line\">&lt;bean id=&quot;bean1&quot; class=&quot;spring.demo3.Bean1&quot;&gt;&lt;/bean&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;!-- 方式二:静态工厂实例化 Bean --&gt;</div><div class=\"line\">&lt;bean id=&quot;bean2&quot; class=&quot;spring.demo3.Bean2Factory&quot; factory-method=&quot;getBean2&quot;/&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;!-- 方式三:实例工厂实例化 Bean --&gt;</div><div class=\"line\">&lt;bean id=&quot;bean3Factory&quot; class=&quot;spring.demo3.Bean3Factory&quot;&gt;&lt;/bean&gt; </div><div class=\"line\">&lt;bean id=&quot;bean3&quot; factory-bean=&quot;bean3Factory&quot; factory-method=&quot;getBean3&quot;&gt;&lt;/bean&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"Spring-的-Bean-的属性注入\"><a href=\"#Spring-的-Bean-的属性注入\" class=\"headerlink\" title=\"Spring 的 Bean 的属性注入:\"></a>Spring 的 Bean 的属性注入:</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- 第一种:构造方法的方式 --&gt;</div><div class=\"line\">&lt;bean id=&quot;car&quot; class=&quot;spring.demo4.Car&quot;&gt;</div><div class=\"line\">&lt;constructor-arg name=&quot;name&quot; value=&quot;保时捷&quot;/&gt;</div><div class=\"line\">&lt;constructor-arg name=&quot;price&quot; value=&quot;1000000&quot;/&gt; &lt;/bean&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;!-- 第二种:set 方法的方式 --&gt;</div><div class=\"line\">&lt;bean id=&quot;car2&quot; class=&quot;spring.demo4.Car2&quot;&gt;</div><div class=\"line\">&lt;property name=&quot;name&quot; value=&quot;奇瑞 QQ&quot;/&gt;</div><div class=\"line\">&lt;property name=&quot;price&quot; value=&quot;40000&quot;/&gt; &lt;/bean&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;!-- p名称空间的属性注入的方式 --&gt;</div><div class=\"line\">&lt;bean id=&quot;car2&quot; class=&quot;spring.demo4.Car2&quot; p:name=&quot;宝马7&quot; p:price=&quot;1200000&quot;/&gt;</div><div class=\"line\">&lt;bean id=&quot;person&quot; class=&quot;spring.demo4.Person&quot; p:name=&quot;张三&quot; p:car2-ref=&quot;car2&quot;/&gt;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">SpEL:Spring Expression Language. 语法:#&#123; SpEL &#125;</div><div class=\"line\">&lt;!-- SpEL 的注入的方式 --&gt;</div><div class=\"line\">&lt;bean id=&quot;car2&quot; class=&quot;spring.demo4.Car2&quot;&gt;</div><div class=\"line\">&lt;property name=&quot;name&quot; value=&quot;#&#123;&apos;奔驰&apos;&#125;&quot;/&gt;</div><div class=\"line\">&lt;property name=&quot;price&quot; value=&quot;#&#123;800000&#125;&quot;/&gt; &lt;/bean&gt;</div><div class=\"line\">&lt;bean id=&quot;person&quot; class=&quot;spring.demo4.Person&quot;&gt; </div><div class=\"line\">&lt;property name=&quot;name&quot; value=&quot;#&#123;&apos;冠希&apos;&#125;&quot;/&gt;</div><div class=\"line\">&lt;property name=&quot;car2&quot; value=&quot;#&#123;car2&#125;&quot;/&gt;</div><div class=\"line\">&lt;/bean&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;bean id=&quot;carInfo&quot; class=&quot;spring.demo4.CarInfo&quot;&gt;&lt;/bean&gt;</div><div class=\"line\">引用了另一个类的属性</div><div class=\"line\">&lt;bean id=&quot;car2&quot; class=&quot; </div><div class=\"line\">spring.demo4.Car2&quot;&gt; &lt;!-- &lt;property name=&quot;name&quot; value=&quot;#&#123;&apos;奔驰&apos;&#125;&quot;/&gt; --&gt;</div><div class=\"line\">        &lt;property name=&quot;name&quot; value=&quot;#&#123;carInfo.carName&#125;&quot;/&gt;</div><div class=\"line\">        &lt;property name=&quot;price&quot; value=&quot;#&#123;carInfo.calculatePrice()&#125;&quot;/&gt;</div><div class=\"line\">&lt;/bean&gt;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&lt;!-- Spring 的复杂类型的注入===================== --&gt;</div><div class=\"line\">&lt;bean id=&quot;collectionBean&quot; class=&quot;spring.demo5.CollectionBean&quot;&gt;</div><div class=\"line\">&lt;!-- 数组类型的属性 --&gt; </div><div class=\"line\">&lt;property name=&quot;arrs&quot;&gt;</div><div class=\"line\">&lt;list&gt;</div><div class=\"line\"> &lt;value&gt;会希&lt;/value&gt;</div><div class=\"line\"> &lt;value&gt;冠希&lt;/value&gt;</div><div class=\"line\"> &lt;value&gt;天一&lt;/value&gt;</div><div class=\"line\">&lt;/list&gt;</div><div class=\"line\">&lt;/property&gt;</div><div class=\"line\">&lt;!-- 注入 List 集合的数据 --&gt; &lt;property name=&quot;list&quot;&gt;</div><div class=\"line\">&lt;list&gt;</div><div class=\"line\"> &lt;value&gt;芙蓉&lt;/value&gt; &lt;value&gt;如花&lt;/value&gt; &lt;value&gt;凤姐&lt;/value&gt;</div><div class=\"line\">&lt;/list&gt;</div><div class=\"line\">&lt;/property&gt;</div><div class=\"line\">&lt;!-- 注入 Map 集合 --&gt; &lt;property name=&quot;map&quot;&gt;</div><div class=\"line\">&lt;map&gt;</div><div class=\"line\">&lt;entry key=&quot;aaa&quot; value=&quot;111&quot;/&gt; &lt;entry key=&quot;bbb&quot; value=&quot;222&quot;/&gt; &lt;entry key=&quot;ccc&quot; value=&quot;333&quot;/&gt;</div><div class=\"line\">&lt;/map&gt;</div><div class=\"line\">&lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;!-- Properties 的注入 --&gt; &lt;property name=&quot;properties&quot;&gt;</div><div class=\"line\">&lt;props&gt;</div><div class=\"line\">&lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt;</div><div class=\"line\"> &lt;prop key=&quot;password&quot;&gt;123&lt;/prop&gt;</div><div class=\"line\">&lt;/props&gt;</div><div class=\"line\">&lt;/property&gt;</div><div class=\"line\">&lt;/bean&gt;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&lt;!-- 注入对象类型的属性 --&gt;</div><div class=\"line\">&lt;bean id=&quot;person&quot; class=&quot;spring.demo4.Person&quot;&gt;</div><div class=\"line\">&lt;property name=&quot;name&quot; value=&quot;会希&quot;/&gt;</div><div class=\"line\">&lt;!-- ref 属性:引用另一个 bean 的 id 或 name --&gt; &lt;property name=&quot;car2&quot; ref=&quot;car2&quot;/&gt;</div><div class=\"line\">&lt;/bean&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"Spring-的分配置文件的开发\"><a href=\"#Spring-的分配置文件的开发\" class=\"headerlink\" title=\"Spring 的分配置文件的开发\"></a>Spring 的分配置文件的开发</h2><p>一种:创建工厂的时候加载多个配置文件:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;,&quot;applicationContext2.xml&quot;);</div></pre></td></tr></table></figure>\n<p>二种:在一个配置文件中包含另一个配置文件:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;import resource=&quot;applicationContext2.xml&quot;&gt;&lt;/import&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"Spring要导入的基础包\"><a href=\"#Spring要导入的基础包\" class=\"headerlink\" title=\"Spring要导入的基础包\"></a>Spring要导入的基础包</h3><ol>\n<li>beans</li>\n<li>context</li>\n<li>core</li>\n<li>expression</li>\n<li>commons-logging</li>\n<li>log4j</li>\n</ol>\n<h2 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h2><ol>\n<li><p>@Component:组件.(作用在类上)<br>Spring 中提供@Component 的三个衍生注解:(功能目前来讲是一致的)</p>\n<ul>\n<li>@Controller</li>\n<li>@Service</li>\n<li>@Repository<br>这三个注解是为了让标注类本身的用途清晰，Spring在后续版本会对其增强</li>\n</ul>\n</li>\n<li><p>属性注入的注解:(使用注解注入的方式,可以不用提供 set 方法.)</p>\n<ul>\n<li>@Value :用于注入普通类型.</li>\n<li>@Autowired :自动装配: 默认按类型进行装配. </li>\n<li>按名称注入:@Qualifier:强制使用名称注入. </li>\n<li>@Resource 相当于: @Autowired 和@Qualifier 一起使用.</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Spring是什么\"><a href=\"#Spring是什么\" class=\"headerlink\" title=\"Spring是什么\"></a>Spring是什么</h2><ul>\n<li>Spring是一个容器，负责对象的创建。</li>\n<li>Spring的核心是控制反转(IoC)和面向切面(AOP)。</li>\n<li>简单来说，Spring 是一个分层的 JavaSE/EEfull-stack(一站式) 轻量级 开源框架。</li>\n</ul>\n<h2 id=\"Spring的优势\"><a href=\"#Spring的优势\" class=\"headerlink\" title=\"Spring的优势\"></a>Spring的优势</h2><ol>\n<li>方便解耦，简化开发：<br>Spring就是一个大工厂，可以将所有对象创建和依赖关系维护，交给 Spring 管理。</li>\n<li>AOP编程的支持：Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。</li>\n<li>声明式事务的支持：只需要通过配置就可以完成对事务的管理，而无需手动编程。</li>\n<li>方便程序的测试：Spring对Junit4支持，可以通过注解方便的测试Spring程序。</li>\n<li>方便集成各种优秀框架：Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架(如:Struts、Hibernate、MyBatis、Quartz 等)的直接支持 降低 JavaEE API 的使用难度。<br>Spring对JavaEE开发中非常难用的一些API(JDBC、JavaMail、远程调用等)，都提供了封装，使这些 API 应用难度大大降低。</li>\n</ol>\n<h2 id=\"IOC\"><a href=\"#IOC\" class=\"headerlink\" title=\"IOC\"></a>IOC</h2><ol>\n<li>IOC控制反转,将对象的创建权交给了Spring。</li>\n<li>DI Dependency Injection 依赖注入，需要有 IOC 的环境，Spring创建这个类的过程中,Spring将类的依赖的属性设置进去.</li>\n</ol>\n<h2 id=\"BeanFactory-和-ApplicationContext-的区别\"><a href=\"#BeanFactory-和-ApplicationContext-的区别\" class=\"headerlink\" title=\"BeanFactory 和 ApplicationContext 的区别\"></a>BeanFactory 和 ApplicationContext 的区别</h2><ol>\n<li>BeanFactory（已过时）:Spring原始接口。针对原始接口的实现类功能较为单一；BeanFactory接口实现类的容器。特点是每次在获得对象时才会创建对象，适应与手机端这种内存小的环境。</li>\n<li>ApplicationContext（继承与BeanFactory）: 在加载applicationContext.xml(容器启动)时候就会创建。适用于web项目。</li>\n<li>ApplicatioContext 接口有两个实现类:每次容器启动时就会创建容器中配置的所有对象.并提供更多功能。<ul>\n<li>ClassPathXmlApplicationContext :加载类路径下Spring的配置文件。</li>\n<li>FileSystemXmlApplicationContext :加载本地磁盘下Spring的配置文件。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"bean的配置\"><a href=\"#bean的配置\" class=\"headerlink\" title=\"bean的配置\"></a>bean的配置</h2><ol>\n<li>id :Bean起个名字；在约束中采用ID的唯一约束。必须以字母开始，可以使用字母、数字、连字符、下划线、句号、冒号。 <strong>id:不能出现特殊字符</strong>。</li>\n<li>name:Bean起个名字；没有采用ID的约束。name:出现特殊字符.如果<bean>没有id的话 , name可以当做id使用。推荐使用name。</bean></li>\n</ol>\n<h2 id=\"scope-属性-Bean-的作用范围\"><a href=\"#scope-属性-Bean-的作用范围\" class=\"headerlink\" title=\"scope 属性:Bean 的作用范围\"></a>scope 属性:Bean 的作用范围</h2><ul>\n<li>singleton:默认值，单例的。</li>\n<li>prototype:多例的。</li>\n<li>request:WEB项目中，Spring创建一个Bean的对象,将对象存入到request域中。</li>\n<li>session :WEB项目中，Spring创建一个Bean的对象，将对象存入到session域中。</li>\n<li>globalSession :WEB项目中,应用在Porlet环境.如果没有Porlet环境globalSession相当于session.</li>\n</ul>\n<h2 id=\"Bean-的生命周期的配置\"><a href=\"#Bean-的生命周期的配置\" class=\"headerlink\" title=\"Bean 的生命周期的配置\"></a>Bean 的生命周期的配置</h2><p>通过配置<bean>标签上的 init-method 作为 Bean的初始化的时候执行的方法，配置destroy-method作为Bean的销毁的时候执行的方法。销毁方法想要执行，需要是单例创建的 Bean 而且在工厂关闭的时候，Bean 才会被销毁。</bean></p>\n<h2 id=\"Spring-生成-Bean-的时候三种方式\"><a href=\"#Spring-生成-Bean-的时候三种方式\" class=\"headerlink\" title=\"Spring 生成 Bean 的时候三种方式\"></a>Spring 生成 Bean 的时候三种方式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- 方式一:无参数的构造方法的实例化 --&gt;</div><div class=\"line\">&lt;bean id=&quot;bean1&quot; class=&quot;spring.demo3.Bean1&quot;&gt;&lt;/bean&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;!-- 方式二:静态工厂实例化 Bean --&gt;</div><div class=\"line\">&lt;bean id=&quot;bean2&quot; class=&quot;spring.demo3.Bean2Factory&quot; factory-method=&quot;getBean2&quot;/&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;!-- 方式三:实例工厂实例化 Bean --&gt;</div><div class=\"line\">&lt;bean id=&quot;bean3Factory&quot; class=&quot;spring.demo3.Bean3Factory&quot;&gt;&lt;/bean&gt; </div><div class=\"line\">&lt;bean id=&quot;bean3&quot; factory-bean=&quot;bean3Factory&quot; factory-method=&quot;getBean3&quot;&gt;&lt;/bean&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"Spring-的-Bean-的属性注入\"><a href=\"#Spring-的-Bean-的属性注入\" class=\"headerlink\" title=\"Spring 的 Bean 的属性注入:\"></a>Spring 的 Bean 的属性注入:</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- 第一种:构造方法的方式 --&gt;</div><div class=\"line\">&lt;bean id=&quot;car&quot; class=&quot;spring.demo4.Car&quot;&gt;</div><div class=\"line\">&lt;constructor-arg name=&quot;name&quot; value=&quot;保时捷&quot;/&gt;</div><div class=\"line\">&lt;constructor-arg name=&quot;price&quot; value=&quot;1000000&quot;/&gt; &lt;/bean&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;!-- 第二种:set 方法的方式 --&gt;</div><div class=\"line\">&lt;bean id=&quot;car2&quot; class=&quot;spring.demo4.Car2&quot;&gt;</div><div class=\"line\">&lt;property name=&quot;name&quot; value=&quot;奇瑞 QQ&quot;/&gt;</div><div class=\"line\">&lt;property name=&quot;price&quot; value=&quot;40000&quot;/&gt; &lt;/bean&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;!-- p名称空间的属性注入的方式 --&gt;</div><div class=\"line\">&lt;bean id=&quot;car2&quot; class=&quot;spring.demo4.Car2&quot; p:name=&quot;宝马7&quot; p:price=&quot;1200000&quot;/&gt;</div><div class=\"line\">&lt;bean id=&quot;person&quot; class=&quot;spring.demo4.Person&quot; p:name=&quot;张三&quot; p:car2-ref=&quot;car2&quot;/&gt;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">SpEL:Spring Expression Language. 语法:#&#123; SpEL &#125;</div><div class=\"line\">&lt;!-- SpEL 的注入的方式 --&gt;</div><div class=\"line\">&lt;bean id=&quot;car2&quot; class=&quot;spring.demo4.Car2&quot;&gt;</div><div class=\"line\">&lt;property name=&quot;name&quot; value=&quot;#&#123;&apos;奔驰&apos;&#125;&quot;/&gt;</div><div class=\"line\">&lt;property name=&quot;price&quot; value=&quot;#&#123;800000&#125;&quot;/&gt; &lt;/bean&gt;</div><div class=\"line\">&lt;bean id=&quot;person&quot; class=&quot;spring.demo4.Person&quot;&gt; </div><div class=\"line\">&lt;property name=&quot;name&quot; value=&quot;#&#123;&apos;冠希&apos;&#125;&quot;/&gt;</div><div class=\"line\">&lt;property name=&quot;car2&quot; value=&quot;#&#123;car2&#125;&quot;/&gt;</div><div class=\"line\">&lt;/bean&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;bean id=&quot;carInfo&quot; class=&quot;spring.demo4.CarInfo&quot;&gt;&lt;/bean&gt;</div><div class=\"line\">引用了另一个类的属性</div><div class=\"line\">&lt;bean id=&quot;car2&quot; class=&quot; </div><div class=\"line\">spring.demo4.Car2&quot;&gt; &lt;!-- &lt;property name=&quot;name&quot; value=&quot;#&#123;&apos;奔驰&apos;&#125;&quot;/&gt; --&gt;</div><div class=\"line\">        &lt;property name=&quot;name&quot; value=&quot;#&#123;carInfo.carName&#125;&quot;/&gt;</div><div class=\"line\">        &lt;property name=&quot;price&quot; value=&quot;#&#123;carInfo.calculatePrice()&#125;&quot;/&gt;</div><div class=\"line\">&lt;/bean&gt;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&lt;!-- Spring 的复杂类型的注入===================== --&gt;</div><div class=\"line\">&lt;bean id=&quot;collectionBean&quot; class=&quot;spring.demo5.CollectionBean&quot;&gt;</div><div class=\"line\">&lt;!-- 数组类型的属性 --&gt; </div><div class=\"line\">&lt;property name=&quot;arrs&quot;&gt;</div><div class=\"line\">&lt;list&gt;</div><div class=\"line\"> &lt;value&gt;会希&lt;/value&gt;</div><div class=\"line\"> &lt;value&gt;冠希&lt;/value&gt;</div><div class=\"line\"> &lt;value&gt;天一&lt;/value&gt;</div><div class=\"line\">&lt;/list&gt;</div><div class=\"line\">&lt;/property&gt;</div><div class=\"line\">&lt;!-- 注入 List 集合的数据 --&gt; &lt;property name=&quot;list&quot;&gt;</div><div class=\"line\">&lt;list&gt;</div><div class=\"line\"> &lt;value&gt;芙蓉&lt;/value&gt; &lt;value&gt;如花&lt;/value&gt; &lt;value&gt;凤姐&lt;/value&gt;</div><div class=\"line\">&lt;/list&gt;</div><div class=\"line\">&lt;/property&gt;</div><div class=\"line\">&lt;!-- 注入 Map 集合 --&gt; &lt;property name=&quot;map&quot;&gt;</div><div class=\"line\">&lt;map&gt;</div><div class=\"line\">&lt;entry key=&quot;aaa&quot; value=&quot;111&quot;/&gt; &lt;entry key=&quot;bbb&quot; value=&quot;222&quot;/&gt; &lt;entry key=&quot;ccc&quot; value=&quot;333&quot;/&gt;</div><div class=\"line\">&lt;/map&gt;</div><div class=\"line\">&lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;!-- Properties 的注入 --&gt; &lt;property name=&quot;properties&quot;&gt;</div><div class=\"line\">&lt;props&gt;</div><div class=\"line\">&lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt;</div><div class=\"line\"> &lt;prop key=&quot;password&quot;&gt;123&lt;/prop&gt;</div><div class=\"line\">&lt;/props&gt;</div><div class=\"line\">&lt;/property&gt;</div><div class=\"line\">&lt;/bean&gt;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&lt;!-- 注入对象类型的属性 --&gt;</div><div class=\"line\">&lt;bean id=&quot;person&quot; class=&quot;spring.demo4.Person&quot;&gt;</div><div class=\"line\">&lt;property name=&quot;name&quot; value=&quot;会希&quot;/&gt;</div><div class=\"line\">&lt;!-- ref 属性:引用另一个 bean 的 id 或 name --&gt; &lt;property name=&quot;car2&quot; ref=&quot;car2&quot;/&gt;</div><div class=\"line\">&lt;/bean&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"Spring-的分配置文件的开发\"><a href=\"#Spring-的分配置文件的开发\" class=\"headerlink\" title=\"Spring 的分配置文件的开发\"></a>Spring 的分配置文件的开发</h2><p>一种:创建工厂的时候加载多个配置文件:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;,&quot;applicationContext2.xml&quot;);</div></pre></td></tr></table></figure>\n<p>二种:在一个配置文件中包含另一个配置文件:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;import resource=&quot;applicationContext2.xml&quot;&gt;&lt;/import&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"Spring要导入的基础包\"><a href=\"#Spring要导入的基础包\" class=\"headerlink\" title=\"Spring要导入的基础包\"></a>Spring要导入的基础包</h3><ol>\n<li>beans</li>\n<li>context</li>\n<li>core</li>\n<li>expression</li>\n<li>commons-logging</li>\n<li>log4j</li>\n</ol>\n<h2 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h2><ol>\n<li><p>@Component:组件.(作用在类上)<br>Spring 中提供@Component 的三个衍生注解:(功能目前来讲是一致的)</p>\n<ul>\n<li>@Controller</li>\n<li>@Service</li>\n<li>@Repository<br>这三个注解是为了让标注类本身的用途清晰，Spring在后续版本会对其增强</li>\n</ul>\n</li>\n<li><p>属性注入的注解:(使用注解注入的方式,可以不用提供 set 方法.)</p>\n<ul>\n<li>@Value :用于注入普通类型.</li>\n<li>@Autowired :自动装配: 默认按类型进行装配. </li>\n<li>按名称注入:@Qualifier:强制使用名称注入. </li>\n<li>@Resource 相当于: @Autowired 和@Qualifier 一起使用.</li>\n</ul>\n</li>\n</ol>\n"},{"title":"Spring MVC","comments":1,"date":"2017-09-17T10:13:48.000Z","update":"2017-09-17T10:13:48.000Z","_content":"\n# Spring mvc请求流程\n\n1. 发送请求到前端控制器DispatcherServlet；\n2. DispatcherServlet调用HandleMapping处理器映射器；\n3. 处理器映射器根据请求的URL找到具体的处理器，生成处理器对象以及处理器拦截器一并返回给DispatcherServlet；\n4. DispatcherServlet通过HandlerAdapter处理器适配器调用处理器；\n5. 执行处理器（自己编写的controller，也叫后端处理器）；\n6. controller执行完后，返回ModelAndView；\n7. HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet；\n8. DispatcherServlet将ModelAndView传给ViewReslover视图解析器；\n9. ViewReslover解析后返回具体View；\n10. DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中；\n11. DispatcherServlet响应用户；\n\n# 组件\n\n1. DispatcherServlet(前端控制器)\n\n\tdispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。\n\n2. HandlerMapping（处理器映射器）\n\n\tHandlerMapping负责根据用户请求url找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。\n\n3. HandlAdapter（处理器适配器）\n\n\t通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。\n\n4. Handler（处理器）\n\n\tHandler是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。\n由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。\n\n5. ViewResolver（视图解析器）\n\n\tView Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 \n\n6. View （视图）\n\n\tspringmvc框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。\n一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。\n\n\t> 在springmvc的各个组件中，处理器映射器、处理器适配器、视图解析器称为springmvc的三大组件。\n需要用户开发的组件有handler、view\n\n# Spring mvc 默认加载的组件\nproperties的位置：org.springframework.web.servlet下的DispatcherServlet.properties\n\n```\n# Default implementation classes for DispatcherServlet's strategy interfaces.\n# Used as fallback when no matching beans are found in the DispatcherServlet context.\n# Not meant to be customized by application developers.\n\norg.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver\n\norg.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver\n\norg.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\\\n\torg.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping\n\norg.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\\\n\torg.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\\\n\torg.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\n\norg.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\\\n\torg.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\\\n\torg.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver\n\norg.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator\n\norg.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver\n\norg.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager\n```\n\n# spring.xml文件的一些配置\n\n\n1. 配置扫描包\n\n\t```\n\t<!-- 配置controller扫描包，多个包之间用,分隔 -->\n\t<context:component-scan base-package=\"springmvc.controller\" />\n\t```\n2. 配置处理器映射器\n\n\t```\n\t<!-- 配置处理器映射器 -->\n<bean\n\tclass=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\" />\n```\n\n3. 配置处理器适配器\n\t```\n\t<!-- 配置处理器适配器 -->\n<bean\n\tclass=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\" />\n\t```\n\t\n4. 注解驱动(可替代注解处理器和适配器的配置)\n\n\t```\n\t<!-- 注解驱动 -->\n<mvc:annotation-driven />\n```\n\n5. 视图解析器\n\n\t```\n\t\t<!-- Example: prefix=\"/WEB-INF/jsp/\", suffix=\".jsp\", viewname=\"test\" -> \n\t\t\"/WEB-INF/jsp/test.jsp\" -->\n\t<!-- 配置视图解析器 -->\n\t<bean\n\t\tclass=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n\t\t<!-- 配置逻辑视图的前缀 -->\n\t\t<property name=\"prefix\" value=\"/WEB-INF/jsp/\" />\n\t\t<!-- 配置逻辑视图的后缀 -->\n\t\t<property name=\"suffix\" value=\".jsp\" />\n\t</bean>\n\t```\n\t\n6. 配置拦截器\n\n\t```\n<mvc:interceptor>\n\t<!-- 配置商品被拦截器拦截 -->\n\t<mvc:mapping path=\"/item/**\" />\n\t<!-- 配置具体的拦截器 -->\n\t<bean class=\"interceptor.LoginHandlerInterceptor\" />\n</mvc:interceptor>\n```\n\t\n\t拦截器的调用顺序：\npreHandle按拦截器定义顺序调用\npostHandler按拦截器定义逆序调用\nafterCompletion按拦截器定义逆序调用\npostHandler在拦截器链内所有拦截器返成功调用\nafterCompletion只有preHandle返回true才调用\n\n\n7. 配置上传解析器\n\n\t``` <!-- 文件上传,id必须设置为multipartResolver -->\n<bean id=\"multipartResolver\"\n\tclass=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">\n\t<!-- 设置文件上传大小 -->\n\t<property name=\"maxUploadSize\" value=\"5000000\" />\n</bean>\n```\n\n8. 异常处理器配置\n\n\t```\n<!-- 配置全局异常处理器 -->\n<bean \nid=\"customHandleException\" \tclass=\"exception.CustomHandleException\"/>\n```\n\n# 小问题\n注意两个区别\n@PathVariable是获取url上数据的。@RequestParam获取请求参数的（包括post表单提交）\n\n\n@RequestBody注解用于读取http请求的内容(字符串)，通过springmvc提供的HttpMessageConverter接口将读到的内容（json数据）转换为java对象并绑定到Controller方法的参数上。\n\n\n@ResponseBody\n作用：\n@ResponseBody注解用于将Controller的方法返回的对象，通过springmvc提供的HttpMessageConverter接口转换为指定格式的数据如：json,xml等，通过Response响应给客户端\n\n如果加上@ResponseBody注解，就不会走视图解析器，不会返回页面，目前返回的json数据。如果不加，就走视图解析器，返回页面。\n\n\t\n# web.xml\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txmlns=\"http://java.sun.com/xml/ns/javaee\"\n\txsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\n\tid=\"WebApp_ID\" version=\"2.5\">\n\t<display-name>springmvc-web</display-name>\n\t<welcome-file-list>\n\t\t<welcome-file>index.html</welcome-file>\n\t\t<welcome-file>index.htm</welcome-file>\n\t\t<welcome-file>index.jsp</welcome-file>\n\t\t<welcome-file>default.html</welcome-file>\n\t\t<welcome-file>default.htm</welcome-file>\n\t\t<welcome-file>default.jsp</welcome-file>\n\t</welcome-file-list>\n\n\t<!-- 配置spring -->\n\t<context-param>\n\t\t<param-name>contextConfigLocation</param-name>\n\t\t<param-value>classpath:spring/applicationContext*.xml</param-value>\n\t</context-param>\n\n\t<!-- 使用监听器加载Spring配置文件 -->\n\t<listener>\n\t\t<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n\t</listener>\n\n\t<!-- 配置SrpingMVC的前端控制器 -->\n\t<servlet>\n\t\t<servlet-name>springmvc-web</servlet-name>\n\t\t<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n\t\t<init-param>\n\t\t\t<param-name>contextConfigLocation</param-name>\n\t\t\t<param-value>classpath:spring/springmvc.xml</param-value>\n\t\t</init-param>\n\t</servlet>\n\n\t<servlet-mapping>\n\t\t<servlet-name>springmvc-web</servlet-name>\n\t\t<!-- 配置所有以action结尾的请求进入SpringMVC -->\n\t\t<url-pattern>*.action</url-pattern>\n\t</servlet-mapping>\n\t\t<!-- 解决post乱码问题 -->\n\t<filter>\n\t\t<filter-name>encoding</filter-name>\n\t\t<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n\t\t<!-- 设置编码参是UTF8 -->\n\t\t<init-param>\n\t\t\t<param-name>encoding</param-name>\n\t\t\t<param-value>UTF-8</param-value>\n\t\t</init-param>\n\t</filter>\n\t<filter-mapping>\n\t\t<filter-name>encoding</filter-name>\n\t\t<url-pattern>/*</url-pattern>\n\t</filter-mapping>\n</web-app>\n```\t\n\t\n# Spring MVC 与Struts2不同\n1. springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过滤器。\n2. springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。\n3. Struts采用值栈存储请求和响应的数据，通过OGNL存取数据， springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过request域传输到页面。Jsp视图解析器默认使用jstl。\n\n","source":"_posts/Spring-MVC.md","raw":"---\ntitle: Spring MVC\ncomments: true\ntags:\n  - spring\n  - mvc\ncategories:\n  - SPRING\ndate: 2017-09-17 18:13:48\nupdate: 2017-09-17 18:13:48\n\n---\n\n# Spring mvc请求流程\n\n1. 发送请求到前端控制器DispatcherServlet；\n2. DispatcherServlet调用HandleMapping处理器映射器；\n3. 处理器映射器根据请求的URL找到具体的处理器，生成处理器对象以及处理器拦截器一并返回给DispatcherServlet；\n4. DispatcherServlet通过HandlerAdapter处理器适配器调用处理器；\n5. 执行处理器（自己编写的controller，也叫后端处理器）；\n6. controller执行完后，返回ModelAndView；\n7. HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet；\n8. DispatcherServlet将ModelAndView传给ViewReslover视图解析器；\n9. ViewReslover解析后返回具体View；\n10. DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中；\n11. DispatcherServlet响应用户；\n\n# 组件\n\n1. DispatcherServlet(前端控制器)\n\n\tdispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。\n\n2. HandlerMapping（处理器映射器）\n\n\tHandlerMapping负责根据用户请求url找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。\n\n3. HandlAdapter（处理器适配器）\n\n\t通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。\n\n4. Handler（处理器）\n\n\tHandler是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。\n由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。\n\n5. ViewResolver（视图解析器）\n\n\tView Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 \n\n6. View （视图）\n\n\tspringmvc框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。\n一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。\n\n\t> 在springmvc的各个组件中，处理器映射器、处理器适配器、视图解析器称为springmvc的三大组件。\n需要用户开发的组件有handler、view\n\n# Spring mvc 默认加载的组件\nproperties的位置：org.springframework.web.servlet下的DispatcherServlet.properties\n\n```\n# Default implementation classes for DispatcherServlet's strategy interfaces.\n# Used as fallback when no matching beans are found in the DispatcherServlet context.\n# Not meant to be customized by application developers.\n\norg.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver\n\norg.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver\n\norg.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\\\n\torg.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping\n\norg.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\\\n\torg.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\\\n\torg.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\n\norg.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\\\n\torg.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\\\n\torg.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver\n\norg.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator\n\norg.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver\n\norg.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager\n```\n\n# spring.xml文件的一些配置\n\n\n1. 配置扫描包\n\n\t```\n\t<!-- 配置controller扫描包，多个包之间用,分隔 -->\n\t<context:component-scan base-package=\"springmvc.controller\" />\n\t```\n2. 配置处理器映射器\n\n\t```\n\t<!-- 配置处理器映射器 -->\n<bean\n\tclass=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\" />\n```\n\n3. 配置处理器适配器\n\t```\n\t<!-- 配置处理器适配器 -->\n<bean\n\tclass=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\" />\n\t```\n\t\n4. 注解驱动(可替代注解处理器和适配器的配置)\n\n\t```\n\t<!-- 注解驱动 -->\n<mvc:annotation-driven />\n```\n\n5. 视图解析器\n\n\t```\n\t\t<!-- Example: prefix=\"/WEB-INF/jsp/\", suffix=\".jsp\", viewname=\"test\" -> \n\t\t\"/WEB-INF/jsp/test.jsp\" -->\n\t<!-- 配置视图解析器 -->\n\t<bean\n\t\tclass=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n\t\t<!-- 配置逻辑视图的前缀 -->\n\t\t<property name=\"prefix\" value=\"/WEB-INF/jsp/\" />\n\t\t<!-- 配置逻辑视图的后缀 -->\n\t\t<property name=\"suffix\" value=\".jsp\" />\n\t</bean>\n\t```\n\t\n6. 配置拦截器\n\n\t```\n<mvc:interceptor>\n\t<!-- 配置商品被拦截器拦截 -->\n\t<mvc:mapping path=\"/item/**\" />\n\t<!-- 配置具体的拦截器 -->\n\t<bean class=\"interceptor.LoginHandlerInterceptor\" />\n</mvc:interceptor>\n```\n\t\n\t拦截器的调用顺序：\npreHandle按拦截器定义顺序调用\npostHandler按拦截器定义逆序调用\nafterCompletion按拦截器定义逆序调用\npostHandler在拦截器链内所有拦截器返成功调用\nafterCompletion只有preHandle返回true才调用\n\n\n7. 配置上传解析器\n\n\t``` <!-- 文件上传,id必须设置为multipartResolver -->\n<bean id=\"multipartResolver\"\n\tclass=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">\n\t<!-- 设置文件上传大小 -->\n\t<property name=\"maxUploadSize\" value=\"5000000\" />\n</bean>\n```\n\n8. 异常处理器配置\n\n\t```\n<!-- 配置全局异常处理器 -->\n<bean \nid=\"customHandleException\" \tclass=\"exception.CustomHandleException\"/>\n```\n\n# 小问题\n注意两个区别\n@PathVariable是获取url上数据的。@RequestParam获取请求参数的（包括post表单提交）\n\n\n@RequestBody注解用于读取http请求的内容(字符串)，通过springmvc提供的HttpMessageConverter接口将读到的内容（json数据）转换为java对象并绑定到Controller方法的参数上。\n\n\n@ResponseBody\n作用：\n@ResponseBody注解用于将Controller的方法返回的对象，通过springmvc提供的HttpMessageConverter接口转换为指定格式的数据如：json,xml等，通过Response响应给客户端\n\n如果加上@ResponseBody注解，就不会走视图解析器，不会返回页面，目前返回的json数据。如果不加，就走视图解析器，返回页面。\n\n\t\n# web.xml\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txmlns=\"http://java.sun.com/xml/ns/javaee\"\n\txsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\n\tid=\"WebApp_ID\" version=\"2.5\">\n\t<display-name>springmvc-web</display-name>\n\t<welcome-file-list>\n\t\t<welcome-file>index.html</welcome-file>\n\t\t<welcome-file>index.htm</welcome-file>\n\t\t<welcome-file>index.jsp</welcome-file>\n\t\t<welcome-file>default.html</welcome-file>\n\t\t<welcome-file>default.htm</welcome-file>\n\t\t<welcome-file>default.jsp</welcome-file>\n\t</welcome-file-list>\n\n\t<!-- 配置spring -->\n\t<context-param>\n\t\t<param-name>contextConfigLocation</param-name>\n\t\t<param-value>classpath:spring/applicationContext*.xml</param-value>\n\t</context-param>\n\n\t<!-- 使用监听器加载Spring配置文件 -->\n\t<listener>\n\t\t<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n\t</listener>\n\n\t<!-- 配置SrpingMVC的前端控制器 -->\n\t<servlet>\n\t\t<servlet-name>springmvc-web</servlet-name>\n\t\t<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n\t\t<init-param>\n\t\t\t<param-name>contextConfigLocation</param-name>\n\t\t\t<param-value>classpath:spring/springmvc.xml</param-value>\n\t\t</init-param>\n\t</servlet>\n\n\t<servlet-mapping>\n\t\t<servlet-name>springmvc-web</servlet-name>\n\t\t<!-- 配置所有以action结尾的请求进入SpringMVC -->\n\t\t<url-pattern>*.action</url-pattern>\n\t</servlet-mapping>\n\t\t<!-- 解决post乱码问题 -->\n\t<filter>\n\t\t<filter-name>encoding</filter-name>\n\t\t<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n\t\t<!-- 设置编码参是UTF8 -->\n\t\t<init-param>\n\t\t\t<param-name>encoding</param-name>\n\t\t\t<param-value>UTF-8</param-value>\n\t\t</init-param>\n\t</filter>\n\t<filter-mapping>\n\t\t<filter-name>encoding</filter-name>\n\t\t<url-pattern>/*</url-pattern>\n\t</filter-mapping>\n</web-app>\n```\t\n\t\n# Spring MVC 与Struts2不同\n1. springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过滤器。\n2. springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。\n3. Struts采用值栈存储请求和响应的数据，通过OGNL存取数据， springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过request域传输到页面。Jsp视图解析器默认使用jstl。\n\n","slug":"Spring-MVC","published":1,"updated":"2017-09-17T11:41:41.000Z","layout":"post","photos":[],"link":"","_id":"cjd4d19zr000fryx47wmprb2t","content":"<h1 id=\"Spring-mvc请求流程\"><a href=\"#Spring-mvc请求流程\" class=\"headerlink\" title=\"Spring mvc请求流程\"></a>Spring mvc请求流程</h1><ol>\n<li>发送请求到前端控制器DispatcherServlet；</li>\n<li>DispatcherServlet调用HandleMapping处理器映射器；</li>\n<li>处理器映射器根据请求的URL找到具体的处理器，生成处理器对象以及处理器拦截器一并返回给DispatcherServlet；</li>\n<li>DispatcherServlet通过HandlerAdapter处理器适配器调用处理器；</li>\n<li>执行处理器（自己编写的controller，也叫后端处理器）；</li>\n<li>controller执行完后，返回ModelAndView；</li>\n<li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet；</li>\n<li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器；</li>\n<li>ViewReslover解析后返回具体View；</li>\n<li>DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中；</li>\n<li>DispatcherServlet响应用户；</li>\n</ol>\n<h1 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h1><ol>\n<li><p>DispatcherServlet(前端控制器)</p>\n<p> dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。</p>\n</li>\n<li><p>HandlerMapping（处理器映射器）</p>\n<p> HandlerMapping负责根据用户请求url找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p>\n</li>\n<li><p>HandlAdapter（处理器适配器）</p>\n<p> 通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p>\n</li>\n<li><p>Handler（处理器）</p>\n<p> Handler是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。<br>由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。</p>\n</li>\n<li><p>ViewResolver（视图解析器）</p>\n<p> View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 </p>\n</li>\n<li><p>View （视图）</p>\n<p> springmvc框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。<br>一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</p>\n<blockquote>\n<p>在springmvc的各个组件中，处理器映射器、处理器适配器、视图解析器称为springmvc的三大组件。<br>需要用户开发的组件有handler、view</p>\n</blockquote>\n</li>\n</ol>\n<h1 id=\"Spring-mvc-默认加载的组件\"><a href=\"#Spring-mvc-默认加载的组件\" class=\"headerlink\" title=\"Spring mvc 默认加载的组件\"></a>Spring mvc 默认加载的组件</h1><p>properties的位置：org.springframework.web.servlet下的DispatcherServlet.properties</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Default implementation classes for DispatcherServlet&apos;s strategy interfaces.</div><div class=\"line\"># Used as fallback when no matching beans are found in the DispatcherServlet context.</div><div class=\"line\"># Not meant to be customized by application developers.</div><div class=\"line\"></div><div class=\"line\">org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver</div><div class=\"line\"></div><div class=\"line\">org.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver</div><div class=\"line\"></div><div class=\"line\">org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\\</div><div class=\"line\">\torg.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping</div><div class=\"line\"></div><div class=\"line\">org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\\</div><div class=\"line\">\torg.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\\</div><div class=\"line\">\torg.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter</div><div class=\"line\"></div><div class=\"line\">org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\\</div><div class=\"line\">\torg.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\\</div><div class=\"line\">\torg.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</div><div class=\"line\"></div><div class=\"line\">org.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</div><div class=\"line\"></div><div class=\"line\">org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver</div><div class=\"line\"></div><div class=\"line\">org.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager</div></pre></td></tr></table></figure>\n<h1 id=\"spring-xml文件的一些配置\"><a href=\"#spring-xml文件的一些配置\" class=\"headerlink\" title=\"spring.xml文件的一些配置\"></a>spring.xml文件的一些配置</h1><ol>\n<li><p>配置扫描包</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- 配置controller扫描包，多个包之间用,分隔 --&gt;</div><div class=\"line\">&lt;context:component-scan base-package=&quot;springmvc.controller&quot; /&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>配置处理器映射器</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t&lt;!-- 配置处理器映射器 --&gt;</div><div class=\"line\">&lt;bean</div><div class=\"line\">\tclass=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot; /&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>配置处理器适配器</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t&lt;!-- 配置处理器适配器 --&gt;</div><div class=\"line\">&lt;bean</div><div class=\"line\">\tclass=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot; /&gt;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>注解驱动(可替代注解处理器和适配器的配置)</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t&lt;!-- 注解驱动 --&gt;</div><div class=\"line\">&lt;mvc:annotation-driven /&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>视图解析器</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t&lt;!-- Example: prefix=&quot;/WEB-INF/jsp/&quot;, suffix=&quot;.jsp&quot;, viewname=&quot;test&quot; -&gt; </div><div class=\"line\">\t&quot;/WEB-INF/jsp/test.jsp&quot; --&gt;</div><div class=\"line\">&lt;!-- 配置视图解析器 --&gt;</div><div class=\"line\">&lt;bean</div><div class=\"line\">\tclass=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</div><div class=\"line\">\t&lt;!-- 配置逻辑视图的前缀 --&gt;</div><div class=\"line\">\t&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;</div><div class=\"line\">\t&lt;!-- 配置逻辑视图的后缀 --&gt;</div><div class=\"line\">\t&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;</div><div class=\"line\">&lt;/bean&gt;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>配置拦截器</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;mvc:interceptor&gt;</div><div class=\"line\">\t&lt;!-- 配置商品被拦截器拦截 --&gt;</div><div class=\"line\">\t&lt;mvc:mapping path=&quot;/item/**&quot; /&gt;</div><div class=\"line\">\t&lt;!-- 配置具体的拦截器 --&gt;</div><div class=\"line\">\t&lt;bean class=&quot;interceptor.LoginHandlerInterceptor&quot; /&gt;</div><div class=\"line\">&lt;/mvc:interceptor&gt;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<pre><code>拦截器的调用顺序：\n</code></pre><p>preHandle按拦截器定义顺序调用<br>postHandler按拦截器定义逆序调用<br>afterCompletion按拦截器定义逆序调用<br>postHandler在拦截器链内所有拦截器返成功调用<br>afterCompletion只有preHandle返回true才调用</p>\n<ol>\n<li><p>配置上传解析器</p>\n <figure class=\"highlight plain\"><figcaption><span>文件上传,id必须设置为multipartResolver --></span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;bean id=&quot;multipartResolver&quot;</div><div class=\"line\">\tclass=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;</div><div class=\"line\">\t&lt;!-- 设置文件上传大小 --&gt;</div><div class=\"line\">\t&lt;property name=&quot;maxUploadSize&quot; value=&quot;5000000&quot; /&gt;</div><div class=\"line\">&lt;/bean&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>异常处理器配置</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- 配置全局异常处理器 --&gt;</div><div class=\"line\">&lt;bean </div><div class=\"line\">id=&quot;customHandleException&quot; \tclass=&quot;exception.CustomHandleException&quot;/&gt;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"小问题\"><a href=\"#小问题\" class=\"headerlink\" title=\"小问题\"></a>小问题</h1><p>注意两个区别<br>@PathVariable是获取url上数据的。@RequestParam获取请求参数的（包括post表单提交）</p>\n<p>@RequestBody注解用于读取http请求的内容(字符串)，通过springmvc提供的HttpMessageConverter接口将读到的内容（json数据）转换为java对象并绑定到Controller方法的参数上。</p>\n<p>@ResponseBody<br>作用：<br>@ResponseBody注解用于将Controller的方法返回的对象，通过springmvc提供的HttpMessageConverter接口转换为指定格式的数据如：json,xml等，通过Response响应给客户端</p>\n<p>如果加上@ResponseBody注解，就不会走视图解析器，不会返回页面，目前返回的json数据。如果不加，就走视图解析器，返回页面。</p>\n<h1 id=\"web-xml\"><a href=\"#web-xml\" class=\"headerlink\" title=\"web.xml\"></a>web.xml</h1><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;\n    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;\n    id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt;\n    &lt;display-name&gt;springmvc-web&lt;/display-name&gt;\n    &lt;welcome-file-list&gt;\n        &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;\n        &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;\n        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;\n        &lt;welcome-file&gt;default.html&lt;/welcome-file&gt;\n        &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt;\n        &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;\n    &lt;/welcome-file-list&gt;\n\n    &lt;!-- 配置spring --&gt;\n    &lt;context-param&gt;\n        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n        &lt;param-value&gt;classpath:spring/applicationContext*.xml&lt;/param-value&gt;\n    &lt;/context-param&gt;\n\n    &lt;!-- 使用监听器加载Spring配置文件 --&gt;\n    &lt;listener&gt;\n        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;\n    &lt;/listener&gt;\n\n    &lt;!-- 配置SrpingMVC的前端控制器 --&gt;\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;springmvc-web&lt;/servlet-name&gt;\n        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n            &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt;\n        &lt;/init-param&gt;\n    &lt;/servlet&gt;\n\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;springmvc-web&lt;/servlet-name&gt;\n        &lt;!-- 配置所有以action结尾的请求进入SpringMVC --&gt;\n        &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n        &lt;!-- 解决post乱码问题 --&gt;\n    &lt;filter&gt;\n        &lt;filter-name&gt;encoding&lt;/filter-name&gt;\n        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;\n        &lt;!-- 设置编码参是UTF8 --&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;encoding&lt;/param-name&gt;\n            &lt;param-value&gt;UTF-8&lt;/param-value&gt;\n        &lt;/init-param&gt;\n    &lt;/filter&gt;\n    &lt;filter-mapping&gt;\n        &lt;filter-name&gt;encoding&lt;/filter-name&gt;\n        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n    &lt;/filter-mapping&gt;\n&lt;/web-app&gt;\n</code></pre><h1 id=\"Spring-MVC-与Struts2不同\"><a href=\"#Spring-MVC-与Struts2不同\" class=\"headerlink\" title=\"Spring MVC 与Struts2不同\"></a>Spring MVC 与Struts2不同</h1><ol>\n<li>springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过滤器。</li>\n<li>springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。</li>\n<li>Struts采用值栈存储请求和响应的数据，通过OGNL存取数据， springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过request域传输到页面。Jsp视图解析器默认使用jstl。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Spring-mvc请求流程\"><a href=\"#Spring-mvc请求流程\" class=\"headerlink\" title=\"Spring mvc请求流程\"></a>Spring mvc请求流程</h1><ol>\n<li>发送请求到前端控制器DispatcherServlet；</li>\n<li>DispatcherServlet调用HandleMapping处理器映射器；</li>\n<li>处理器映射器根据请求的URL找到具体的处理器，生成处理器对象以及处理器拦截器一并返回给DispatcherServlet；</li>\n<li>DispatcherServlet通过HandlerAdapter处理器适配器调用处理器；</li>\n<li>执行处理器（自己编写的controller，也叫后端处理器）；</li>\n<li>controller执行完后，返回ModelAndView；</li>\n<li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet；</li>\n<li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器；</li>\n<li>ViewReslover解析后返回具体View；</li>\n<li>DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中；</li>\n<li>DispatcherServlet响应用户；</li>\n</ol>\n<h1 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h1><ol>\n<li><p>DispatcherServlet(前端控制器)</p>\n<p> dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。</p>\n</li>\n<li><p>HandlerMapping（处理器映射器）</p>\n<p> HandlerMapping负责根据用户请求url找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p>\n</li>\n<li><p>HandlAdapter（处理器适配器）</p>\n<p> 通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p>\n</li>\n<li><p>Handler（处理器）</p>\n<p> Handler是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。<br>由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。</p>\n</li>\n<li><p>ViewResolver（视图解析器）</p>\n<p> View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 </p>\n</li>\n<li><p>View （视图）</p>\n<p> springmvc框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。<br>一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</p>\n<blockquote>\n<p>在springmvc的各个组件中，处理器映射器、处理器适配器、视图解析器称为springmvc的三大组件。<br>需要用户开发的组件有handler、view</p>\n</blockquote>\n</li>\n</ol>\n<h1 id=\"Spring-mvc-默认加载的组件\"><a href=\"#Spring-mvc-默认加载的组件\" class=\"headerlink\" title=\"Spring mvc 默认加载的组件\"></a>Spring mvc 默认加载的组件</h1><p>properties的位置：org.springframework.web.servlet下的DispatcherServlet.properties</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Default implementation classes for DispatcherServlet&apos;s strategy interfaces.</div><div class=\"line\"># Used as fallback when no matching beans are found in the DispatcherServlet context.</div><div class=\"line\"># Not meant to be customized by application developers.</div><div class=\"line\"></div><div class=\"line\">org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver</div><div class=\"line\"></div><div class=\"line\">org.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver</div><div class=\"line\"></div><div class=\"line\">org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\\</div><div class=\"line\">\torg.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping</div><div class=\"line\"></div><div class=\"line\">org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\\</div><div class=\"line\">\torg.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\\</div><div class=\"line\">\torg.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter</div><div class=\"line\"></div><div class=\"line\">org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\\</div><div class=\"line\">\torg.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\\</div><div class=\"line\">\torg.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</div><div class=\"line\"></div><div class=\"line\">org.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</div><div class=\"line\"></div><div class=\"line\">org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver</div><div class=\"line\"></div><div class=\"line\">org.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager</div></pre></td></tr></table></figure>\n<h1 id=\"spring-xml文件的一些配置\"><a href=\"#spring-xml文件的一些配置\" class=\"headerlink\" title=\"spring.xml文件的一些配置\"></a>spring.xml文件的一些配置</h1><ol>\n<li><p>配置扫描包</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- 配置controller扫描包，多个包之间用,分隔 --&gt;</div><div class=\"line\">&lt;context:component-scan base-package=&quot;springmvc.controller&quot; /&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>配置处理器映射器</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t&lt;!-- 配置处理器映射器 --&gt;</div><div class=\"line\">&lt;bean</div><div class=\"line\">\tclass=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot; /&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>配置处理器适配器</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t&lt;!-- 配置处理器适配器 --&gt;</div><div class=\"line\">&lt;bean</div><div class=\"line\">\tclass=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot; /&gt;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>注解驱动(可替代注解处理器和适配器的配置)</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t&lt;!-- 注解驱动 --&gt;</div><div class=\"line\">&lt;mvc:annotation-driven /&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>视图解析器</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t&lt;!-- Example: prefix=&quot;/WEB-INF/jsp/&quot;, suffix=&quot;.jsp&quot;, viewname=&quot;test&quot; -&gt; </div><div class=\"line\">\t&quot;/WEB-INF/jsp/test.jsp&quot; --&gt;</div><div class=\"line\">&lt;!-- 配置视图解析器 --&gt;</div><div class=\"line\">&lt;bean</div><div class=\"line\">\tclass=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</div><div class=\"line\">\t&lt;!-- 配置逻辑视图的前缀 --&gt;</div><div class=\"line\">\t&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;</div><div class=\"line\">\t&lt;!-- 配置逻辑视图的后缀 --&gt;</div><div class=\"line\">\t&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;</div><div class=\"line\">&lt;/bean&gt;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>配置拦截器</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;mvc:interceptor&gt;</div><div class=\"line\">\t&lt;!-- 配置商品被拦截器拦截 --&gt;</div><div class=\"line\">\t&lt;mvc:mapping path=&quot;/item/**&quot; /&gt;</div><div class=\"line\">\t&lt;!-- 配置具体的拦截器 --&gt;</div><div class=\"line\">\t&lt;bean class=&quot;interceptor.LoginHandlerInterceptor&quot; /&gt;</div><div class=\"line\">&lt;/mvc:interceptor&gt;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<pre><code>拦截器的调用顺序：\n</code></pre><p>preHandle按拦截器定义顺序调用<br>postHandler按拦截器定义逆序调用<br>afterCompletion按拦截器定义逆序调用<br>postHandler在拦截器链内所有拦截器返成功调用<br>afterCompletion只有preHandle返回true才调用</p>\n<ol>\n<li><p>配置上传解析器</p>\n <figure class=\"highlight plain\"><figcaption><span>文件上传,id必须设置为multipartResolver --></span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;bean id=&quot;multipartResolver&quot;</div><div class=\"line\">\tclass=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;</div><div class=\"line\">\t&lt;!-- 设置文件上传大小 --&gt;</div><div class=\"line\">\t&lt;property name=&quot;maxUploadSize&quot; value=&quot;5000000&quot; /&gt;</div><div class=\"line\">&lt;/bean&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>异常处理器配置</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- 配置全局异常处理器 --&gt;</div><div class=\"line\">&lt;bean </div><div class=\"line\">id=&quot;customHandleException&quot; \tclass=&quot;exception.CustomHandleException&quot;/&gt;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"小问题\"><a href=\"#小问题\" class=\"headerlink\" title=\"小问题\"></a>小问题</h1><p>注意两个区别<br>@PathVariable是获取url上数据的。@RequestParam获取请求参数的（包括post表单提交）</p>\n<p>@RequestBody注解用于读取http请求的内容(字符串)，通过springmvc提供的HttpMessageConverter接口将读到的内容（json数据）转换为java对象并绑定到Controller方法的参数上。</p>\n<p>@ResponseBody<br>作用：<br>@ResponseBody注解用于将Controller的方法返回的对象，通过springmvc提供的HttpMessageConverter接口转换为指定格式的数据如：json,xml等，通过Response响应给客户端</p>\n<p>如果加上@ResponseBody注解，就不会走视图解析器，不会返回页面，目前返回的json数据。如果不加，就走视图解析器，返回页面。</p>\n<h1 id=\"web-xml\"><a href=\"#web-xml\" class=\"headerlink\" title=\"web.xml\"></a>web.xml</h1><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;\n    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;\n    id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt;\n    &lt;display-name&gt;springmvc-web&lt;/display-name&gt;\n    &lt;welcome-file-list&gt;\n        &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;\n        &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;\n        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;\n        &lt;welcome-file&gt;default.html&lt;/welcome-file&gt;\n        &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt;\n        &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;\n    &lt;/welcome-file-list&gt;\n\n    &lt;!-- 配置spring --&gt;\n    &lt;context-param&gt;\n        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n        &lt;param-value&gt;classpath:spring/applicationContext*.xml&lt;/param-value&gt;\n    &lt;/context-param&gt;\n\n    &lt;!-- 使用监听器加载Spring配置文件 --&gt;\n    &lt;listener&gt;\n        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;\n    &lt;/listener&gt;\n\n    &lt;!-- 配置SrpingMVC的前端控制器 --&gt;\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;springmvc-web&lt;/servlet-name&gt;\n        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n            &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt;\n        &lt;/init-param&gt;\n    &lt;/servlet&gt;\n\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;springmvc-web&lt;/servlet-name&gt;\n        &lt;!-- 配置所有以action结尾的请求进入SpringMVC --&gt;\n        &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n        &lt;!-- 解决post乱码问题 --&gt;\n    &lt;filter&gt;\n        &lt;filter-name&gt;encoding&lt;/filter-name&gt;\n        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;\n        &lt;!-- 设置编码参是UTF8 --&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;encoding&lt;/param-name&gt;\n            &lt;param-value&gt;UTF-8&lt;/param-value&gt;\n        &lt;/init-param&gt;\n    &lt;/filter&gt;\n    &lt;filter-mapping&gt;\n        &lt;filter-name&gt;encoding&lt;/filter-name&gt;\n        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n    &lt;/filter-mapping&gt;\n&lt;/web-app&gt;\n</code></pre><h1 id=\"Spring-MVC-与Struts2不同\"><a href=\"#Spring-MVC-与Struts2不同\" class=\"headerlink\" title=\"Spring MVC 与Struts2不同\"></a>Spring MVC 与Struts2不同</h1><ol>\n<li>springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过滤器。</li>\n<li>springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。</li>\n<li>Struts采用值栈存储请求和响应的数据，通过OGNL存取数据， springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过request域传输到页面。Jsp视图解析器默认使用jstl。</li>\n</ol>\n"},{"title":"c++ 模板","date":"2017-03-05T02:15:38.000Z","comments":1,"update":"2017-03-05T08:34:59.000Z","_content":"\r模板是C++支持参数化多态的工具，使用模板可以使用户为类或者函数声明一种一般模式，使得类中的某些数据成员或者成员函数的参数、返回值取得任意类型。\n\r模板是一种对类型进行参数化的工具；通常有两种形式：函数模板和类模板；函数模板针对仅参数类型不同的函数；类模板针对仅数据成员和成员函数类型不同的类。\n\r使用模板的目的：就是能够让程序员编写与类型无关的代码。\n\n注意：模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行，比如不能在main函数中声明或定义一个模板。\n\r##\t 1.函数模板定义格式:\r\ttemplate <class 形参名，class 形参名，......> 返回类型 函数名(参数列表)\r\t{\t函数体 }\n\t\r> 模板形参不能为空。一但声明了模板函数就可以用模板函数的形参名声明类中的成员变量和成员函数，即可以在该函数中使用内置类型的地方都可以使用模板形参名。\n\r## 2.函数模板\r>1. 函数模板可以用来创建一个通用功能的函数，以支持多种不同形参，进一步简化重载函数的函数体设计。\r2. 函数模板提供一个种用来自动生成各种类型函数实例的算法，程序员对于函数接口参数和返回类型中的全部或者部分类型进行参数化(parameterize)，而函数体保持不变。  \n\t**注意**：模板形参不能为空。一但声明了模板函数就可以用模板函数的形参名声明类中的成员变量和成员函数，即可以在该函数中使用内置类型的地方都可以使用模板形参名。  \n\t**注意**：对于函数模板而言不存在 h(int,int) 这样的调用，不能在函数调用的参数中指定模板形参的类型，对函数模板的调用应使用实参推演来进行，即只能进行 h(2,3) 这样的调用，或者int a, b; h(a,b)\r3. \t函数模板实例化\r4. \t函数模板只是声明了一个函数的描述即模板，不是一个可以直接执行的函数，只有根据实际情况用实参的数据类型代替类型参数标识符之后，才能产生真正的函数。\r5.\t函数模板的数据类型参数标识符实际上是一个类型形参，在使用函数模板时，要将这个形参实例化为确定的数据类型。将类型形参实例化的参数称为模板实参，用模板实参实例化的函数称为模板函数。模板函数的生成就是将函数模板的类型形参实例化的过程。\r6.\t函数模板在它被调用或取其地址时被实例化\r7.\t模板函数类似于重载函数，但两者有很大区别：函数重载时，每个函数体内可以执行不同的动作，但同一个函数模板实例化后的模板函数都必须执行相同的动作 \r\r## 3.函数模板与同名的非模板函数重载时，应遵循下列调用原则： \r> 1.\t寻找一个参数完全匹配的函数，若找到就调用它。若参数完全匹配的函数多于一个，则这个调用是一个错误的调用。 \r2.\t寻找一个函数模板，若找到就将其实例化生成一个匹配的模板函数并调用它。 \r3.\t若上面两条都失败，则使用函数重载的方法，通过类型转换产生参数匹配，若找到就调用它。\r4.\t若上面三条都失败，还没有找都匹配的函数，则这个调用是一个错误的调用\n\r## 4.类模板定义：\r\ttemplate<class  形参名，class 形参名，…>   \r\tclass 类名\r\t{... };\n\t\r> 类模板和函数模板都是以template开始后接模板形参列表组成，模板形参不能为空，一但声明了类模板就可以用类模板的形参名声明类中的成员变量和成员函数，即可以在类中使用内置类型的地方都可以使用模板形参名来声明。比如:\r\t\n\ttemplate<class T> class A{public: T a; T b; T hy(T c, T &d);};\r\r## 5.类模板对象的创建：\r> 1. 比如一个模板类A，则使用类模板创建对象的方法为A<int> m;在类A后面跟上一个<>尖括号并在里面填上相应的类型，这样的话类A中凡是用到模板形参的地方都会被int 所代替。当类模板有两个模板形参时创建对象的方法为A<int, double> m;类型之间用逗号隔开。\r2. 对于类模板，模板形参的类型必须在类名后的尖括号中明确指定。比如A<2> m;用这种方法把模板形参设置为int是错误的（编译错误：error C2079: 'a' uses undefined class 'A<int>'），类模板形参不存在实参推演的问题。也就是说不能把整型值2推演为int 型传递给模板形参。要把类模板形参调置为int 型必须这样指定A<int> m。\r\r## 6.在类模板外部定义成员函数的方法为：\r\ttemplate<模板形参列表> 函数返回类型 类名<模板形参名>::函数名(参数列表){函数体}；\r> 比如有两个模板形参T1，T2的类A中含有一个void h()函数，则定义该函数的语法为：　\n\n\ttemplate<class T1,class T2> void A<T1,T2>::h(){}。\n\t\r> 注意：当在类外面定义类的成员时template后面的模板形参应与要定义的类的模板形参一致。\r\r## 7.模板的实例化：类模板在引用实际模板类类型时实例化\r> 1. 定义模板类对象时\r2. \t通过类指针或引用指向一个类模板实例时，只有当检查这个指针或引用指的那个对象时(访问数据成员或成员函数)，才会实例化\r3. \t当类模板被实例化时，类模板的成员函数并不自动被实例化。只有该函数被调用或取地址时，才被实例化。\r4.\t静态数据成员只有被使用时才实例化。\r\r## 8.类模板和函数模板区别\r> 1. 函数模板允许重载 ，而类模板不允许重载(类无重载概念，即不存在同名类模板)。\r2. 类模板可以进行全特化和偏特化，而函数模板仅能够全特化 。\r3. 类模板支持默认参数，函数模板不支持\r\r","source":"_posts/c-模板.md","raw":"---\ntitle: c++ 模板\ndate: 2017-03-05 10:15:38\ncomments: true\ntags:\n  - 模板\n  - C++\ncategories:\n  - C++\nupdate: 2017-03-05 16:34:59\n\n---\n\r模板是C++支持参数化多态的工具，使用模板可以使用户为类或者函数声明一种一般模式，使得类中的某些数据成员或者成员函数的参数、返回值取得任意类型。\n\r模板是一种对类型进行参数化的工具；通常有两种形式：函数模板和类模板；函数模板针对仅参数类型不同的函数；类模板针对仅数据成员和成员函数类型不同的类。\n\r使用模板的目的：就是能够让程序员编写与类型无关的代码。\n\n注意：模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行，比如不能在main函数中声明或定义一个模板。\n\r##\t 1.函数模板定义格式:\r\ttemplate <class 形参名，class 形参名，......> 返回类型 函数名(参数列表)\r\t{\t函数体 }\n\t\r> 模板形参不能为空。一但声明了模板函数就可以用模板函数的形参名声明类中的成员变量和成员函数，即可以在该函数中使用内置类型的地方都可以使用模板形参名。\n\r## 2.函数模板\r>1. 函数模板可以用来创建一个通用功能的函数，以支持多种不同形参，进一步简化重载函数的函数体设计。\r2. 函数模板提供一个种用来自动生成各种类型函数实例的算法，程序员对于函数接口参数和返回类型中的全部或者部分类型进行参数化(parameterize)，而函数体保持不变。  \n\t**注意**：模板形参不能为空。一但声明了模板函数就可以用模板函数的形参名声明类中的成员变量和成员函数，即可以在该函数中使用内置类型的地方都可以使用模板形参名。  \n\t**注意**：对于函数模板而言不存在 h(int,int) 这样的调用，不能在函数调用的参数中指定模板形参的类型，对函数模板的调用应使用实参推演来进行，即只能进行 h(2,3) 这样的调用，或者int a, b; h(a,b)\r3. \t函数模板实例化\r4. \t函数模板只是声明了一个函数的描述即模板，不是一个可以直接执行的函数，只有根据实际情况用实参的数据类型代替类型参数标识符之后，才能产生真正的函数。\r5.\t函数模板的数据类型参数标识符实际上是一个类型形参，在使用函数模板时，要将这个形参实例化为确定的数据类型。将类型形参实例化的参数称为模板实参，用模板实参实例化的函数称为模板函数。模板函数的生成就是将函数模板的类型形参实例化的过程。\r6.\t函数模板在它被调用或取其地址时被实例化\r7.\t模板函数类似于重载函数，但两者有很大区别：函数重载时，每个函数体内可以执行不同的动作，但同一个函数模板实例化后的模板函数都必须执行相同的动作 \r\r## 3.函数模板与同名的非模板函数重载时，应遵循下列调用原则： \r> 1.\t寻找一个参数完全匹配的函数，若找到就调用它。若参数完全匹配的函数多于一个，则这个调用是一个错误的调用。 \r2.\t寻找一个函数模板，若找到就将其实例化生成一个匹配的模板函数并调用它。 \r3.\t若上面两条都失败，则使用函数重载的方法，通过类型转换产生参数匹配，若找到就调用它。\r4.\t若上面三条都失败，还没有找都匹配的函数，则这个调用是一个错误的调用\n\r## 4.类模板定义：\r\ttemplate<class  形参名，class 形参名，…>   \r\tclass 类名\r\t{... };\n\t\r> 类模板和函数模板都是以template开始后接模板形参列表组成，模板形参不能为空，一但声明了类模板就可以用类模板的形参名声明类中的成员变量和成员函数，即可以在类中使用内置类型的地方都可以使用模板形参名来声明。比如:\r\t\n\ttemplate<class T> class A{public: T a; T b; T hy(T c, T &d);};\r\r## 5.类模板对象的创建：\r> 1. 比如一个模板类A，则使用类模板创建对象的方法为A<int> m;在类A后面跟上一个<>尖括号并在里面填上相应的类型，这样的话类A中凡是用到模板形参的地方都会被int 所代替。当类模板有两个模板形参时创建对象的方法为A<int, double> m;类型之间用逗号隔开。\r2. 对于类模板，模板形参的类型必须在类名后的尖括号中明确指定。比如A<2> m;用这种方法把模板形参设置为int是错误的（编译错误：error C2079: 'a' uses undefined class 'A<int>'），类模板形参不存在实参推演的问题。也就是说不能把整型值2推演为int 型传递给模板形参。要把类模板形参调置为int 型必须这样指定A<int> m。\r\r## 6.在类模板外部定义成员函数的方法为：\r\ttemplate<模板形参列表> 函数返回类型 类名<模板形参名>::函数名(参数列表){函数体}；\r> 比如有两个模板形参T1，T2的类A中含有一个void h()函数，则定义该函数的语法为：　\n\n\ttemplate<class T1,class T2> void A<T1,T2>::h(){}。\n\t\r> 注意：当在类外面定义类的成员时template后面的模板形参应与要定义的类的模板形参一致。\r\r## 7.模板的实例化：类模板在引用实际模板类类型时实例化\r> 1. 定义模板类对象时\r2. \t通过类指针或引用指向一个类模板实例时，只有当检查这个指针或引用指的那个对象时(访问数据成员或成员函数)，才会实例化\r3. \t当类模板被实例化时，类模板的成员函数并不自动被实例化。只有该函数被调用或取地址时，才被实例化。\r4.\t静态数据成员只有被使用时才实例化。\r\r## 8.类模板和函数模板区别\r> 1. 函数模板允许重载 ，而类模板不允许重载(类无重载概念，即不存在同名类模板)。\r2. 类模板可以进行全特化和偏特化，而函数模板仅能够全特化 。\r3. 类模板支持默认参数，函数模板不支持\r\r","slug":"c-模板","published":1,"updated":"2017-09-02T10:12:19.000Z","layout":"post","photos":[],"link":"","_id":"cjd4d19zu000iryx4l8tr6wic","content":"<p>模板是C++支持参数化多态的工具，使用模板可以使用户为类或者函数声明一种一般模式，使得类中的某些数据成员或者成员函数的参数、返回值取得任意类型。</p>\n<p>模板是一种对类型进行参数化的工具；通常有两种形式：函数模板和类模板；函数模板针对仅参数类型不同的函数；类模板针对仅数据成员和成员函数类型不同的类。</p>\n<p>使用模板的目的：就是能够让程序员编写与类型无关的代码。</p>\n<p>注意：模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行，比如不能在main函数中声明或定义一个模板。</p>\n<h2 id=\"1-函数模板定义格式\"><a href=\"#1-函数模板定义格式\" class=\"headerlink\" title=\"1.函数模板定义格式:\"></a>1.函数模板定义格式:</h2><pre><code>template &lt;class 形参名，class 形参名，......&gt; 返回类型 函数名(参数列表)\n{    函数体 }\n</code></pre><blockquote>\n<p>模板形参不能为空。一但声明了模板函数就可以用模板函数的形参名声明类中的成员变量和成员函数，即可以在该函数中使用内置类型的地方都可以使用模板形参名。</p>\n</blockquote>\n<h2 id=\"2-函数模板\"><a href=\"#2-函数模板\" class=\"headerlink\" title=\"2.函数模板\"></a>2.函数模板</h2><blockquote>\n<ol>\n<li>函数模板可以用来创建一个通用功能的函数，以支持多种不同形参，进一步简化重载函数的函数体设计。</li>\n<li>函数模板提供一个种用来自动生成各种类型函数实例的算法，程序员对于函数接口参数和返回类型中的全部或者部分类型进行参数化(parameterize)，而函数体保持不变。<br> <strong>注意</strong>：模板形参不能为空。一但声明了模板函数就可以用模板函数的形参名声明类中的成员变量和成员函数，即可以在该函数中使用内置类型的地方都可以使用模板形参名。<br> <strong>注意</strong>：对于函数模板而言不存在 h(int,int) 这样的调用，不能在函数调用的参数中指定模板形参的类型，对函数模板的调用应使用实参推演来进行，即只能进行 h(2,3) 这样的调用，或者int a, b; h(a,b)</li>\n<li>函数模板实例化</li>\n<li>函数模板只是声明了一个函数的描述即模板，不是一个可以直接执行的函数，只有根据实际情况用实参的数据类型代替类型参数标识符之后，才能产生真正的函数。</li>\n<li>函数模板的数据类型参数标识符实际上是一个类型形参，在使用函数模板时，要将这个形参实例化为确定的数据类型。将类型形参实例化的参数称为模板实参，用模板实参实例化的函数称为模板函数。模板函数的生成就是将函数模板的类型形参实例化的过程。</li>\n<li>函数模板在它被调用或取其地址时被实例化</li>\n<li>模板函数类似于重载函数，但两者有很大区别：函数重载时，每个函数体内可以执行不同的动作，但同一个函数模板实例化后的模板函数都必须执行相同的动作 </li>\n</ol>\n</blockquote>\n<h2 id=\"3-函数模板与同名的非模板函数重载时，应遵循下列调用原则：\"><a href=\"#3-函数模板与同名的非模板函数重载时，应遵循下列调用原则：\" class=\"headerlink\" title=\"3.函数模板与同名的非模板函数重载时，应遵循下列调用原则：\"></a>3.函数模板与同名的非模板函数重载时，应遵循下列调用原则：</h2><blockquote>\n<ol>\n<li>寻找一个参数完全匹配的函数，若找到就调用它。若参数完全匹配的函数多于一个，则这个调用是一个错误的调用。 </li>\n<li>寻找一个函数模板，若找到就将其实例化生成一个匹配的模板函数并调用它。 </li>\n<li>若上面两条都失败，则使用函数重载的方法，通过类型转换产生参数匹配，若找到就调用它。</li>\n<li>若上面三条都失败，还没有找都匹配的函数，则这个调用是一个错误的调用</li>\n</ol>\n</blockquote>\n<h2 id=\"4-类模板定义：\"><a href=\"#4-类模板定义：\" class=\"headerlink\" title=\"4.类模板定义：\"></a>4.类模板定义：</h2><pre><code>template&lt;class  形参名，class 形参名，…&gt;   \nclass 类名\n{... };\n</code></pre><blockquote>\n<p>类模板和函数模板都是以template开始后接模板形参列表组成，模板形参不能为空，一但声明了类模板就可以用类模板的形参名声明类中的成员变量和成员函数，即可以在类中使用内置类型的地方都可以使用模板形参名来声明。比如:</p>\n</blockquote>\n<pre><code>template&lt;class T&gt; class A{public: T a; T b; T hy(T c, T &amp;d);};\n</code></pre><h2 id=\"5-类模板对象的创建：\"><a href=\"#5-类模板对象的创建：\" class=\"headerlink\" title=\"5.类模板对象的创建：\"></a>5.类模板对象的创建：</h2><blockquote>\n<ol>\n<li>比如一个模板类A，则使用类模板创建对象的方法为A<int> m;在类A后面跟上一个&lt;&gt;尖括号并在里面填上相应的类型，这样的话类A中凡是用到模板形参的地方都会被int 所代替。当类模板有两个模板形参时创建对象的方法为A<int, double=\"\"> m;类型之间用逗号隔开。</int,></int></li>\n<li>对于类模板，模板形参的类型必须在类名后的尖括号中明确指定。比如A<2> m;用这种方法把模板形参设置为int是错误的（编译错误：error C2079: ‘a’ uses undefined class ‘A<int>‘），类模板形参不存在实参推演的问题。也就是说不能把整型值2推演为int 型传递给模板形参。要把类模板形参调置为int 型必须这样指定A<int> m。</int></int></2></li>\n</ol>\n</blockquote>\n<h2 id=\"6-在类模板外部定义成员函数的方法为：\"><a href=\"#6-在类模板外部定义成员函数的方法为：\" class=\"headerlink\" title=\"6.在类模板外部定义成员函数的方法为：\"></a>6.在类模板外部定义成员函数的方法为：</h2><pre><code>template&lt;模板形参列表&gt; 函数返回类型 类名&lt;模板形参名&gt;::函数名(参数列表){函数体}；\n</code></pre><blockquote>\n<p>比如有两个模板形参T1，T2的类A中含有一个void h()函数，则定义该函数的语法为：　</p>\n</blockquote>\n<pre><code>template&lt;class T1,class T2&gt; void A&lt;T1,T2&gt;::h(){}。\n</code></pre><blockquote>\n<p>注意：当在类外面定义类的成员时template后面的模板形参应与要定义的类的模板形参一致。</p>\n</blockquote>\n<h2 id=\"7-模板的实例化：类模板在引用实际模板类类型时实例化\"><a href=\"#7-模板的实例化：类模板在引用实际模板类类型时实例化\" class=\"headerlink\" title=\"7.模板的实例化：类模板在引用实际模板类类型时实例化\"></a>7.模板的实例化：类模板在引用实际模板类类型时实例化</h2><blockquote>\n<ol>\n<li>定义模板类对象时</li>\n<li>通过类指针或引用指向一个类模板实例时，只有当检查这个指针或引用指的那个对象时(访问数据成员或成员函数)，才会实例化</li>\n<li>当类模板被实例化时，类模板的成员函数并不自动被实例化。只有该函数被调用或取地址时，才被实例化。</li>\n<li>静态数据成员只有被使用时才实例化。</li>\n</ol>\n</blockquote>\n<h2 id=\"8-类模板和函数模板区别\"><a href=\"#8-类模板和函数模板区别\" class=\"headerlink\" title=\"8.类模板和函数模板区别\"></a>8.类模板和函数模板区别</h2><blockquote>\n<ol>\n<li>函数模板允许重载 ，而类模板不允许重载(类无重载概念，即不存在同名类模板)。</li>\n<li>类模板可以进行全特化和偏特化，而函数模板仅能够全特化 。</li>\n<li>类模板支持默认参数，函数模板不支持</li>\n</ol>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>模板是C++支持参数化多态的工具，使用模板可以使用户为类或者函数声明一种一般模式，使得类中的某些数据成员或者成员函数的参数、返回值取得任意类型。</p>\n<p>模板是一种对类型进行参数化的工具；通常有两种形式：函数模板和类模板；函数模板针对仅参数类型不同的函数；类模板针对仅数据成员和成员函数类型不同的类。</p>\n<p>使用模板的目的：就是能够让程序员编写与类型无关的代码。</p>\n<p>注意：模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行，比如不能在main函数中声明或定义一个模板。</p>\n<h2 id=\"1-函数模板定义格式\"><a href=\"#1-函数模板定义格式\" class=\"headerlink\" title=\"1.函数模板定义格式:\"></a>1.函数模板定义格式:</h2><pre><code>template &lt;class 形参名，class 形参名，......&gt; 返回类型 函数名(参数列表)\n{    函数体 }\n</code></pre><blockquote>\n<p>模板形参不能为空。一但声明了模板函数就可以用模板函数的形参名声明类中的成员变量和成员函数，即可以在该函数中使用内置类型的地方都可以使用模板形参名。</p>\n</blockquote>\n<h2 id=\"2-函数模板\"><a href=\"#2-函数模板\" class=\"headerlink\" title=\"2.函数模板\"></a>2.函数模板</h2><blockquote>\n<ol>\n<li>函数模板可以用来创建一个通用功能的函数，以支持多种不同形参，进一步简化重载函数的函数体设计。</li>\n<li>函数模板提供一个种用来自动生成各种类型函数实例的算法，程序员对于函数接口参数和返回类型中的全部或者部分类型进行参数化(parameterize)，而函数体保持不变。<br> <strong>注意</strong>：模板形参不能为空。一但声明了模板函数就可以用模板函数的形参名声明类中的成员变量和成员函数，即可以在该函数中使用内置类型的地方都可以使用模板形参名。<br> <strong>注意</strong>：对于函数模板而言不存在 h(int,int) 这样的调用，不能在函数调用的参数中指定模板形参的类型，对函数模板的调用应使用实参推演来进行，即只能进行 h(2,3) 这样的调用，或者int a, b; h(a,b)</li>\n<li>函数模板实例化</li>\n<li>函数模板只是声明了一个函数的描述即模板，不是一个可以直接执行的函数，只有根据实际情况用实参的数据类型代替类型参数标识符之后，才能产生真正的函数。</li>\n<li>函数模板的数据类型参数标识符实际上是一个类型形参，在使用函数模板时，要将这个形参实例化为确定的数据类型。将类型形参实例化的参数称为模板实参，用模板实参实例化的函数称为模板函数。模板函数的生成就是将函数模板的类型形参实例化的过程。</li>\n<li>函数模板在它被调用或取其地址时被实例化</li>\n<li>模板函数类似于重载函数，但两者有很大区别：函数重载时，每个函数体内可以执行不同的动作，但同一个函数模板实例化后的模板函数都必须执行相同的动作 </li>\n</ol>\n</blockquote>\n<h2 id=\"3-函数模板与同名的非模板函数重载时，应遵循下列调用原则：\"><a href=\"#3-函数模板与同名的非模板函数重载时，应遵循下列调用原则：\" class=\"headerlink\" title=\"3.函数模板与同名的非模板函数重载时，应遵循下列调用原则：\"></a>3.函数模板与同名的非模板函数重载时，应遵循下列调用原则：</h2><blockquote>\n<ol>\n<li>寻找一个参数完全匹配的函数，若找到就调用它。若参数完全匹配的函数多于一个，则这个调用是一个错误的调用。 </li>\n<li>寻找一个函数模板，若找到就将其实例化生成一个匹配的模板函数并调用它。 </li>\n<li>若上面两条都失败，则使用函数重载的方法，通过类型转换产生参数匹配，若找到就调用它。</li>\n<li>若上面三条都失败，还没有找都匹配的函数，则这个调用是一个错误的调用</li>\n</ol>\n</blockquote>\n<h2 id=\"4-类模板定义：\"><a href=\"#4-类模板定义：\" class=\"headerlink\" title=\"4.类模板定义：\"></a>4.类模板定义：</h2><pre><code>template&lt;class  形参名，class 形参名，…&gt;   \nclass 类名\n{... };\n</code></pre><blockquote>\n<p>类模板和函数模板都是以template开始后接模板形参列表组成，模板形参不能为空，一但声明了类模板就可以用类模板的形参名声明类中的成员变量和成员函数，即可以在类中使用内置类型的地方都可以使用模板形参名来声明。比如:</p>\n</blockquote>\n<pre><code>template&lt;class T&gt; class A{public: T a; T b; T hy(T c, T &amp;d);};\n</code></pre><h2 id=\"5-类模板对象的创建：\"><a href=\"#5-类模板对象的创建：\" class=\"headerlink\" title=\"5.类模板对象的创建：\"></a>5.类模板对象的创建：</h2><blockquote>\n<ol>\n<li>比如一个模板类A，则使用类模板创建对象的方法为A<int> m;在类A后面跟上一个&lt;&gt;尖括号并在里面填上相应的类型，这样的话类A中凡是用到模板形参的地方都会被int 所代替。当类模板有两个模板形参时创建对象的方法为A<int, double=\"\"> m;类型之间用逗号隔开。</int,></int></li>\n<li>对于类模板，模板形参的类型必须在类名后的尖括号中明确指定。比如A<2> m;用这种方法把模板形参设置为int是错误的（编译错误：error C2079: ‘a’ uses undefined class ‘A<int>‘），类模板形参不存在实参推演的问题。也就是说不能把整型值2推演为int 型传递给模板形参。要把类模板形参调置为int 型必须这样指定A<int> m。</int></int></2></li>\n</ol>\n</blockquote>\n<h2 id=\"6-在类模板外部定义成员函数的方法为：\"><a href=\"#6-在类模板外部定义成员函数的方法为：\" class=\"headerlink\" title=\"6.在类模板外部定义成员函数的方法为：\"></a>6.在类模板外部定义成员函数的方法为：</h2><pre><code>template&lt;模板形参列表&gt; 函数返回类型 类名&lt;模板形参名&gt;::函数名(参数列表){函数体}；\n</code></pre><blockquote>\n<p>比如有两个模板形参T1，T2的类A中含有一个void h()函数，则定义该函数的语法为：　</p>\n</blockquote>\n<pre><code>template&lt;class T1,class T2&gt; void A&lt;T1,T2&gt;::h(){}。\n</code></pre><blockquote>\n<p>注意：当在类外面定义类的成员时template后面的模板形参应与要定义的类的模板形参一致。</p>\n</blockquote>\n<h2 id=\"7-模板的实例化：类模板在引用实际模板类类型时实例化\"><a href=\"#7-模板的实例化：类模板在引用实际模板类类型时实例化\" class=\"headerlink\" title=\"7.模板的实例化：类模板在引用实际模板类类型时实例化\"></a>7.模板的实例化：类模板在引用实际模板类类型时实例化</h2><blockquote>\n<ol>\n<li>定义模板类对象时</li>\n<li>通过类指针或引用指向一个类模板实例时，只有当检查这个指针或引用指的那个对象时(访问数据成员或成员函数)，才会实例化</li>\n<li>当类模板被实例化时，类模板的成员函数并不自动被实例化。只有该函数被调用或取地址时，才被实例化。</li>\n<li>静态数据成员只有被使用时才实例化。</li>\n</ol>\n</blockquote>\n<h2 id=\"8-类模板和函数模板区别\"><a href=\"#8-类模板和函数模板区别\" class=\"headerlink\" title=\"8.类模板和函数模板区别\"></a>8.类模板和函数模板区别</h2><blockquote>\n<ol>\n<li>函数模板允许重载 ，而类模板不允许重载(类无重载概念，即不存在同名类模板)。</li>\n<li>类模板可以进行全特化和偏特化，而函数模板仅能够全特化 。</li>\n<li>类模板支持默认参数，函数模板不支持</li>\n</ol>\n</blockquote>\n"},{"title":"c++ 多态","comments":1,"date":"2017-03-05T08:34:59.000Z","update":"2017-03-05T08:34:59.000Z","_content":"## C和C++的区别：\r1. C是一个结构化语言，它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制）。C的优势在于编写的程序更接近于硬件，仅次于汇编语言，所以他相对其他编程语言高效的多，但同时程序员负责一切不安全，如内存泄露等。但正是由于这样的风险的存在，对程序员的紧密思维要求更高。\r2. C++是有C，面向对象，泛型编程，stl组成。用面向对象来编程首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。 所以C与C++的最大区别在于它们的用于解决问题的思想方法不一样。之所以说C++比C更先进，是因为“ 设计这个概念已经被融入到C++之中 ”。\n\n\t\r## 面向对象的三大特性：\n\r封装，继承，多态\n\r1. \t封装：将对象的属性和方法封装在对象内部，形成一个个独立的单元模块，对外通访问权限控制管理对象数据的交互。(访问权限：（private，protected,public) 保证封装性的关键)\r目的：增强代码的安全性和简化编程，让使用者不必了解类具体的实现细节，只要通过外部接口，以特定的权限来使用类的方法即可。\r2.\t继承：一个对象获得另一对象的特性的过程。是将一群类组织起来，定义了父子关系，实现了代码的重用，父类定义了所有子类的的共有借口和私有实现，同时子类都可以增加或覆盖继承来的东西，以实现独有的行为。\r3. \t多态：它是建立在了继承的基础上；简单来说，就是一个接口，多个方法.具体来说：它是指不同子类在继承父类后分别覆盖了父类的方法\r多态性使得同一属性或者行为在基类及其子类间有不同的语义；\r多态性丰富了对象的内容，增强了软件的灵活性和可重用性；\rC++的多态性有两种：编译时的多态（函数重载），运行时多态（虚函数）\r（联编（binding)或称为绑定:是指计算机程序自身彼此关联的过程\r联编工作在编译连接阶段完成的情况称为：静态联编\r联编在程序运行阶段完成的情况称为：动态联编。）\n\r##\tc++ 重载 覆盖 隐藏的区别和执行方式 :\n\r1. 成员函数被重载的特征:\r相同的范围（在同一个类中）；函数名字相同；参数不同； virtual 关键字可有可无。\r2. 覆盖是指派生类函数覆盖基类函数，特征是:\r不同的范围（分别位于派生类与基类）； 函数名字相同； 参数相同； 基类函数必须有virtual 关键字。 \r3. “隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下:\r如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。 （2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）\r4. 3种情况怎么执行：\n重载：看参数;\r隐藏：用什么就调用什么;\r覆盖：调用派生类;\n\r## 虚函数的工作原理：\n\r编译器处理虚函数的方法是.给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。而这个数组称为虚函数表，虚函数表中存储了为类对象进行声明的虚函数的地址。\n\r1. 单继承时\r\t-\t虚函数指针在对象的最前面的位置；\r\t-\t虚函数地址按照声明的顺序存放于虚表中；\r\t-\t父类虚函数地址在子类虚函数地址的前面；\r\t-\t子类如果覆盖父类的虚函数，则被放到虚表中原父类虚函数的位置\r\t-\t没有被覆盖的函数依旧在原位。\r2. \t多重继承的特殊地方：\r\t-\t每个父类都有自己的虚表时，子类的虚函数成员只被放到第一个父类中。\r\t-\t子类有多个虚表指针，位于类的最前面，分别指向不同的父类的虚表，（按继承的顺序）。\r\t-\t如果有覆盖情况，则替换所有被覆盖的父类虚函数地址。\r3. 父类访问子类中成员函数只能通过虚函数，覆盖的方法。否则无法访问。但我们可以通过函数指针强行访问虚表里的函数。本人就是通过此方法的出的以上结论。\r4. 虚函数特性：\r\t- 虚函数是动态联编的基础。\r\t- 是非静态的成员函数。\r\t-\t在类的声明中，在函数原型之前写virtual。\r\t-\tvirtual 只用来说明类声明中的原型，不能用在函数实现时。\r\t-\t具有继承性，基类中声明了虚函数，派生类中无论是否说明，同原型函数都自动为虚函数。\r\t-\t本质：不是重载声明而是覆盖。\r\t-\t调用方式：通过基类指针或引用，执行时会根据指针指向的对象的类，决定调用哪个函数。\r5.\t虚函数的限制\r\t- 只有类的成员函数才能说明为虚函数，因为虚函数仅适用于继承关系的 类对象，所以普通函数不能说明为虚函数。\r\t- 内联函数不能是虚函数，因为内联函数是在编译时决\t定其位置。\r\t- 构造函数不能是虚函数，因为构造时对象还是一片未\t定型的空间，就没有虚指针，虚表。。\r\t- \t析构函数可以是虚函数，而且通常声明为虚函数。\r##\t纯虚函数与抽象类\r1.\t带有纯虚函数的类称为抽象类:\n\n```\nclass  类名\r {\r     virtual 类型 函数名(参数表)=0;  //纯虚函\r \t ...\r};\n```\n\r2.\t作用：\r\t- 抽象类为抽象和设计的目的而建立，将有关的数据和行为组织在一个继承层次结构中，保证派生类具有要求的行为。\r\t- 对于暂时无法实现的函数，可以声明为纯虚函数，留给派生类去实现。主要作用是通过它为一个类族建立一个公共的接口，使它们能够更有效地发挥多态特性。\r3. \t注意：抽象类只能作为基类来使用;不能声明抽象类的对象;但可以声明一个指针\r\r\r\r","source":"_posts/c-的多态.md","raw":"---\ntitle: c++ 多态\ncomments: true\ntags:\n  - 多态\n  - C++\n  - 面向对象\ncategories:\n  - C++\ndate: 2017-03-05 16:34:59\nupdate: 2017-03-05 16:34:59\n---\n## C和C++的区别：\r1. C是一个结构化语言，它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制）。C的优势在于编写的程序更接近于硬件，仅次于汇编语言，所以他相对其他编程语言高效的多，但同时程序员负责一切不安全，如内存泄露等。但正是由于这样的风险的存在，对程序员的紧密思维要求更高。\r2. C++是有C，面向对象，泛型编程，stl组成。用面向对象来编程首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。 所以C与C++的最大区别在于它们的用于解决问题的思想方法不一样。之所以说C++比C更先进，是因为“ 设计这个概念已经被融入到C++之中 ”。\n\n\t\r## 面向对象的三大特性：\n\r封装，继承，多态\n\r1. \t封装：将对象的属性和方法封装在对象内部，形成一个个独立的单元模块，对外通访问权限控制管理对象数据的交互。(访问权限：（private，protected,public) 保证封装性的关键)\r目的：增强代码的安全性和简化编程，让使用者不必了解类具体的实现细节，只要通过外部接口，以特定的权限来使用类的方法即可。\r2.\t继承：一个对象获得另一对象的特性的过程。是将一群类组织起来，定义了父子关系，实现了代码的重用，父类定义了所有子类的的共有借口和私有实现，同时子类都可以增加或覆盖继承来的东西，以实现独有的行为。\r3. \t多态：它是建立在了继承的基础上；简单来说，就是一个接口，多个方法.具体来说：它是指不同子类在继承父类后分别覆盖了父类的方法\r多态性使得同一属性或者行为在基类及其子类间有不同的语义；\r多态性丰富了对象的内容，增强了软件的灵活性和可重用性；\rC++的多态性有两种：编译时的多态（函数重载），运行时多态（虚函数）\r（联编（binding)或称为绑定:是指计算机程序自身彼此关联的过程\r联编工作在编译连接阶段完成的情况称为：静态联编\r联编在程序运行阶段完成的情况称为：动态联编。）\n\r##\tc++ 重载 覆盖 隐藏的区别和执行方式 :\n\r1. 成员函数被重载的特征:\r相同的范围（在同一个类中）；函数名字相同；参数不同； virtual 关键字可有可无。\r2. 覆盖是指派生类函数覆盖基类函数，特征是:\r不同的范围（分别位于派生类与基类）； 函数名字相同； 参数相同； 基类函数必须有virtual 关键字。 \r3. “隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下:\r如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。 （2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）\r4. 3种情况怎么执行：\n重载：看参数;\r隐藏：用什么就调用什么;\r覆盖：调用派生类;\n\r## 虚函数的工作原理：\n\r编译器处理虚函数的方法是.给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。而这个数组称为虚函数表，虚函数表中存储了为类对象进行声明的虚函数的地址。\n\r1. 单继承时\r\t-\t虚函数指针在对象的最前面的位置；\r\t-\t虚函数地址按照声明的顺序存放于虚表中；\r\t-\t父类虚函数地址在子类虚函数地址的前面；\r\t-\t子类如果覆盖父类的虚函数，则被放到虚表中原父类虚函数的位置\r\t-\t没有被覆盖的函数依旧在原位。\r2. \t多重继承的特殊地方：\r\t-\t每个父类都有自己的虚表时，子类的虚函数成员只被放到第一个父类中。\r\t-\t子类有多个虚表指针，位于类的最前面，分别指向不同的父类的虚表，（按继承的顺序）。\r\t-\t如果有覆盖情况，则替换所有被覆盖的父类虚函数地址。\r3. 父类访问子类中成员函数只能通过虚函数，覆盖的方法。否则无法访问。但我们可以通过函数指针强行访问虚表里的函数。本人就是通过此方法的出的以上结论。\r4. 虚函数特性：\r\t- 虚函数是动态联编的基础。\r\t- 是非静态的成员函数。\r\t-\t在类的声明中，在函数原型之前写virtual。\r\t-\tvirtual 只用来说明类声明中的原型，不能用在函数实现时。\r\t-\t具有继承性，基类中声明了虚函数，派生类中无论是否说明，同原型函数都自动为虚函数。\r\t-\t本质：不是重载声明而是覆盖。\r\t-\t调用方式：通过基类指针或引用，执行时会根据指针指向的对象的类，决定调用哪个函数。\r5.\t虚函数的限制\r\t- 只有类的成员函数才能说明为虚函数，因为虚函数仅适用于继承关系的 类对象，所以普通函数不能说明为虚函数。\r\t- 内联函数不能是虚函数，因为内联函数是在编译时决\t定其位置。\r\t- 构造函数不能是虚函数，因为构造时对象还是一片未\t定型的空间，就没有虚指针，虚表。。\r\t- \t析构函数可以是虚函数，而且通常声明为虚函数。\r##\t纯虚函数与抽象类\r1.\t带有纯虚函数的类称为抽象类:\n\n```\nclass  类名\r {\r     virtual 类型 函数名(参数表)=0;  //纯虚函\r \t ...\r};\n```\n\r2.\t作用：\r\t- 抽象类为抽象和设计的目的而建立，将有关的数据和行为组织在一个继承层次结构中，保证派生类具有要求的行为。\r\t- 对于暂时无法实现的函数，可以声明为纯虚函数，留给派生类去实现。主要作用是通过它为一个类族建立一个公共的接口，使它们能够更有效地发挥多态特性。\r3. \t注意：抽象类只能作为基类来使用;不能声明抽象类的对象;但可以声明一个指针\r\r\r\r","slug":"c-的多态","published":1,"updated":"2017-09-02T10:11:51.000Z","layout":"post","photos":[],"link":"","_id":"cjd4d19zw000kryx482ovciyo","content":"<h2 id=\"C和C-的区别：\"><a href=\"#C和C-的区别：\" class=\"headerlink\" title=\"C和C++的区别：\"></a>C和C++的区别：</h2><ol>\n<li>C是一个结构化语言，它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制）。C的优势在于编写的程序更接近于硬件，仅次于汇编语言，所以他相对其他编程语言高效的多，但同时程序员负责一切不安全，如内存泄露等。但正是由于这样的风险的存在，对程序员的紧密思维要求更高。</li>\n<li>C++是有C，面向对象，泛型编程，stl组成。用面向对象来编程首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。 所以C与C++的最大区别在于它们的用于解决问题的思想方法不一样。之所以说C++比C更先进，是因为“ 设计这个概念已经被融入到C++之中 ”。</li>\n</ol>\n<h2 id=\"面向对象的三大特性：\"><a href=\"#面向对象的三大特性：\" class=\"headerlink\" title=\"面向对象的三大特性：\"></a>面向对象的三大特性：</h2><p>封装，继承，多态</p>\n<ol>\n<li>封装：将对象的属性和方法封装在对象内部，形成一个个独立的单元模块，对外通访问权限控制管理对象数据的交互。(访问权限：（private，protected,public) 保证封装性的关键)<br>目的：增强代码的安全性和简化编程，让使用者不必了解类具体的实现细节，只要通过外部接口，以特定的权限来使用类的方法即可。</li>\n<li>继承：一个对象获得另一对象的特性的过程。是将一群类组织起来，定义了父子关系，实现了代码的重用，父类定义了所有子类的的共有借口和私有实现，同时子类都可以增加或覆盖继承来的东西，以实现独有的行为。</li>\n<li>多态：它是建立在了继承的基础上；简单来说，就是一个接口，多个方法.具体来说：它是指不同子类在继承父类后分别覆盖了父类的方法<br>多态性使得同一属性或者行为在基类及其子类间有不同的语义；<br>多态性丰富了对象的内容，增强了软件的灵活性和可重用性；<br>C++的多态性有两种：编译时的多态（函数重载），运行时多态（虚函数）<br>（联编（binding)或称为绑定:是指计算机程序自身彼此关联的过程<br>联编工作在编译连接阶段完成的情况称为：静态联编<br>联编在程序运行阶段完成的情况称为：动态联编。）</li>\n</ol>\n<h2 id=\"c-重载-覆盖-隐藏的区别和执行方式\"><a href=\"#c-重载-覆盖-隐藏的区别和执行方式\" class=\"headerlink\" title=\"c++ 重载 覆盖 隐藏的区别和执行方式 :\"></a>c++ 重载 覆盖 隐藏的区别和执行方式 :</h2><ol>\n<li>成员函数被重载的特征:<br>相同的范围（在同一个类中）；函数名字相同；参数不同； virtual 关键字可有可无。</li>\n<li>覆盖是指派生类函数覆盖基类函数，特征是:<br>不同的范围（分别位于派生类与基类）； 函数名字相同； 参数相同； 基类函数必须有virtual 关键字。 </li>\n<li>“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下:<br>如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。 （2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）</li>\n<li>3种情况怎么执行：<br>重载：看参数;<br>隐藏：用什么就调用什么;<br>覆盖：调用派生类;</li>\n</ol>\n<h2 id=\"虚函数的工作原理：\"><a href=\"#虚函数的工作原理：\" class=\"headerlink\" title=\"虚函数的工作原理：\"></a>虚函数的工作原理：</h2><p>编译器处理虚函数的方法是.给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。而这个数组称为虚函数表，虚函数表中存储了为类对象进行声明的虚函数的地址。</p>\n<ol>\n<li>单继承时<ul>\n<li>虚函数指针在对象的最前面的位置；</li>\n<li>虚函数地址按照声明的顺序存放于虚表中；</li>\n<li>父类虚函数地址在子类虚函数地址的前面；</li>\n<li>子类如果覆盖父类的虚函数，则被放到虚表中原父类虚函数的位置</li>\n<li>没有被覆盖的函数依旧在原位。</li>\n</ul>\n</li>\n<li>多重继承的特殊地方：<ul>\n<li>每个父类都有自己的虚表时，子类的虚函数成员只被放到第一个父类中。</li>\n<li>子类有多个虚表指针，位于类的最前面，分别指向不同的父类的虚表，（按继承的顺序）。</li>\n<li>如果有覆盖情况，则替换所有被覆盖的父类虚函数地址。</li>\n</ul>\n</li>\n<li>父类访问子类中成员函数只能通过虚函数，覆盖的方法。否则无法访问。但我们可以通过函数指针强行访问虚表里的函数。本人就是通过此方法的出的以上结论。</li>\n<li>虚函数特性：<ul>\n<li>虚函数是动态联编的基础。</li>\n<li>是非静态的成员函数。</li>\n<li>在类的声明中，在函数原型之前写virtual。</li>\n<li>virtual 只用来说明类声明中的原型，不能用在函数实现时。</li>\n<li>具有继承性，基类中声明了虚函数，派生类中无论是否说明，同原型函数都自动为虚函数。</li>\n<li>本质：不是重载声明而是覆盖。</li>\n<li>调用方式：通过基类指针或引用，执行时会根据指针指向的对象的类，决定调用哪个函数。</li>\n</ul>\n</li>\n<li>虚函数的限制<ul>\n<li>只有类的成员函数才能说明为虚函数，因为虚函数仅适用于继承关系的 类对象，所以普通函数不能说明为虚函数。</li>\n<li>内联函数不能是虚函数，因为内联函数是在编译时决    定其位置。</li>\n<li>构造函数不能是虚函数，因为构造时对象还是一片未    定型的空间，就没有虚指针，虚表。。</li>\n<li>析构函数可以是虚函数，而且通常声明为虚函数。<h2 id=\"纯虚函数与抽象类\"><a href=\"#纯虚函数与抽象类\" class=\"headerlink\" title=\"纯虚函数与抽象类\"></a>纯虚函数与抽象类</h2></li>\n</ul>\n</li>\n<li>带有纯虚函数的类称为抽象类:</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">class  类名\r &#123;\r     virtual 类型 函数名(参数表)=0;  //纯虚函\r \t ...\r&#125;;</div></pre></td></tr></table></figure>\n<ol>\n<li>作用：<ul>\n<li>抽象类为抽象和设计的目的而建立，将有关的数据和行为组织在一个继承层次结构中，保证派生类具有要求的行为。</li>\n<li>对于暂时无法实现的函数，可以声明为纯虚函数，留给派生类去实现。主要作用是通过它为一个类族建立一个公共的接口，使它们能够更有效地发挥多态特性。</li>\n</ul>\n</li>\n<li>注意：抽象类只能作为基类来使用;不能声明抽象类的对象;但可以声明一个指针</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"C和C-的区别：\"><a href=\"#C和C-的区别：\" class=\"headerlink\" title=\"C和C++的区别：\"></a>C和C++的区别：</h2><ol>\n<li>C是一个结构化语言，它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制）。C的优势在于编写的程序更接近于硬件，仅次于汇编语言，所以他相对其他编程语言高效的多，但同时程序员负责一切不安全，如内存泄露等。但正是由于这样的风险的存在，对程序员的紧密思维要求更高。</li>\n<li>C++是有C，面向对象，泛型编程，stl组成。用面向对象来编程首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。 所以C与C++的最大区别在于它们的用于解决问题的思想方法不一样。之所以说C++比C更先进，是因为“ 设计这个概念已经被融入到C++之中 ”。</li>\n</ol>\n<h2 id=\"面向对象的三大特性：\"><a href=\"#面向对象的三大特性：\" class=\"headerlink\" title=\"面向对象的三大特性：\"></a>面向对象的三大特性：</h2><p>封装，继承，多态</p>\n<ol>\n<li>封装：将对象的属性和方法封装在对象内部，形成一个个独立的单元模块，对外通访问权限控制管理对象数据的交互。(访问权限：（private，protected,public) 保证封装性的关键)<br>目的：增强代码的安全性和简化编程，让使用者不必了解类具体的实现细节，只要通过外部接口，以特定的权限来使用类的方法即可。</li>\n<li>继承：一个对象获得另一对象的特性的过程。是将一群类组织起来，定义了父子关系，实现了代码的重用，父类定义了所有子类的的共有借口和私有实现，同时子类都可以增加或覆盖继承来的东西，以实现独有的行为。</li>\n<li>多态：它是建立在了继承的基础上；简单来说，就是一个接口，多个方法.具体来说：它是指不同子类在继承父类后分别覆盖了父类的方法<br>多态性使得同一属性或者行为在基类及其子类间有不同的语义；<br>多态性丰富了对象的内容，增强了软件的灵活性和可重用性；<br>C++的多态性有两种：编译时的多态（函数重载），运行时多态（虚函数）<br>（联编（binding)或称为绑定:是指计算机程序自身彼此关联的过程<br>联编工作在编译连接阶段完成的情况称为：静态联编<br>联编在程序运行阶段完成的情况称为：动态联编。）</li>\n</ol>\n<h2 id=\"c-重载-覆盖-隐藏的区别和执行方式\"><a href=\"#c-重载-覆盖-隐藏的区别和执行方式\" class=\"headerlink\" title=\"c++ 重载 覆盖 隐藏的区别和执行方式 :\"></a>c++ 重载 覆盖 隐藏的区别和执行方式 :</h2><ol>\n<li>成员函数被重载的特征:<br>相同的范围（在同一个类中）；函数名字相同；参数不同； virtual 关键字可有可无。</li>\n<li>覆盖是指派生类函数覆盖基类函数，特征是:<br>不同的范围（分别位于派生类与基类）； 函数名字相同； 参数相同； 基类函数必须有virtual 关键字。 </li>\n<li>“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下:<br>如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。 （2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）</li>\n<li>3种情况怎么执行：<br>重载：看参数;<br>隐藏：用什么就调用什么;<br>覆盖：调用派生类;</li>\n</ol>\n<h2 id=\"虚函数的工作原理：\"><a href=\"#虚函数的工作原理：\" class=\"headerlink\" title=\"虚函数的工作原理：\"></a>虚函数的工作原理：</h2><p>编译器处理虚函数的方法是.给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。而这个数组称为虚函数表，虚函数表中存储了为类对象进行声明的虚函数的地址。</p>\n<ol>\n<li>单继承时<ul>\n<li>虚函数指针在对象的最前面的位置；</li>\n<li>虚函数地址按照声明的顺序存放于虚表中；</li>\n<li>父类虚函数地址在子类虚函数地址的前面；</li>\n<li>子类如果覆盖父类的虚函数，则被放到虚表中原父类虚函数的位置</li>\n<li>没有被覆盖的函数依旧在原位。</li>\n</ul>\n</li>\n<li>多重继承的特殊地方：<ul>\n<li>每个父类都有自己的虚表时，子类的虚函数成员只被放到第一个父类中。</li>\n<li>子类有多个虚表指针，位于类的最前面，分别指向不同的父类的虚表，（按继承的顺序）。</li>\n<li>如果有覆盖情况，则替换所有被覆盖的父类虚函数地址。</li>\n</ul>\n</li>\n<li>父类访问子类中成员函数只能通过虚函数，覆盖的方法。否则无法访问。但我们可以通过函数指针强行访问虚表里的函数。本人就是通过此方法的出的以上结论。</li>\n<li>虚函数特性：<ul>\n<li>虚函数是动态联编的基础。</li>\n<li>是非静态的成员函数。</li>\n<li>在类的声明中，在函数原型之前写virtual。</li>\n<li>virtual 只用来说明类声明中的原型，不能用在函数实现时。</li>\n<li>具有继承性，基类中声明了虚函数，派生类中无论是否说明，同原型函数都自动为虚函数。</li>\n<li>本质：不是重载声明而是覆盖。</li>\n<li>调用方式：通过基类指针或引用，执行时会根据指针指向的对象的类，决定调用哪个函数。</li>\n</ul>\n</li>\n<li>虚函数的限制<ul>\n<li>只有类的成员函数才能说明为虚函数，因为虚函数仅适用于继承关系的 类对象，所以普通函数不能说明为虚函数。</li>\n<li>内联函数不能是虚函数，因为内联函数是在编译时决    定其位置。</li>\n<li>构造函数不能是虚函数，因为构造时对象还是一片未    定型的空间，就没有虚指针，虚表。。</li>\n<li>析构函数可以是虚函数，而且通常声明为虚函数。<h2 id=\"纯虚函数与抽象类\"><a href=\"#纯虚函数与抽象类\" class=\"headerlink\" title=\"纯虚函数与抽象类\"></a>纯虚函数与抽象类</h2></li>\n</ul>\n</li>\n<li>带有纯虚函数的类称为抽象类:</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">class  类名\r &#123;\r     virtual 类型 函数名(参数表)=0;  //纯虚函\r \t ...\r&#125;;</div></pre></td></tr></table></figure>\n<ol>\n<li>作用：<ul>\n<li>抽象类为抽象和设计的目的而建立，将有关的数据和行为组织在一个继承层次结构中，保证派生类具有要求的行为。</li>\n<li>对于暂时无法实现的函数，可以声明为纯虚函数，留给派生类去实现。主要作用是通过它为一个类族建立一个公共的接口，使它们能够更有效地发挥多态特性。</li>\n</ul>\n</li>\n<li>注意：抽象类只能作为基类来使用;不能声明抽象类的对象;但可以声明一个指针</li>\n</ol>\n"},{"title":"c++ 继承","comments":1,"date":"2017-03-05T08:59:34.000Z","update":"2017-03-05T08:59:34.000Z","_content":"\r# 继承与派生：\r- 保持已有类的特性而构造新类的过程称为继承。\r- 在已有类的基础上新增自己的特性而产生新类的过程称为派生。\r- 继承的目的：实现代码重用。\r- 派生的目的：当新的问题出现，原有程序无法解决（或不能完全解决）时，需要对原有程序进行改造。\n\r#\t三种继承方式\r> 公有继承；私有继承；保护继承   \n> 不同继承方式的影响主要体现在:\n>\n1. 派生类成员对基类成员的访问控制。\r2. 派生类对象对基类成员的访问控制。\n\r## 1.公有继承：\r- 继承方式：基类的public和protected成员的访问属性在派生类中保持不变，但基类的private成员不可访问。\r- 类内： 派生类中的成员函数可以直接访问基类中的public和protected成员，但不能访问基类的private成员。\r- 类外：通过派生类的对象只能访问基类的public成员。\n\r## 2.私有继承：\r- 继承方式：基类的public和protected成员都以private身份出现在派生类中，但基类的private成员不可访问。\r- 类内：派生类中的成员函数可以直接访问基类中的public和protected成员，但不能访问基类的private成员。\r- 类外：通过派生类的对象不能访问基类中的任何成员。\n\r## 3.保护继承：\r- 继承方式：基类的public和protected成员都以protected身份出现在派生类中，但基类的private成员不可访问。\r- 类内：派生类中的成员函数可以直接访问基类中的public和protected成员，但不能访问基类的private成员。\r- 类外：通过派生类的对象不能访问基类中的任何成员\n\n## 4.protected 成员的特点与作用：\r-\t对建立其所在类对象的模块来说（水平访问时），它与 private 成员的性质相同。\r-\t对于其派生类来说（垂直访问时），它与 public 成员的性质相同。\r- .\t既实现了数据隐藏，又方便继承，实现代码重用；\n\r# 基类与派生类的对应关系\r- 单继承:\t派生类只从一个基类派生。\r- 多继承：派生类从多个基类派生。\r- 多重派生: 由一个基类派生出多个不同的派生类。\r- 多层派生: 派生类又作为基类，继续派生新的类。\r\r# 继承时的构造函数\r1. \t基类的构造函数不被继承，需要在派生类中自行声明。\r2.\t声明构造函数时，只需要对本类中新增成员进行初始化，对继承来的基类成员的初始化由基类完成。\n\r# 多重继承构造函数的调用次序\r1. 调用基类构造函数，调用顺序按照它们被继承时声明的顺序（从左向右）。\r2. \t调用成员对象的构造函数，调用顺序按照它们在类中声明的顺序。\r3. \t派生类的构造函数体中的内容。\n\r#\t 多重继承时的析构函数\r1.\t析构函数也不被继承，派生类自行声明。\r2. \t声明方法与一般（无继承关系时）类的析构函数相同。\r3. \t不需要显式地调用基类的析构函数，系统会自动隐式调用。\r4.\t析构函数的调用次序与构造函数相反。\n\r#\t 二义性问题\n\r- 在多继承时，基类与派生类之间，或基类之间出现同名成员时，将出现访问时的二义性（不确定性）——采用虚函数或支配（同名覆盖）原则来解决。\r- 当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类中的成员时，将产生二义性——采用虚基类来解决。（菱形继承）\n\r# 虚基类\r声明:\t以virtual修饰说明基类\t\n\n\t例：class B1:virtual public B\n\t\r作用：\n\r1. \t主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题.\r2. 为最远的派生类提供唯一的基类成员，而不重复产生多次拷贝\r\r>**注意**：在第一级继承时就要将共同基类设计为虚基类。\n\r# 赋值兼容原则\r一个公有派生类的对象在使用上可以被当作基类的对象，反之则禁止。具体表现在：\r\r1. 派生类的对象可以被赋值给基类对象。\r2. 派生类的对象可以初始化基类的引用。\r3. 指向基类的指针也可以指向派生类。\r","source":"_posts/c-继承.md","raw":"---\ntitle: c++ 继承\ncomments: true\ntags:\n  - C++\n  - 继承\ncategories:\n  - C++\ndate: 2017-03-05 16:59:34\nupdate: 2017-03-05 16:59:34\n\n---\n\r# 继承与派生：\r- 保持已有类的特性而构造新类的过程称为继承。\r- 在已有类的基础上新增自己的特性而产生新类的过程称为派生。\r- 继承的目的：实现代码重用。\r- 派生的目的：当新的问题出现，原有程序无法解决（或不能完全解决）时，需要对原有程序进行改造。\n\r#\t三种继承方式\r> 公有继承；私有继承；保护继承   \n> 不同继承方式的影响主要体现在:\n>\n1. 派生类成员对基类成员的访问控制。\r2. 派生类对象对基类成员的访问控制。\n\r## 1.公有继承：\r- 继承方式：基类的public和protected成员的访问属性在派生类中保持不变，但基类的private成员不可访问。\r- 类内： 派生类中的成员函数可以直接访问基类中的public和protected成员，但不能访问基类的private成员。\r- 类外：通过派生类的对象只能访问基类的public成员。\n\r## 2.私有继承：\r- 继承方式：基类的public和protected成员都以private身份出现在派生类中，但基类的private成员不可访问。\r- 类内：派生类中的成员函数可以直接访问基类中的public和protected成员，但不能访问基类的private成员。\r- 类外：通过派生类的对象不能访问基类中的任何成员。\n\r## 3.保护继承：\r- 继承方式：基类的public和protected成员都以protected身份出现在派生类中，但基类的private成员不可访问。\r- 类内：派生类中的成员函数可以直接访问基类中的public和protected成员，但不能访问基类的private成员。\r- 类外：通过派生类的对象不能访问基类中的任何成员\n\n## 4.protected 成员的特点与作用：\r-\t对建立其所在类对象的模块来说（水平访问时），它与 private 成员的性质相同。\r-\t对于其派生类来说（垂直访问时），它与 public 成员的性质相同。\r- .\t既实现了数据隐藏，又方便继承，实现代码重用；\n\r# 基类与派生类的对应关系\r- 单继承:\t派生类只从一个基类派生。\r- 多继承：派生类从多个基类派生。\r- 多重派生: 由一个基类派生出多个不同的派生类。\r- 多层派生: 派生类又作为基类，继续派生新的类。\r\r# 继承时的构造函数\r1. \t基类的构造函数不被继承，需要在派生类中自行声明。\r2.\t声明构造函数时，只需要对本类中新增成员进行初始化，对继承来的基类成员的初始化由基类完成。\n\r# 多重继承构造函数的调用次序\r1. 调用基类构造函数，调用顺序按照它们被继承时声明的顺序（从左向右）。\r2. \t调用成员对象的构造函数，调用顺序按照它们在类中声明的顺序。\r3. \t派生类的构造函数体中的内容。\n\r#\t 多重继承时的析构函数\r1.\t析构函数也不被继承，派生类自行声明。\r2. \t声明方法与一般（无继承关系时）类的析构函数相同。\r3. \t不需要显式地调用基类的析构函数，系统会自动隐式调用。\r4.\t析构函数的调用次序与构造函数相反。\n\r#\t 二义性问题\n\r- 在多继承时，基类与派生类之间，或基类之间出现同名成员时，将出现访问时的二义性（不确定性）——采用虚函数或支配（同名覆盖）原则来解决。\r- 当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类中的成员时，将产生二义性——采用虚基类来解决。（菱形继承）\n\r# 虚基类\r声明:\t以virtual修饰说明基类\t\n\n\t例：class B1:virtual public B\n\t\r作用：\n\r1. \t主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题.\r2. 为最远的派生类提供唯一的基类成员，而不重复产生多次拷贝\r\r>**注意**：在第一级继承时就要将共同基类设计为虚基类。\n\r# 赋值兼容原则\r一个公有派生类的对象在使用上可以被当作基类的对象，反之则禁止。具体表现在：\r\r1. 派生类的对象可以被赋值给基类对象。\r2. 派生类的对象可以初始化基类的引用。\r3. 指向基类的指针也可以指向派生类。\r","slug":"c-继承","published":1,"updated":"2017-09-02T10:12:01.000Z","layout":"post","photos":[],"link":"","_id":"cjd4d19zx000oryx4zjs20et5","content":"<h1 id=\"继承与派生：\"><a href=\"#继承与派生：\" class=\"headerlink\" title=\"继承与派生：\"></a>继承与派生：</h1><ul>\n<li>保持已有类的特性而构造新类的过程称为继承。</li>\n<li>在已有类的基础上新增自己的特性而产生新类的过程称为派生。</li>\n<li>继承的目的：实现代码重用。</li>\n<li>派生的目的：当新的问题出现，原有程序无法解决（或不能完全解决）时，需要对原有程序进行改造。</li>\n</ul>\n<h1 id=\"三种继承方式\"><a href=\"#三种继承方式\" class=\"headerlink\" title=\"三种继承方式\"></a>三种继承方式</h1><blockquote>\n<p>公有继承；私有继承；保护继承<br>不同继承方式的影响主要体现在:</p>\n<ol>\n<li>派生类成员对基类成员的访问控制。</li>\n<li>派生类对象对基类成员的访问控制。</li>\n</ol>\n</blockquote>\n<h2 id=\"1-公有继承：\"><a href=\"#1-公有继承：\" class=\"headerlink\" title=\"1.公有继承：\"></a>1.公有继承：</h2><ul>\n<li>继承方式：基类的public和protected成员的访问属性在派生类中保持不变，但基类的private成员不可访问。</li>\n<li>类内： 派生类中的成员函数可以直接访问基类中的public和protected成员，但不能访问基类的private成员。</li>\n<li>类外：通过派生类的对象只能访问基类的public成员。</li>\n</ul>\n<h2 id=\"2-私有继承：\"><a href=\"#2-私有继承：\" class=\"headerlink\" title=\"2.私有继承：\"></a>2.私有继承：</h2><ul>\n<li>继承方式：基类的public和protected成员都以private身份出现在派生类中，但基类的private成员不可访问。</li>\n<li>类内：派生类中的成员函数可以直接访问基类中的public和protected成员，但不能访问基类的private成员。</li>\n<li>类外：通过派生类的对象不能访问基类中的任何成员。</li>\n</ul>\n<h2 id=\"3-保护继承：\"><a href=\"#3-保护继承：\" class=\"headerlink\" title=\"3.保护继承：\"></a>3.保护继承：</h2><ul>\n<li>继承方式：基类的public和protected成员都以protected身份出现在派生类中，但基类的private成员不可访问。</li>\n<li>类内：派生类中的成员函数可以直接访问基类中的public和protected成员，但不能访问基类的private成员。</li>\n<li>类外：通过派生类的对象不能访问基类中的任何成员</li>\n</ul>\n<h2 id=\"4-protected-成员的特点与作用：\"><a href=\"#4-protected-成员的特点与作用：\" class=\"headerlink\" title=\"4.protected 成员的特点与作用：\"></a>4.protected 成员的特点与作用：</h2><ul>\n<li>对建立其所在类对象的模块来说（水平访问时），它与 private 成员的性质相同。</li>\n<li>对于其派生类来说（垂直访问时），它与 public 成员的性质相同。</li>\n<li>.    既实现了数据隐藏，又方便继承，实现代码重用；</li>\n</ul>\n<h1 id=\"基类与派生类的对应关系\"><a href=\"#基类与派生类的对应关系\" class=\"headerlink\" title=\"基类与派生类的对应关系\"></a>基类与派生类的对应关系</h1><ul>\n<li>单继承:    派生类只从一个基类派生。</li>\n<li>多继承：派生类从多个基类派生。</li>\n<li>多重派生: 由一个基类派生出多个不同的派生类。</li>\n<li>多层派生: 派生类又作为基类，继续派生新的类。</li>\n</ul>\n<h1 id=\"继承时的构造函数\"><a href=\"#继承时的构造函数\" class=\"headerlink\" title=\"继承时的构造函数\"></a>继承时的构造函数</h1><ol>\n<li>基类的构造函数不被继承，需要在派生类中自行声明。</li>\n<li>声明构造函数时，只需要对本类中新增成员进行初始化，对继承来的基类成员的初始化由基类完成。</li>\n</ol>\n<h1 id=\"多重继承构造函数的调用次序\"><a href=\"#多重继承构造函数的调用次序\" class=\"headerlink\" title=\"多重继承构造函数的调用次序\"></a>多重继承构造函数的调用次序</h1><ol>\n<li>调用基类构造函数，调用顺序按照它们被继承时声明的顺序（从左向右）。</li>\n<li>调用成员对象的构造函数，调用顺序按照它们在类中声明的顺序。</li>\n<li>派生类的构造函数体中的内容。</li>\n</ol>\n<h1 id=\"多重继承时的析构函数\"><a href=\"#多重继承时的析构函数\" class=\"headerlink\" title=\"多重继承时的析构函数\"></a>多重继承时的析构函数</h1><ol>\n<li>析构函数也不被继承，派生类自行声明。</li>\n<li>声明方法与一般（无继承关系时）类的析构函数相同。</li>\n<li>不需要显式地调用基类的析构函数，系统会自动隐式调用。</li>\n<li>析构函数的调用次序与构造函数相反。</li>\n</ol>\n<h1 id=\"二义性问题\"><a href=\"#二义性问题\" class=\"headerlink\" title=\"二义性问题\"></a>二义性问题</h1><ul>\n<li>在多继承时，基类与派生类之间，或基类之间出现同名成员时，将出现访问时的二义性（不确定性）——采用虚函数或支配（同名覆盖）原则来解决。</li>\n<li>当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类中的成员时，将产生二义性——采用虚基类来解决。（菱形继承）</li>\n</ul>\n<h1 id=\"虚基类\"><a href=\"#虚基类\" class=\"headerlink\" title=\"虚基类\"></a>虚基类</h1><p>声明:    以virtual修饰说明基类    </p>\n<pre><code>例：class B1:virtual public B\n</code></pre><p>作用：</p>\n<ol>\n<li>主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题.</li>\n<li>为最远的派生类提供唯一的基类成员，而不重复产生多次拷贝</li>\n</ol>\n<blockquote>\n<p><strong>注意</strong>：在第一级继承时就要将共同基类设计为虚基类。</p>\n</blockquote>\n<h1 id=\"赋值兼容原则\"><a href=\"#赋值兼容原则\" class=\"headerlink\" title=\"赋值兼容原则\"></a>赋值兼容原则</h1><p>一个公有派生类的对象在使用上可以被当作基类的对象，反之则禁止。具体表现在：</p>\n<ol>\n<li>派生类的对象可以被赋值给基类对象。</li>\n<li>派生类的对象可以初始化基类的引用。</li>\n<li>指向基类的指针也可以指向派生类。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"继承与派生：\"><a href=\"#继承与派生：\" class=\"headerlink\" title=\"继承与派生：\"></a>继承与派生：</h1><ul>\n<li>保持已有类的特性而构造新类的过程称为继承。</li>\n<li>在已有类的基础上新增自己的特性而产生新类的过程称为派生。</li>\n<li>继承的目的：实现代码重用。</li>\n<li>派生的目的：当新的问题出现，原有程序无法解决（或不能完全解决）时，需要对原有程序进行改造。</li>\n</ul>\n<h1 id=\"三种继承方式\"><a href=\"#三种继承方式\" class=\"headerlink\" title=\"三种继承方式\"></a>三种继承方式</h1><blockquote>\n<p>公有继承；私有继承；保护继承<br>不同继承方式的影响主要体现在:</p>\n<ol>\n<li>派生类成员对基类成员的访问控制。</li>\n<li>派生类对象对基类成员的访问控制。</li>\n</ol>\n</blockquote>\n<h2 id=\"1-公有继承：\"><a href=\"#1-公有继承：\" class=\"headerlink\" title=\"1.公有继承：\"></a>1.公有继承：</h2><ul>\n<li>继承方式：基类的public和protected成员的访问属性在派生类中保持不变，但基类的private成员不可访问。</li>\n<li>类内： 派生类中的成员函数可以直接访问基类中的public和protected成员，但不能访问基类的private成员。</li>\n<li>类外：通过派生类的对象只能访问基类的public成员。</li>\n</ul>\n<h2 id=\"2-私有继承：\"><a href=\"#2-私有继承：\" class=\"headerlink\" title=\"2.私有继承：\"></a>2.私有继承：</h2><ul>\n<li>继承方式：基类的public和protected成员都以private身份出现在派生类中，但基类的private成员不可访问。</li>\n<li>类内：派生类中的成员函数可以直接访问基类中的public和protected成员，但不能访问基类的private成员。</li>\n<li>类外：通过派生类的对象不能访问基类中的任何成员。</li>\n</ul>\n<h2 id=\"3-保护继承：\"><a href=\"#3-保护继承：\" class=\"headerlink\" title=\"3.保护继承：\"></a>3.保护继承：</h2><ul>\n<li>继承方式：基类的public和protected成员都以protected身份出现在派生类中，但基类的private成员不可访问。</li>\n<li>类内：派生类中的成员函数可以直接访问基类中的public和protected成员，但不能访问基类的private成员。</li>\n<li>类外：通过派生类的对象不能访问基类中的任何成员</li>\n</ul>\n<h2 id=\"4-protected-成员的特点与作用：\"><a href=\"#4-protected-成员的特点与作用：\" class=\"headerlink\" title=\"4.protected 成员的特点与作用：\"></a>4.protected 成员的特点与作用：</h2><ul>\n<li>对建立其所在类对象的模块来说（水平访问时），它与 private 成员的性质相同。</li>\n<li>对于其派生类来说（垂直访问时），它与 public 成员的性质相同。</li>\n<li>.    既实现了数据隐藏，又方便继承，实现代码重用；</li>\n</ul>\n<h1 id=\"基类与派生类的对应关系\"><a href=\"#基类与派生类的对应关系\" class=\"headerlink\" title=\"基类与派生类的对应关系\"></a>基类与派生类的对应关系</h1><ul>\n<li>单继承:    派生类只从一个基类派生。</li>\n<li>多继承：派生类从多个基类派生。</li>\n<li>多重派生: 由一个基类派生出多个不同的派生类。</li>\n<li>多层派生: 派生类又作为基类，继续派生新的类。</li>\n</ul>\n<h1 id=\"继承时的构造函数\"><a href=\"#继承时的构造函数\" class=\"headerlink\" title=\"继承时的构造函数\"></a>继承时的构造函数</h1><ol>\n<li>基类的构造函数不被继承，需要在派生类中自行声明。</li>\n<li>声明构造函数时，只需要对本类中新增成员进行初始化，对继承来的基类成员的初始化由基类完成。</li>\n</ol>\n<h1 id=\"多重继承构造函数的调用次序\"><a href=\"#多重继承构造函数的调用次序\" class=\"headerlink\" title=\"多重继承构造函数的调用次序\"></a>多重继承构造函数的调用次序</h1><ol>\n<li>调用基类构造函数，调用顺序按照它们被继承时声明的顺序（从左向右）。</li>\n<li>调用成员对象的构造函数，调用顺序按照它们在类中声明的顺序。</li>\n<li>派生类的构造函数体中的内容。</li>\n</ol>\n<h1 id=\"多重继承时的析构函数\"><a href=\"#多重继承时的析构函数\" class=\"headerlink\" title=\"多重继承时的析构函数\"></a>多重继承时的析构函数</h1><ol>\n<li>析构函数也不被继承，派生类自行声明。</li>\n<li>声明方法与一般（无继承关系时）类的析构函数相同。</li>\n<li>不需要显式地调用基类的析构函数，系统会自动隐式调用。</li>\n<li>析构函数的调用次序与构造函数相反。</li>\n</ol>\n<h1 id=\"二义性问题\"><a href=\"#二义性问题\" class=\"headerlink\" title=\"二义性问题\"></a>二义性问题</h1><ul>\n<li>在多继承时，基类与派生类之间，或基类之间出现同名成员时，将出现访问时的二义性（不确定性）——采用虚函数或支配（同名覆盖）原则来解决。</li>\n<li>当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类中的成员时，将产生二义性——采用虚基类来解决。（菱形继承）</li>\n</ul>\n<h1 id=\"虚基类\"><a href=\"#虚基类\" class=\"headerlink\" title=\"虚基类\"></a>虚基类</h1><p>声明:    以virtual修饰说明基类    </p>\n<pre><code>例：class B1:virtual public B\n</code></pre><p>作用：</p>\n<ol>\n<li>主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题.</li>\n<li>为最远的派生类提供唯一的基类成员，而不重复产生多次拷贝</li>\n</ol>\n<blockquote>\n<p><strong>注意</strong>：在第一级继承时就要将共同基类设计为虚基类。</p>\n</blockquote>\n<h1 id=\"赋值兼容原则\"><a href=\"#赋值兼容原则\" class=\"headerlink\" title=\"赋值兼容原则\"></a>赋值兼容原则</h1><p>一个公有派生类的对象在使用上可以被当作基类的对象，反之则禁止。具体表现在：</p>\n<ol>\n<li>派生类的对象可以被赋值给基类对象。</li>\n<li>派生类的对象可以初始化基类的引用。</li>\n<li>指向基类的指针也可以指向派生类。</li>\n</ol>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2017-02-10T11:43:33.000Z","updated":"2017-02-10T11:43:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd4d19zy000qryx400ldj11r","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n"},{"title":"c++ 类的四大函数","comments":1,"date":"2017-03-05T09:33:19.000Z","update":"2017-03-05T09:33:19.000Z","_content":"\n# 类与对象\r1.\t类是用户自定义的一种数据类型，定义类时描述它可以提供的信息及能够执行的操作；即类是一种具有属性和行为的自定义的数据类型；\r2.\t对象就是封装了数据结构，及施加这些数据结构上的操作的封装体；\n\r#\t类与对象的关系：\r类之于对象如同类型之于变量，因此类只是描述了数据格式和方法，而对象则是根据规范创建的实体；换句话说类就像图纸，而对象则是根据图纸盖起的大楼。\n\r#\t类与结构体的区别\n\r唯一的区别在于struct的默认访问权限是public,而类是private;\n\r#\tC++中的类所占内存分析：\n\r1. 类所占内存的大小是由成员变量（静态变量除外）决定的，成员函数（这是笼统的说，后面会细说）是不计算在内的。成员函数还是以一般的函数一样的存在。a.fun()是通过fun(a.this)来调用的。\r2. 所谓成员函数只是在名义上是类里的。其实成员函数的大小不在类的对象里面，同一个类的多个对象共享函数代码。而我们访问类的成员函数是通过类里面的一个指针实现，而这个指针指向的是一个table，\r3. table里面记录的各个成员函数的地址（当然不同的编译可能略有不同的实现）。所以我们访问成员函数是间接获得地址的。所以这样也就增加了一定的时间开销，这也就是为什么我们提倡把一些简短的，调用频率高的函数声明为inline形式（内联函数）。\r\r总结：空的类是会占用内存空间的，而且大小是1，原因是C++要求每个实例在内存中都有独一无二的地址。\n\r1. 类内部的成员变量：\r    普通的变量：是要占用内存的，但是要注意对齐原则（这点和struct类型很相似）。\r    static修饰的静态变量：不占用内容，原因是编译器将其放在全局变量区。\r2. 类内部的成员函数：\r    普通函数：不占用内存。\r    虚函数：要占用4个字节，用来指定虚函数的虚拟函数表的入口地址。所以一个类的虚函数所占用的地址是不变的，和虚函数的个数是没有关系的。\r\r\r#\tC++类中的四大函数：构造函数、拷贝构造函数、析构函数和赋值函数:\n\r1.\t四个函数一般系统都会默认。但是往往系统默认的并不是我们所期望的，为此我们有必要自己编写符合要求的函数，参看String.cpp;\r2.\t把对象的初始化工作放在构造函数中，当对象被创建时，构造函数被自动执行。\r3.\t把清除工作放在析构函数中。当对象消亡时，析构函数被自动执行，把一切内存垃圾清理，可见他的重要。如果没有析构函数或析构函数不正确就会发生内存泄露等问题，后果非常危险\r4.\t每个类只有一个析构函数和一个赋值函数，但可以有多个构造函数（包含一个拷贝构造函数，其它的称为普通构造函数）。\r5.\t构造函数和赋值函数有着很大的区别，构造函数是在对象创建时调用的；而赋值函数使对象已经创建好了存在之后再赋值时调用的。有时候我们懒得写赋值函数和拷贝构造函数，又不允许别人使用编译器生成的缺省函数，那么我们可以只需将拷贝构造函数和赋值函数声明为私有函数，函数体为空即可；\n\r#\t使用对象前正确初始化\n\r1.\t并不是所有的编译器都对象对象的内置类型成员会被自动初始化为0。永远在使用对象之前先将它初始化。确保每一个构造函数都将对象的每一个成员初始化。\r2.\t别把赋值错当成初始化。C++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前（对于内置类型对象可能不确定），这点对于非内置类型对象来说尤其关键。如果你没有在成员初始化列表（member initialization list）为其初始化，它们将调用自己的默认构造函数，然后才进入构造函数内部（很可能你会在这里给他们赋值）。在成员初始化列表中的初始化只是调用了拷贝构造函数一次，而在构造函数内部再为其赋值则在调用默认构造函数后又调用了一次拷贝构造函数。因此初始化列表将更为高效\r\r所以，请用成员初始化列表进行初始化，虽然效率提高只针对于非内置类型成员，但是规定总是在初值列中列出所有成员变量，这样就省的有些未被列出的内置类型成员被忘记初始化。而有些时候，即使成员变量是内置类型，也必须要用成员初始化列表（成员变量为const或者reference，它们一定要有初值，而且不能被赋值）。\n\r#\t构造函数\n\r1.\t使用构造函数的原因：由于类的封装性,不能象普通变量一样初始化\r2.\t构造函数的作用：是在对象被创建时使用特定的值构造对象，或者说将对象初始化为一个特定的状态。\r3.\t调用时刻：在对象创建时由系统自动调用。如果程序中未声明，则系统自动产生出一个缺省形式的构造函数\r4.\t条件约束：允许为内联函数、重载函数、带缺省形参值的函数；但不允许是虚函数因为在刚开始对象还未被创建，内部什么都没有，更不用说虚表，虚表指针。因此无法调用虚函数。\n\r#\t拷贝构造函数（是一种特殊的构造函数，其形参为本类的对象引用）。　\r作用：使用一个对象（参数指定的对象），去初始化一个正在被建立的同类型对象（如果程序员没有为类声明拷贝初始化构造函数，则编译器自己生成一个拷贝构造函数。）\n\r调用时刻：\n\r1. \t当用类的一个对象去初始化该类的另一个对象时系统自动调用它实现拷贝赋值。\r2.\t若函数的形参为类对象，调用函数时，实参赋值给形参，系统自动调用拷贝构造函数。\r3.\t当函数的返回值是类对象时，系统自动调用拷贝构造函数。\r#\t析构函数\r作用：完成对象被删除前的一些清理工作。\r调用时刻：在对象的生存期结束的时刻系统自动调用它，然后再释放此对象所属的空间。\r如果程序中未声明析构函数，编译器将自动产生一个缺省的析构函数。\n\r注意事项：  \n\n1.\t析构函数也不被继承，派生类自行声明。\r2. 声明方法与一般（无继承关系时）类的析构函数相同。\r3. 不需要显式地调用基类的析构函数，系统会自动隐式调用。\r4. 析构函数的调用次序与构造函数相反。\n\r#\t类组合的构造函数调用\r1.\t构造函数调用顺序：先调用内嵌对象的构造函数（按内嵌时的声明顺序，先声明者先构造）。然后调用本类的构造函数。（析构函数的调用顺序相反）\r2.\t若调用缺省构造函数（即无形参的），则内嵌对象的初始化也将调用相应的缺省构造函数。\n\r# 多继承且有内嵌对象时的构造函数调用次序\r1.\t调用基类构造函数，调用顺序按照它们被继承时声明的顺序（从左向右）。\r2.\t调用成员对象的构造函数，调用顺序按照它们在类中声明的顺序。\n\r#\t静态数据成员\n\r在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。\r\r使用静态数据成员可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。\n\r静态数据成员的使用方法和注意事项如下：\n\r1. 静态数据成员在定义或说明时前面加关键字static。\r2. 静态成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式如下：\r     <数据类型><类名>::<静态数据成员名>=<值>\n     \r这表明：\n\r1. 初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆。\r2. 初始化时不加该成员的访问权限控制符private，public等。\n3. 初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员。\r4. 静态数据成员是静态存储的，它是静态生存期，必须对它进行初始化。\r5. 引用静态数据成员时，采用如下格式：\r<类名>::<静态成员名>\n\r#\t静态成员函数\r1. \t静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。\r2.\t在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员。如果静态成员函数中要引用非静态成员时，可通过对象来引用。\r3.\t调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);\r4.\t类外代码可以使用类名和作用域操作符来调用静态成员函数。\n5. \t静态成员函数只能引用属于该类的静态数据成员或静态成员函数。\n\r#\tInline函数\n\rC++ inline函数 ：\n\n\tinline int min(int first, int secend) {/****/};\n\t\r1. \tinline函数对编译器而言必须是可见的，以便它能够在调用点内展开该函数。与非\rinline函数不同的是，inline函数必须在调用该函数的每个文本文件中定义。\r2.\t关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。\r（所以说，inline 是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了inline 关键字，但我认为inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。）\n\r#\t慎用内联：\n\r内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联：\n\r1. 如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。\r2. 如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。\n\r#\t内联函数和#define 宏的区别：\n\r内联函数总是对参数只精确地进行一次求值，从而避免了那声名狼藉的宏错误。换句话说，调用内联函数和调用正规函数是等价的，差别仅仅是更快\n\r#\t 常函数的调用是这样的：\n\r常量对象只能调用常成员函数，非常量对象即可以调常成员函数，也可以调一般成员函数，但当某个函数有const和非const两个版本时，const对象调const版本，非const对象调非const版本。\n\r#\t二义性的问题\n\r1. \t在多继承时，基类与派生类之间，或基类之间出现同名成员时，将出现访问时的二义性（不确定性）——采用虚函数（第8章）或支配（同名覆盖）原则来解决。\r2.\t当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类中的成员时，将产生二义性——采用虚基类来解决。\n\r#\t虚基类\r引入\n\r1. \t用于有共同基类的场合声明\r2. \t以virtual修饰说明基类\t例：class B1:virtual public B\n\r作用：\n\r1. \t主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题.\r2.\t为最远的派生类提供唯一的基类成员，而不重复产生多次拷贝  \n\r**注意：** 在第一级继承时就要将共同基类设计为虚基类。\n\r# 虚基类及其派生类构造函数\r1.\t建立对象时所指定的类称为最（远）派生类。\r2.\t虚基类的成员是由最派生类的构造函数通过调用虚基类的构造函数进行初始化的。\r3.\t在整个继承结构中，直接或间接继承虚基类的所有派生类，都必须在构造函数的成员初始化表中给出对虚基类的构造函数的调用。如果未列出，则表示调用该虚基类的缺省构造函数。\r4.\t在建立对象时，只有最派生类的构造函数调用虚基类的构造函数，该派生类的其它基类对虚基类构造函数的调用被忽略。\r\r","source":"_posts/c-类的四大函数.md","raw":"---\ntitle: c++ 类的四大函数\ncomments: true\ntags:\n  - C++\n  - 类\ncategories:\n  - C++\ndate: 2017-03-05 17:33:19\nupdate: 2017-03-05 17:33:19\n---\n\n# 类与对象\r1.\t类是用户自定义的一种数据类型，定义类时描述它可以提供的信息及能够执行的操作；即类是一种具有属性和行为的自定义的数据类型；\r2.\t对象就是封装了数据结构，及施加这些数据结构上的操作的封装体；\n\r#\t类与对象的关系：\r类之于对象如同类型之于变量，因此类只是描述了数据格式和方法，而对象则是根据规范创建的实体；换句话说类就像图纸，而对象则是根据图纸盖起的大楼。\n\r#\t类与结构体的区别\n\r唯一的区别在于struct的默认访问权限是public,而类是private;\n\r#\tC++中的类所占内存分析：\n\r1. 类所占内存的大小是由成员变量（静态变量除外）决定的，成员函数（这是笼统的说，后面会细说）是不计算在内的。成员函数还是以一般的函数一样的存在。a.fun()是通过fun(a.this)来调用的。\r2. 所谓成员函数只是在名义上是类里的。其实成员函数的大小不在类的对象里面，同一个类的多个对象共享函数代码。而我们访问类的成员函数是通过类里面的一个指针实现，而这个指针指向的是一个table，\r3. table里面记录的各个成员函数的地址（当然不同的编译可能略有不同的实现）。所以我们访问成员函数是间接获得地址的。所以这样也就增加了一定的时间开销，这也就是为什么我们提倡把一些简短的，调用频率高的函数声明为inline形式（内联函数）。\r\r总结：空的类是会占用内存空间的，而且大小是1，原因是C++要求每个实例在内存中都有独一无二的地址。\n\r1. 类内部的成员变量：\r    普通的变量：是要占用内存的，但是要注意对齐原则（这点和struct类型很相似）。\r    static修饰的静态变量：不占用内容，原因是编译器将其放在全局变量区。\r2. 类内部的成员函数：\r    普通函数：不占用内存。\r    虚函数：要占用4个字节，用来指定虚函数的虚拟函数表的入口地址。所以一个类的虚函数所占用的地址是不变的，和虚函数的个数是没有关系的。\r\r\r#\tC++类中的四大函数：构造函数、拷贝构造函数、析构函数和赋值函数:\n\r1.\t四个函数一般系统都会默认。但是往往系统默认的并不是我们所期望的，为此我们有必要自己编写符合要求的函数，参看String.cpp;\r2.\t把对象的初始化工作放在构造函数中，当对象被创建时，构造函数被自动执行。\r3.\t把清除工作放在析构函数中。当对象消亡时，析构函数被自动执行，把一切内存垃圾清理，可见他的重要。如果没有析构函数或析构函数不正确就会发生内存泄露等问题，后果非常危险\r4.\t每个类只有一个析构函数和一个赋值函数，但可以有多个构造函数（包含一个拷贝构造函数，其它的称为普通构造函数）。\r5.\t构造函数和赋值函数有着很大的区别，构造函数是在对象创建时调用的；而赋值函数使对象已经创建好了存在之后再赋值时调用的。有时候我们懒得写赋值函数和拷贝构造函数，又不允许别人使用编译器生成的缺省函数，那么我们可以只需将拷贝构造函数和赋值函数声明为私有函数，函数体为空即可；\n\r#\t使用对象前正确初始化\n\r1.\t并不是所有的编译器都对象对象的内置类型成员会被自动初始化为0。永远在使用对象之前先将它初始化。确保每一个构造函数都将对象的每一个成员初始化。\r2.\t别把赋值错当成初始化。C++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前（对于内置类型对象可能不确定），这点对于非内置类型对象来说尤其关键。如果你没有在成员初始化列表（member initialization list）为其初始化，它们将调用自己的默认构造函数，然后才进入构造函数内部（很可能你会在这里给他们赋值）。在成员初始化列表中的初始化只是调用了拷贝构造函数一次，而在构造函数内部再为其赋值则在调用默认构造函数后又调用了一次拷贝构造函数。因此初始化列表将更为高效\r\r所以，请用成员初始化列表进行初始化，虽然效率提高只针对于非内置类型成员，但是规定总是在初值列中列出所有成员变量，这样就省的有些未被列出的内置类型成员被忘记初始化。而有些时候，即使成员变量是内置类型，也必须要用成员初始化列表（成员变量为const或者reference，它们一定要有初值，而且不能被赋值）。\n\r#\t构造函数\n\r1.\t使用构造函数的原因：由于类的封装性,不能象普通变量一样初始化\r2.\t构造函数的作用：是在对象被创建时使用特定的值构造对象，或者说将对象初始化为一个特定的状态。\r3.\t调用时刻：在对象创建时由系统自动调用。如果程序中未声明，则系统自动产生出一个缺省形式的构造函数\r4.\t条件约束：允许为内联函数、重载函数、带缺省形参值的函数；但不允许是虚函数因为在刚开始对象还未被创建，内部什么都没有，更不用说虚表，虚表指针。因此无法调用虚函数。\n\r#\t拷贝构造函数（是一种特殊的构造函数，其形参为本类的对象引用）。　\r作用：使用一个对象（参数指定的对象），去初始化一个正在被建立的同类型对象（如果程序员没有为类声明拷贝初始化构造函数，则编译器自己生成一个拷贝构造函数。）\n\r调用时刻：\n\r1. \t当用类的一个对象去初始化该类的另一个对象时系统自动调用它实现拷贝赋值。\r2.\t若函数的形参为类对象，调用函数时，实参赋值给形参，系统自动调用拷贝构造函数。\r3.\t当函数的返回值是类对象时，系统自动调用拷贝构造函数。\r#\t析构函数\r作用：完成对象被删除前的一些清理工作。\r调用时刻：在对象的生存期结束的时刻系统自动调用它，然后再释放此对象所属的空间。\r如果程序中未声明析构函数，编译器将自动产生一个缺省的析构函数。\n\r注意事项：  \n\n1.\t析构函数也不被继承，派生类自行声明。\r2. 声明方法与一般（无继承关系时）类的析构函数相同。\r3. 不需要显式地调用基类的析构函数，系统会自动隐式调用。\r4. 析构函数的调用次序与构造函数相反。\n\r#\t类组合的构造函数调用\r1.\t构造函数调用顺序：先调用内嵌对象的构造函数（按内嵌时的声明顺序，先声明者先构造）。然后调用本类的构造函数。（析构函数的调用顺序相反）\r2.\t若调用缺省构造函数（即无形参的），则内嵌对象的初始化也将调用相应的缺省构造函数。\n\r# 多继承且有内嵌对象时的构造函数调用次序\r1.\t调用基类构造函数，调用顺序按照它们被继承时声明的顺序（从左向右）。\r2.\t调用成员对象的构造函数，调用顺序按照它们在类中声明的顺序。\n\r#\t静态数据成员\n\r在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。\r\r使用静态数据成员可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。\n\r静态数据成员的使用方法和注意事项如下：\n\r1. 静态数据成员在定义或说明时前面加关键字static。\r2. 静态成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式如下：\r     <数据类型><类名>::<静态数据成员名>=<值>\n     \r这表明：\n\r1. 初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆。\r2. 初始化时不加该成员的访问权限控制符private，public等。\n3. 初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员。\r4. 静态数据成员是静态存储的，它是静态生存期，必须对它进行初始化。\r5. 引用静态数据成员时，采用如下格式：\r<类名>::<静态成员名>\n\r#\t静态成员函数\r1. \t静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。\r2.\t在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员。如果静态成员函数中要引用非静态成员时，可通过对象来引用。\r3.\t调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);\r4.\t类外代码可以使用类名和作用域操作符来调用静态成员函数。\n5. \t静态成员函数只能引用属于该类的静态数据成员或静态成员函数。\n\r#\tInline函数\n\rC++ inline函数 ：\n\n\tinline int min(int first, int secend) {/****/};\n\t\r1. \tinline函数对编译器而言必须是可见的，以便它能够在调用点内展开该函数。与非\rinline函数不同的是，inline函数必须在调用该函数的每个文本文件中定义。\r2.\t关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。\r（所以说，inline 是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了inline 关键字，但我认为inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。）\n\r#\t慎用内联：\n\r内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联：\n\r1. 如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。\r2. 如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。\n\r#\t内联函数和#define 宏的区别：\n\r内联函数总是对参数只精确地进行一次求值，从而避免了那声名狼藉的宏错误。换句话说，调用内联函数和调用正规函数是等价的，差别仅仅是更快\n\r#\t 常函数的调用是这样的：\n\r常量对象只能调用常成员函数，非常量对象即可以调常成员函数，也可以调一般成员函数，但当某个函数有const和非const两个版本时，const对象调const版本，非const对象调非const版本。\n\r#\t二义性的问题\n\r1. \t在多继承时，基类与派生类之间，或基类之间出现同名成员时，将出现访问时的二义性（不确定性）——采用虚函数（第8章）或支配（同名覆盖）原则来解决。\r2.\t当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类中的成员时，将产生二义性——采用虚基类来解决。\n\r#\t虚基类\r引入\n\r1. \t用于有共同基类的场合声明\r2. \t以virtual修饰说明基类\t例：class B1:virtual public B\n\r作用：\n\r1. \t主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题.\r2.\t为最远的派生类提供唯一的基类成员，而不重复产生多次拷贝  \n\r**注意：** 在第一级继承时就要将共同基类设计为虚基类。\n\r# 虚基类及其派生类构造函数\r1.\t建立对象时所指定的类称为最（远）派生类。\r2.\t虚基类的成员是由最派生类的构造函数通过调用虚基类的构造函数进行初始化的。\r3.\t在整个继承结构中，直接或间接继承虚基类的所有派生类，都必须在构造函数的成员初始化表中给出对虚基类的构造函数的调用。如果未列出，则表示调用该虚基类的缺省构造函数。\r4.\t在建立对象时，只有最派生类的构造函数调用虚基类的构造函数，该派生类的其它基类对虚基类构造函数的调用被忽略。\r\r","slug":"c-类的四大函数","published":1,"updated":"2017-09-02T10:12:11.000Z","layout":"post","photos":[],"link":"","_id":"cjd4d1a00000uryx40ti3sb51","content":"<h1 id=\"类与对象\"><a href=\"#类与对象\" class=\"headerlink\" title=\"类与对象\"></a>类与对象</h1><ol>\n<li>类是用户自定义的一种数据类型，定义类时描述它可以提供的信息及能够执行的操作；即类是一种具有属性和行为的自定义的数据类型；</li>\n<li>对象就是封装了数据结构，及施加这些数据结构上的操作的封装体；</li>\n</ol>\n<h1 id=\"类与对象的关系：\"><a href=\"#类与对象的关系：\" class=\"headerlink\" title=\"类与对象的关系：\"></a>类与对象的关系：</h1><p>类之于对象如同类型之于变量，因此类只是描述了数据格式和方法，而对象则是根据规范创建的实体；换句话说类就像图纸，而对象则是根据图纸盖起的大楼。</p>\n<h1 id=\"类与结构体的区别\"><a href=\"#类与结构体的区别\" class=\"headerlink\" title=\"类与结构体的区别\"></a>类与结构体的区别</h1><p>唯一的区别在于struct的默认访问权限是public,而类是private;</p>\n<h1 id=\"C-中的类所占内存分析：\"><a href=\"#C-中的类所占内存分析：\" class=\"headerlink\" title=\"C++中的类所占内存分析：\"></a>C++中的类所占内存分析：</h1><ol>\n<li>类所占内存的大小是由成员变量（静态变量除外）决定的，成员函数（这是笼统的说，后面会细说）是不计算在内的。成员函数还是以一般的函数一样的存在。a.fun()是通过fun(a.this)来调用的。</li>\n<li>所谓成员函数只是在名义上是类里的。其实成员函数的大小不在类的对象里面，同一个类的多个对象共享函数代码。而我们访问类的成员函数是通过类里面的一个指针实现，而这个指针指向的是一个table，</li>\n<li>table里面记录的各个成员函数的地址（当然不同的编译可能略有不同的实现）。所以我们访问成员函数是间接获得地址的。所以这样也就增加了一定的时间开销，这也就是为什么我们提倡把一些简短的，调用频率高的函数声明为inline形式（内联函数）。</li>\n</ol>\n<p>总结：空的类是会占用内存空间的，而且大小是1，原因是C++要求每个实例在内存中都有独一无二的地址。</p>\n<ol>\n<li>类内部的成员变量：<br> 普通的变量：是要占用内存的，但是要注意对齐原则（这点和struct类型很相似）。<br> static修饰的静态变量：不占用内容，原因是编译器将其放在全局变量区。</li>\n<li>类内部的成员函数：<br> 普通函数：不占用内存。<br> 虚函数：要占用4个字节，用来指定虚函数的虚拟函数表的入口地址。所以一个类的虚函数所占用的地址是不变的，和虚函数的个数是没有关系的。</li>\n</ol>\n<h1 id=\"C-类中的四大函数：构造函数、拷贝构造函数、析构函数和赋值函数\"><a href=\"#C-类中的四大函数：构造函数、拷贝构造函数、析构函数和赋值函数\" class=\"headerlink\" title=\"C++类中的四大函数：构造函数、拷贝构造函数、析构函数和赋值函数:\"></a>C++类中的四大函数：构造函数、拷贝构造函数、析构函数和赋值函数:</h1><ol>\n<li>四个函数一般系统都会默认。但是往往系统默认的并不是我们所期望的，为此我们有必要自己编写符合要求的函数，参看String.cpp;</li>\n<li>把对象的初始化工作放在构造函数中，当对象被创建时，构造函数被自动执行。</li>\n<li>把清除工作放在析构函数中。当对象消亡时，析构函数被自动执行，把一切内存垃圾清理，可见他的重要。如果没有析构函数或析构函数不正确就会发生内存泄露等问题，后果非常危险</li>\n<li>每个类只有一个析构函数和一个赋值函数，但可以有多个构造函数（包含一个拷贝构造函数，其它的称为普通构造函数）。</li>\n<li>构造函数和赋值函数有着很大的区别，构造函数是在对象创建时调用的；而赋值函数使对象已经创建好了存在之后再赋值时调用的。有时候我们懒得写赋值函数和拷贝构造函数，又不允许别人使用编译器生成的缺省函数，那么我们可以只需将拷贝构造函数和赋值函数声明为私有函数，函数体为空即可；</li>\n</ol>\n<h1 id=\"使用对象前正确初始化\"><a href=\"#使用对象前正确初始化\" class=\"headerlink\" title=\"使用对象前正确初始化\"></a>使用对象前正确初始化</h1><ol>\n<li>并不是所有的编译器都对象对象的内置类型成员会被自动初始化为0。永远在使用对象之前先将它初始化。确保每一个构造函数都将对象的每一个成员初始化。</li>\n<li>别把赋值错当成初始化。C++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前（对于内置类型对象可能不确定），这点对于非内置类型对象来说尤其关键。如果你没有在成员初始化列表（member initialization list）为其初始化，它们将调用自己的默认构造函数，然后才进入构造函数内部（很可能你会在这里给他们赋值）。在成员初始化列表中的初始化只是调用了拷贝构造函数一次，而在构造函数内部再为其赋值则在调用默认构造函数后又调用了一次拷贝构造函数。因此初始化列表将更为高效</li>\n</ol>\n<p>所以，请用成员初始化列表进行初始化，虽然效率提高只针对于非内置类型成员，但是规定总是在初值列中列出所有成员变量，这样就省的有些未被列出的内置类型成员被忘记初始化。而有些时候，即使成员变量是内置类型，也必须要用成员初始化列表（成员变量为const或者reference，它们一定要有初值，而且不能被赋值）。</p>\n<h1 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h1><ol>\n<li>使用构造函数的原因：由于类的封装性,不能象普通变量一样初始化</li>\n<li>构造函数的作用：是在对象被创建时使用特定的值构造对象，或者说将对象初始化为一个特定的状态。</li>\n<li>调用时刻：在对象创建时由系统自动调用。如果程序中未声明，则系统自动产生出一个缺省形式的构造函数</li>\n<li>条件约束：允许为内联函数、重载函数、带缺省形参值的函数；但不允许是虚函数因为在刚开始对象还未被创建，内部什么都没有，更不用说虚表，虚表指针。因此无法调用虚函数。</li>\n</ol>\n<h1 id=\"拷贝构造函数（是一种特殊的构造函数，其形参为本类的对象引用）。\"><a href=\"#拷贝构造函数（是一种特殊的构造函数，其形参为本类的对象引用）。\" class=\"headerlink\" title=\"拷贝构造函数（是一种特殊的构造函数，其形参为本类的对象引用）。　\"></a>拷贝构造函数（是一种特殊的构造函数，其形参为本类的对象引用）。　</h1><p>作用：使用一个对象（参数指定的对象），去初始化一个正在被建立的同类型对象（如果程序员没有为类声明拷贝初始化构造函数，则编译器自己生成一个拷贝构造函数。）</p>\n<p>调用时刻：</p>\n<ol>\n<li>当用类的一个对象去初始化该类的另一个对象时系统自动调用它实现拷贝赋值。</li>\n<li>若函数的形参为类对象，调用函数时，实参赋值给形参，系统自动调用拷贝构造函数。</li>\n<li>当函数的返回值是类对象时，系统自动调用拷贝构造函数。<h1 id=\"析构函数\"><a href=\"#析构函数\" class=\"headerlink\" title=\"析构函数\"></a>析构函数</h1>作用：完成对象被删除前的一些清理工作。<br>调用时刻：在对象的生存期结束的时刻系统自动调用它，然后再释放此对象所属的空间。<br>如果程序中未声明析构函数，编译器将自动产生一个缺省的析构函数。</li>\n</ol>\n<p>注意事项：  </p>\n<ol>\n<li>析构函数也不被继承，派生类自行声明。</li>\n<li>声明方法与一般（无继承关系时）类的析构函数相同。</li>\n<li>不需要显式地调用基类的析构函数，系统会自动隐式调用。</li>\n<li>析构函数的调用次序与构造函数相反。</li>\n</ol>\n<h1 id=\"类组合的构造函数调用\"><a href=\"#类组合的构造函数调用\" class=\"headerlink\" title=\"类组合的构造函数调用\"></a>类组合的构造函数调用</h1><ol>\n<li>构造函数调用顺序：先调用内嵌对象的构造函数（按内嵌时的声明顺序，先声明者先构造）。然后调用本类的构造函数。（析构函数的调用顺序相反）</li>\n<li>若调用缺省构造函数（即无形参的），则内嵌对象的初始化也将调用相应的缺省构造函数。</li>\n</ol>\n<h1 id=\"多继承且有内嵌对象时的构造函数调用次序\"><a href=\"#多继承且有内嵌对象时的构造函数调用次序\" class=\"headerlink\" title=\"多继承且有内嵌对象时的构造函数调用次序\"></a>多继承且有内嵌对象时的构造函数调用次序</h1><ol>\n<li>调用基类构造函数，调用顺序按照它们被继承时声明的顺序（从左向右）。</li>\n<li>调用成员对象的构造函数，调用顺序按照它们在类中声明的顺序。</li>\n</ol>\n<h1 id=\"静态数据成员\"><a href=\"#静态数据成员\" class=\"headerlink\" title=\"静态数据成员\"></a>静态数据成员</h1><p>在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。</p>\n<p>使用静态数据成员可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。</p>\n<p>静态数据成员的使用方法和注意事项如下：</p>\n<ol>\n<li>静态数据成员在定义或说明时前面加关键字static。</li>\n<li>静态成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式如下：<br>  &lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt;</li>\n</ol>\n<p>这表明：</p>\n<ol>\n<li>初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆。</li>\n<li>初始化时不加该成员的访问权限控制符private，public等。</li>\n<li>初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员。</li>\n<li>静态数据成员是静态存储的，它是静态生存期，必须对它进行初始化。</li>\n<li>引用静态数据成员时，采用如下格式：<br>&lt;类名&gt;::&lt;静态成员名&gt;</li>\n</ol>\n<h1 id=\"静态成员函数\"><a href=\"#静态成员函数\" class=\"headerlink\" title=\"静态成员函数\"></a>静态成员函数</h1><ol>\n<li>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。</li>\n<li>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员。如果静态成员函数中要引用非静态成员时，可通过对象来引用。</li>\n<li>调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);</li>\n<li>类外代码可以使用类名和作用域操作符来调用静态成员函数。</li>\n<li>静态成员函数只能引用属于该类的静态数据成员或静态成员函数。</li>\n</ol>\n<h1 id=\"Inline函数\"><a href=\"#Inline函数\" class=\"headerlink\" title=\"Inline函数\"></a>Inline函数</h1><p>C++ inline函数 ：</p>\n<pre><code>inline int min(int first, int secend) {/****/};\n</code></pre><ol>\n<li>inline函数对编译器而言必须是可见的，以便它能够在调用点内展开该函数。与非<br>inline函数不同的是，inline函数必须在调用该函数的每个文本文件中定义。</li>\n<li>关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。<br>（所以说，inline 是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了inline 关键字，但我认为inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。）</li>\n</ol>\n<h1 id=\"慎用内联：\"><a href=\"#慎用内联：\" class=\"headerlink\" title=\"慎用内联：\"></a>慎用内联：</h1><p>内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联：</p>\n<ol>\n<li>如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。</li>\n<li>如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。</li>\n</ol>\n<h1 id=\"内联函数和-define-宏的区别：\"><a href=\"#内联函数和-define-宏的区别：\" class=\"headerlink\" title=\"内联函数和#define 宏的区别：\"></a>内联函数和#define 宏的区别：</h1><p>内联函数总是对参数只精确地进行一次求值，从而避免了那声名狼藉的宏错误。换句话说，调用内联函数和调用正规函数是等价的，差别仅仅是更快</p>\n<h1 id=\"常函数的调用是这样的：\"><a href=\"#常函数的调用是这样的：\" class=\"headerlink\" title=\"常函数的调用是这样的：\"></a>常函数的调用是这样的：</h1><p>常量对象只能调用常成员函数，非常量对象即可以调常成员函数，也可以调一般成员函数，但当某个函数有const和非const两个版本时，const对象调const版本，非const对象调非const版本。</p>\n<h1 id=\"二义性的问题\"><a href=\"#二义性的问题\" class=\"headerlink\" title=\"二义性的问题\"></a>二义性的问题</h1><ol>\n<li>在多继承时，基类与派生类之间，或基类之间出现同名成员时，将出现访问时的二义性（不确定性）——采用虚函数（第8章）或支配（同名覆盖）原则来解决。</li>\n<li>当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类中的成员时，将产生二义性——采用虚基类来解决。</li>\n</ol>\n<h1 id=\"虚基类\"><a href=\"#虚基类\" class=\"headerlink\" title=\"虚基类\"></a>虚基类</h1><p>引入</p>\n<ol>\n<li>用于有共同基类的场合声明</li>\n<li>以virtual修饰说明基类    例：class B1:virtual public B</li>\n</ol>\n<p>作用：</p>\n<ol>\n<li>主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题.</li>\n<li>为最远的派生类提供唯一的基类成员，而不重复产生多次拷贝  </li>\n</ol>\n<p><strong>注意：</strong> 在第一级继承时就要将共同基类设计为虚基类。</p>\n<h1 id=\"虚基类及其派生类构造函数\"><a href=\"#虚基类及其派生类构造函数\" class=\"headerlink\" title=\"虚基类及其派生类构造函数\"></a>虚基类及其派生类构造函数</h1><ol>\n<li>建立对象时所指定的类称为最（远）派生类。</li>\n<li>虚基类的成员是由最派生类的构造函数通过调用虚基类的构造函数进行初始化的。</li>\n<li>在整个继承结构中，直接或间接继承虚基类的所有派生类，都必须在构造函数的成员初始化表中给出对虚基类的构造函数的调用。如果未列出，则表示调用该虚基类的缺省构造函数。</li>\n<li>在建立对象时，只有最派生类的构造函数调用虚基类的构造函数，该派生类的其它基类对虚基类构造函数的调用被忽略。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"类与对象\"><a href=\"#类与对象\" class=\"headerlink\" title=\"类与对象\"></a>类与对象</h1><ol>\n<li>类是用户自定义的一种数据类型，定义类时描述它可以提供的信息及能够执行的操作；即类是一种具有属性和行为的自定义的数据类型；</li>\n<li>对象就是封装了数据结构，及施加这些数据结构上的操作的封装体；</li>\n</ol>\n<h1 id=\"类与对象的关系：\"><a href=\"#类与对象的关系：\" class=\"headerlink\" title=\"类与对象的关系：\"></a>类与对象的关系：</h1><p>类之于对象如同类型之于变量，因此类只是描述了数据格式和方法，而对象则是根据规范创建的实体；换句话说类就像图纸，而对象则是根据图纸盖起的大楼。</p>\n<h1 id=\"类与结构体的区别\"><a href=\"#类与结构体的区别\" class=\"headerlink\" title=\"类与结构体的区别\"></a>类与结构体的区别</h1><p>唯一的区别在于struct的默认访问权限是public,而类是private;</p>\n<h1 id=\"C-中的类所占内存分析：\"><a href=\"#C-中的类所占内存分析：\" class=\"headerlink\" title=\"C++中的类所占内存分析：\"></a>C++中的类所占内存分析：</h1><ol>\n<li>类所占内存的大小是由成员变量（静态变量除外）决定的，成员函数（这是笼统的说，后面会细说）是不计算在内的。成员函数还是以一般的函数一样的存在。a.fun()是通过fun(a.this)来调用的。</li>\n<li>所谓成员函数只是在名义上是类里的。其实成员函数的大小不在类的对象里面，同一个类的多个对象共享函数代码。而我们访问类的成员函数是通过类里面的一个指针实现，而这个指针指向的是一个table，</li>\n<li>table里面记录的各个成员函数的地址（当然不同的编译可能略有不同的实现）。所以我们访问成员函数是间接获得地址的。所以这样也就增加了一定的时间开销，这也就是为什么我们提倡把一些简短的，调用频率高的函数声明为inline形式（内联函数）。</li>\n</ol>\n<p>总结：空的类是会占用内存空间的，而且大小是1，原因是C++要求每个实例在内存中都有独一无二的地址。</p>\n<ol>\n<li>类内部的成员变量：<br> 普通的变量：是要占用内存的，但是要注意对齐原则（这点和struct类型很相似）。<br> static修饰的静态变量：不占用内容，原因是编译器将其放在全局变量区。</li>\n<li>类内部的成员函数：<br> 普通函数：不占用内存。<br> 虚函数：要占用4个字节，用来指定虚函数的虚拟函数表的入口地址。所以一个类的虚函数所占用的地址是不变的，和虚函数的个数是没有关系的。</li>\n</ol>\n<h1 id=\"C-类中的四大函数：构造函数、拷贝构造函数、析构函数和赋值函数\"><a href=\"#C-类中的四大函数：构造函数、拷贝构造函数、析构函数和赋值函数\" class=\"headerlink\" title=\"C++类中的四大函数：构造函数、拷贝构造函数、析构函数和赋值函数:\"></a>C++类中的四大函数：构造函数、拷贝构造函数、析构函数和赋值函数:</h1><ol>\n<li>四个函数一般系统都会默认。但是往往系统默认的并不是我们所期望的，为此我们有必要自己编写符合要求的函数，参看String.cpp;</li>\n<li>把对象的初始化工作放在构造函数中，当对象被创建时，构造函数被自动执行。</li>\n<li>把清除工作放在析构函数中。当对象消亡时，析构函数被自动执行，把一切内存垃圾清理，可见他的重要。如果没有析构函数或析构函数不正确就会发生内存泄露等问题，后果非常危险</li>\n<li>每个类只有一个析构函数和一个赋值函数，但可以有多个构造函数（包含一个拷贝构造函数，其它的称为普通构造函数）。</li>\n<li>构造函数和赋值函数有着很大的区别，构造函数是在对象创建时调用的；而赋值函数使对象已经创建好了存在之后再赋值时调用的。有时候我们懒得写赋值函数和拷贝构造函数，又不允许别人使用编译器生成的缺省函数，那么我们可以只需将拷贝构造函数和赋值函数声明为私有函数，函数体为空即可；</li>\n</ol>\n<h1 id=\"使用对象前正确初始化\"><a href=\"#使用对象前正确初始化\" class=\"headerlink\" title=\"使用对象前正确初始化\"></a>使用对象前正确初始化</h1><ol>\n<li>并不是所有的编译器都对象对象的内置类型成员会被自动初始化为0。永远在使用对象之前先将它初始化。确保每一个构造函数都将对象的每一个成员初始化。</li>\n<li>别把赋值错当成初始化。C++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前（对于内置类型对象可能不确定），这点对于非内置类型对象来说尤其关键。如果你没有在成员初始化列表（member initialization list）为其初始化，它们将调用自己的默认构造函数，然后才进入构造函数内部（很可能你会在这里给他们赋值）。在成员初始化列表中的初始化只是调用了拷贝构造函数一次，而在构造函数内部再为其赋值则在调用默认构造函数后又调用了一次拷贝构造函数。因此初始化列表将更为高效</li>\n</ol>\n<p>所以，请用成员初始化列表进行初始化，虽然效率提高只针对于非内置类型成员，但是规定总是在初值列中列出所有成员变量，这样就省的有些未被列出的内置类型成员被忘记初始化。而有些时候，即使成员变量是内置类型，也必须要用成员初始化列表（成员变量为const或者reference，它们一定要有初值，而且不能被赋值）。</p>\n<h1 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h1><ol>\n<li>使用构造函数的原因：由于类的封装性,不能象普通变量一样初始化</li>\n<li>构造函数的作用：是在对象被创建时使用特定的值构造对象，或者说将对象初始化为一个特定的状态。</li>\n<li>调用时刻：在对象创建时由系统自动调用。如果程序中未声明，则系统自动产生出一个缺省形式的构造函数</li>\n<li>条件约束：允许为内联函数、重载函数、带缺省形参值的函数；但不允许是虚函数因为在刚开始对象还未被创建，内部什么都没有，更不用说虚表，虚表指针。因此无法调用虚函数。</li>\n</ol>\n<h1 id=\"拷贝构造函数（是一种特殊的构造函数，其形参为本类的对象引用）。\"><a href=\"#拷贝构造函数（是一种特殊的构造函数，其形参为本类的对象引用）。\" class=\"headerlink\" title=\"拷贝构造函数（是一种特殊的构造函数，其形参为本类的对象引用）。　\"></a>拷贝构造函数（是一种特殊的构造函数，其形参为本类的对象引用）。　</h1><p>作用：使用一个对象（参数指定的对象），去初始化一个正在被建立的同类型对象（如果程序员没有为类声明拷贝初始化构造函数，则编译器自己生成一个拷贝构造函数。）</p>\n<p>调用时刻：</p>\n<ol>\n<li>当用类的一个对象去初始化该类的另一个对象时系统自动调用它实现拷贝赋值。</li>\n<li>若函数的形参为类对象，调用函数时，实参赋值给形参，系统自动调用拷贝构造函数。</li>\n<li>当函数的返回值是类对象时，系统自动调用拷贝构造函数。<h1 id=\"析构函数\"><a href=\"#析构函数\" class=\"headerlink\" title=\"析构函数\"></a>析构函数</h1>作用：完成对象被删除前的一些清理工作。<br>调用时刻：在对象的生存期结束的时刻系统自动调用它，然后再释放此对象所属的空间。<br>如果程序中未声明析构函数，编译器将自动产生一个缺省的析构函数。</li>\n</ol>\n<p>注意事项：  </p>\n<ol>\n<li>析构函数也不被继承，派生类自行声明。</li>\n<li>声明方法与一般（无继承关系时）类的析构函数相同。</li>\n<li>不需要显式地调用基类的析构函数，系统会自动隐式调用。</li>\n<li>析构函数的调用次序与构造函数相反。</li>\n</ol>\n<h1 id=\"类组合的构造函数调用\"><a href=\"#类组合的构造函数调用\" class=\"headerlink\" title=\"类组合的构造函数调用\"></a>类组合的构造函数调用</h1><ol>\n<li>构造函数调用顺序：先调用内嵌对象的构造函数（按内嵌时的声明顺序，先声明者先构造）。然后调用本类的构造函数。（析构函数的调用顺序相反）</li>\n<li>若调用缺省构造函数（即无形参的），则内嵌对象的初始化也将调用相应的缺省构造函数。</li>\n</ol>\n<h1 id=\"多继承且有内嵌对象时的构造函数调用次序\"><a href=\"#多继承且有内嵌对象时的构造函数调用次序\" class=\"headerlink\" title=\"多继承且有内嵌对象时的构造函数调用次序\"></a>多继承且有内嵌对象时的构造函数调用次序</h1><ol>\n<li>调用基类构造函数，调用顺序按照它们被继承时声明的顺序（从左向右）。</li>\n<li>调用成员对象的构造函数，调用顺序按照它们在类中声明的顺序。</li>\n</ol>\n<h1 id=\"静态数据成员\"><a href=\"#静态数据成员\" class=\"headerlink\" title=\"静态数据成员\"></a>静态数据成员</h1><p>在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。</p>\n<p>使用静态数据成员可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。</p>\n<p>静态数据成员的使用方法和注意事项如下：</p>\n<ol>\n<li>静态数据成员在定义或说明时前面加关键字static。</li>\n<li>静态成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式如下：<br>  &lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt;</li>\n</ol>\n<p>这表明：</p>\n<ol>\n<li>初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆。</li>\n<li>初始化时不加该成员的访问权限控制符private，public等。</li>\n<li>初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员。</li>\n<li>静态数据成员是静态存储的，它是静态生存期，必须对它进行初始化。</li>\n<li>引用静态数据成员时，采用如下格式：<br>&lt;类名&gt;::&lt;静态成员名&gt;</li>\n</ol>\n<h1 id=\"静态成员函数\"><a href=\"#静态成员函数\" class=\"headerlink\" title=\"静态成员函数\"></a>静态成员函数</h1><ol>\n<li>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。</li>\n<li>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员。如果静态成员函数中要引用非静态成员时，可通过对象来引用。</li>\n<li>调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);</li>\n<li>类外代码可以使用类名和作用域操作符来调用静态成员函数。</li>\n<li>静态成员函数只能引用属于该类的静态数据成员或静态成员函数。</li>\n</ol>\n<h1 id=\"Inline函数\"><a href=\"#Inline函数\" class=\"headerlink\" title=\"Inline函数\"></a>Inline函数</h1><p>C++ inline函数 ：</p>\n<pre><code>inline int min(int first, int secend) {/****/};\n</code></pre><ol>\n<li>inline函数对编译器而言必须是可见的，以便它能够在调用点内展开该函数。与非<br>inline函数不同的是，inline函数必须在调用该函数的每个文本文件中定义。</li>\n<li>关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。<br>（所以说，inline 是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了inline 关键字，但我认为inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。）</li>\n</ol>\n<h1 id=\"慎用内联：\"><a href=\"#慎用内联：\" class=\"headerlink\" title=\"慎用内联：\"></a>慎用内联：</h1><p>内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联：</p>\n<ol>\n<li>如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。</li>\n<li>如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。</li>\n</ol>\n<h1 id=\"内联函数和-define-宏的区别：\"><a href=\"#内联函数和-define-宏的区别：\" class=\"headerlink\" title=\"内联函数和#define 宏的区别：\"></a>内联函数和#define 宏的区别：</h1><p>内联函数总是对参数只精确地进行一次求值，从而避免了那声名狼藉的宏错误。换句话说，调用内联函数和调用正规函数是等价的，差别仅仅是更快</p>\n<h1 id=\"常函数的调用是这样的：\"><a href=\"#常函数的调用是这样的：\" class=\"headerlink\" title=\"常函数的调用是这样的：\"></a>常函数的调用是这样的：</h1><p>常量对象只能调用常成员函数，非常量对象即可以调常成员函数，也可以调一般成员函数，但当某个函数有const和非const两个版本时，const对象调const版本，非const对象调非const版本。</p>\n<h1 id=\"二义性的问题\"><a href=\"#二义性的问题\" class=\"headerlink\" title=\"二义性的问题\"></a>二义性的问题</h1><ol>\n<li>在多继承时，基类与派生类之间，或基类之间出现同名成员时，将出现访问时的二义性（不确定性）——采用虚函数（第8章）或支配（同名覆盖）原则来解决。</li>\n<li>当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类中的成员时，将产生二义性——采用虚基类来解决。</li>\n</ol>\n<h1 id=\"虚基类\"><a href=\"#虚基类\" class=\"headerlink\" title=\"虚基类\"></a>虚基类</h1><p>引入</p>\n<ol>\n<li>用于有共同基类的场合声明</li>\n<li>以virtual修饰说明基类    例：class B1:virtual public B</li>\n</ol>\n<p>作用：</p>\n<ol>\n<li>主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题.</li>\n<li>为最远的派生类提供唯一的基类成员，而不重复产生多次拷贝  </li>\n</ol>\n<p><strong>注意：</strong> 在第一级继承时就要将共同基类设计为虚基类。</p>\n<h1 id=\"虚基类及其派生类构造函数\"><a href=\"#虚基类及其派生类构造函数\" class=\"headerlink\" title=\"虚基类及其派生类构造函数\"></a>虚基类及其派生类构造函数</h1><ol>\n<li>建立对象时所指定的类称为最（远）派生类。</li>\n<li>虚基类的成员是由最派生类的构造函数通过调用虚基类的构造函数进行初始化的。</li>\n<li>在整个继承结构中，直接或间接继承虚基类的所有派生类，都必须在构造函数的成员初始化表中给出对虚基类的构造函数的调用。如果未列出，则表示调用该虚基类的缺省构造函数。</li>\n<li>在建立对象时，只有最派生类的构造函数调用虚基类的构造函数，该派生类的其它基类对虚基类构造函数的调用被忽略。</li>\n</ol>\n"},{"title":"git 常用命令","comments":1,"date":"2017-09-09T02:36:59.000Z","update":"2017-09-09T02:36:59.000Z","_content":"\n# 版本间的切换\n\n```\ngit log --pretty=online 版本记录\n\ngit reset -hard HEAD^ 会退上一个版本\n\ngit reflog 记录每一次命令，通过commitID可以回退\n\ngit reset --hard  commitID 回退到某个版本\ngit log 可以查看提交历史确认commitID\n要重返未来，用git reflog 查看历史命令，确定版本。\n\n\n```\n\n# 三种回退文件修改内容\n\n```\n1. 修改文件，未暂存，git checkout -- file 丢弃工作区的修改\n2. 修改文件，暂存 \ngit reset HEAD file 把暂存区的修改撤销掉\ngit checkout -- file 丢弃工作区的修改\n3. 修改文件，暂存，已提交本地。使用版本回退。\n\ngit diff 查看修改与仓库的不同\n\n提交之前撤销git add\n如果只需要移除一个文件，那么请输入：\n$ git reset <文件名>\n移除所有没有提交的修改：\n$ git reset\n\n```\n\n\n#关联远程分支\n```\ngit remote add orgin git@github.com:仓库地址。\ngit push -u orgin master第一次推送master分支的所有内容，之后就可以使用 git push orgin master推送 最新修改。\n```\n\n\n# 创建并切换分支\n\n```\ngit checkout -b newbranch \n创建分支\ngit branch newbranch \n切换分支\ngit checkout branch \n```\n\n# 拉取远程分支，并创建本地之分\n\n```\ngit checkout -b branchname  orgin/branchname 在本地创建和远程对应的分支\ngit fetch origin 远程分支名x:本地分支名x。   git checkout branch\n```\n\n# 合并分支(合并dev到当前分支)\ngit merge dev\n\n# 查看分支\n\n```\ngit branch 查看本地分支\ngit branch -r 查看远程分支\n```\n\n# 推送本地分支到远程\n\n```\ngit push origin local_branch:remote_branch\ngit branch --set-upstream branchname orgin/branchname 建立本地分支与远程分支关联\n```\n\n# 删除分支\n\n```\ngit branch -d newbranch\ngit branch -D newbranch(强删)\ngit push origin --delete <branchName>  删除远程分支\n```\n\n# 修复bug\n```\n创建分支，修复bug，合并，删除。当手上工作并没有完成时，先把工作现场git stash 储藏现场工作一下，修复完后切回本分支，再git stash pop,回到现场。\ngit stash list 查看储藏的工作现场\ngit stash apply 恢复stash的内容不删除\ngit stash drop 删除储藏的内容\ngit stash pop 恢复工作现场并删除\n\ngit remove -v 查看远程仓库的信息。\ngit push origin beanch-name 推送本地分支到远程仓库，如果推送失败，先git pull远程分支\n\n```\n\n\n\n\n# 修改错误的提交信息\n\n```\ngit commit --amend -m ”YOUR-NEW-COMMIT-MESSAGE”\ngit push <remote> <branch> —force (修改推送后的提交信息)\n```\n\n# 标签\n\n```\ngit tag 查看所有标签\ngit tag v1.0 打标签\ngit tag v1.0  committID 给指定分支打标签\ngit show v1.0 查看标签信息\ngit tag -d v1.0 删除标签\ngit push orgin v1.0 推送标签到远程分支\ngit push orgin --tags  推送全部尚未推送的标签\n```\n\n## 删除已推送的远程仓库的标签\n\n```\ngit tag -d v1.0 删除标签\ngit push orgin:refs/tags/v1.0 \n```\n\n\n\n# 编写文档步骤\n\n```git checkout master  \ngit pull\ngit checkout feature-add_insurance_docs  \ngit rebase origin/master  \ngit status  \nvim  \ngit add .\ngit rebase —continue\nhexo g\nhexo s\n git push -f   \n浏览器\nmerge 更新文档步骤\n```\n\n\n\n\n","source":"_posts/git-常用命令.md","raw":"---\ntitle: git 常用命令\ncomments: true\ntags:\n  - git\ncategories:\n  - GIT\ndate: 2017-09-09 10:36:59\nupdate: 2017-09-09 10:36:59\n\n---\n\n# 版本间的切换\n\n```\ngit log --pretty=online 版本记录\n\ngit reset -hard HEAD^ 会退上一个版本\n\ngit reflog 记录每一次命令，通过commitID可以回退\n\ngit reset --hard  commitID 回退到某个版本\ngit log 可以查看提交历史确认commitID\n要重返未来，用git reflog 查看历史命令，确定版本。\n\n\n```\n\n# 三种回退文件修改内容\n\n```\n1. 修改文件，未暂存，git checkout -- file 丢弃工作区的修改\n2. 修改文件，暂存 \ngit reset HEAD file 把暂存区的修改撤销掉\ngit checkout -- file 丢弃工作区的修改\n3. 修改文件，暂存，已提交本地。使用版本回退。\n\ngit diff 查看修改与仓库的不同\n\n提交之前撤销git add\n如果只需要移除一个文件，那么请输入：\n$ git reset <文件名>\n移除所有没有提交的修改：\n$ git reset\n\n```\n\n\n#关联远程分支\n```\ngit remote add orgin git@github.com:仓库地址。\ngit push -u orgin master第一次推送master分支的所有内容，之后就可以使用 git push orgin master推送 最新修改。\n```\n\n\n# 创建并切换分支\n\n```\ngit checkout -b newbranch \n创建分支\ngit branch newbranch \n切换分支\ngit checkout branch \n```\n\n# 拉取远程分支，并创建本地之分\n\n```\ngit checkout -b branchname  orgin/branchname 在本地创建和远程对应的分支\ngit fetch origin 远程分支名x:本地分支名x。   git checkout branch\n```\n\n# 合并分支(合并dev到当前分支)\ngit merge dev\n\n# 查看分支\n\n```\ngit branch 查看本地分支\ngit branch -r 查看远程分支\n```\n\n# 推送本地分支到远程\n\n```\ngit push origin local_branch:remote_branch\ngit branch --set-upstream branchname orgin/branchname 建立本地分支与远程分支关联\n```\n\n# 删除分支\n\n```\ngit branch -d newbranch\ngit branch -D newbranch(强删)\ngit push origin --delete <branchName>  删除远程分支\n```\n\n# 修复bug\n```\n创建分支，修复bug，合并，删除。当手上工作并没有完成时，先把工作现场git stash 储藏现场工作一下，修复完后切回本分支，再git stash pop,回到现场。\ngit stash list 查看储藏的工作现场\ngit stash apply 恢复stash的内容不删除\ngit stash drop 删除储藏的内容\ngit stash pop 恢复工作现场并删除\n\ngit remove -v 查看远程仓库的信息。\ngit push origin beanch-name 推送本地分支到远程仓库，如果推送失败，先git pull远程分支\n\n```\n\n\n\n\n# 修改错误的提交信息\n\n```\ngit commit --amend -m ”YOUR-NEW-COMMIT-MESSAGE”\ngit push <remote> <branch> —force (修改推送后的提交信息)\n```\n\n# 标签\n\n```\ngit tag 查看所有标签\ngit tag v1.0 打标签\ngit tag v1.0  committID 给指定分支打标签\ngit show v1.0 查看标签信息\ngit tag -d v1.0 删除标签\ngit push orgin v1.0 推送标签到远程分支\ngit push orgin --tags  推送全部尚未推送的标签\n```\n\n## 删除已推送的远程仓库的标签\n\n```\ngit tag -d v1.0 删除标签\ngit push orgin:refs/tags/v1.0 \n```\n\n\n\n# 编写文档步骤\n\n```git checkout master  \ngit pull\ngit checkout feature-add_insurance_docs  \ngit rebase origin/master  \ngit status  \nvim  \ngit add .\ngit rebase —continue\nhexo g\nhexo s\n git push -f   \n浏览器\nmerge 更新文档步骤\n```\n\n\n\n\n","slug":"git-常用命令","published":1,"updated":"2017-09-09T02:55:09.000Z","layout":"post","photos":[],"link":"","_id":"cjd4d1a06000xryx4idqoxv4u","content":"<h1 id=\"版本间的切换\"><a href=\"#版本间的切换\" class=\"headerlink\" title=\"版本间的切换\"></a>版本间的切换</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">git log --pretty=online 版本记录</div><div class=\"line\"></div><div class=\"line\">git reset -hard HEAD^ 会退上一个版本</div><div class=\"line\"></div><div class=\"line\">git reflog 记录每一次命令，通过commitID可以回退</div><div class=\"line\"></div><div class=\"line\">git reset --hard  commitID 回退到某个版本</div><div class=\"line\">git log 可以查看提交历史确认commitID</div><div class=\"line\">要重返未来，用git reflog 查看历史命令，确定版本。</div></pre></td></tr></table></figure>\n<h1 id=\"三种回退文件修改内容\"><a href=\"#三种回退文件修改内容\" class=\"headerlink\" title=\"三种回退文件修改内容\"></a>三种回退文件修改内容</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. 修改文件，未暂存，git checkout -- file 丢弃工作区的修改</div><div class=\"line\">2. 修改文件，暂存 </div><div class=\"line\">git reset HEAD file 把暂存区的修改撤销掉</div><div class=\"line\">git checkout -- file 丢弃工作区的修改</div><div class=\"line\">3. 修改文件，暂存，已提交本地。使用版本回退。</div><div class=\"line\"></div><div class=\"line\">git diff 查看修改与仓库的不同</div><div class=\"line\"></div><div class=\"line\">提交之前撤销git add</div><div class=\"line\">如果只需要移除一个文件，那么请输入：</div><div class=\"line\">$ git reset &lt;文件名&gt;</div><div class=\"line\">移除所有没有提交的修改：</div><div class=\"line\">$ git reset</div></pre></td></tr></table></figure>\n<p>#关联远程分支<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git remote add orgin git@github.com:仓库地址。</div><div class=\"line\">git push -u orgin master第一次推送master分支的所有内容，之后就可以使用 git push orgin master推送 最新修改。</div></pre></td></tr></table></figure></p>\n<h1 id=\"创建并切换分支\"><a href=\"#创建并切换分支\" class=\"headerlink\" title=\"创建并切换分支\"></a>创建并切换分支</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">git checkout -b newbranch </div><div class=\"line\">创建分支</div><div class=\"line\">git branch newbranch </div><div class=\"line\">切换分支</div><div class=\"line\">git checkout branch</div></pre></td></tr></table></figure>\n<h1 id=\"拉取远程分支，并创建本地之分\"><a href=\"#拉取远程分支，并创建本地之分\" class=\"headerlink\" title=\"拉取远程分支，并创建本地之分\"></a>拉取远程分支，并创建本地之分</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git checkout -b branchname  orgin/branchname 在本地创建和远程对应的分支</div><div class=\"line\">git fetch origin 远程分支名x:本地分支名x。   git checkout branch</div></pre></td></tr></table></figure>\n<h1 id=\"合并分支-合并dev到当前分支\"><a href=\"#合并分支-合并dev到当前分支\" class=\"headerlink\" title=\"合并分支(合并dev到当前分支)\"></a>合并分支(合并dev到当前分支)</h1><p>git merge dev</p>\n<h1 id=\"查看分支\"><a href=\"#查看分支\" class=\"headerlink\" title=\"查看分支\"></a>查看分支</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git branch 查看本地分支</div><div class=\"line\">git branch -r 查看远程分支</div></pre></td></tr></table></figure>\n<h1 id=\"推送本地分支到远程\"><a href=\"#推送本地分支到远程\" class=\"headerlink\" title=\"推送本地分支到远程\"></a>推送本地分支到远程</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git push origin local_branch:remote_branch</div><div class=\"line\">git branch --set-upstream branchname orgin/branchname 建立本地分支与远程分支关联</div></pre></td></tr></table></figure>\n<h1 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git branch -d newbranch</div><div class=\"line\">git branch -D newbranch(强删)</div><div class=\"line\">git push origin --delete &lt;branchName&gt;  删除远程分支</div></pre></td></tr></table></figure>\n<h1 id=\"修复bug\"><a href=\"#修复bug\" class=\"headerlink\" title=\"修复bug\"></a>修复bug</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">创建分支，修复bug，合并，删除。当手上工作并没有完成时，先把工作现场git stash 储藏现场工作一下，修复完后切回本分支，再git stash pop,回到现场。</div><div class=\"line\">git stash list 查看储藏的工作现场</div><div class=\"line\">git stash apply 恢复stash的内容不删除</div><div class=\"line\">git stash drop 删除储藏的内容</div><div class=\"line\">git stash pop 恢复工作现场并删除</div><div class=\"line\"></div><div class=\"line\">git remove -v 查看远程仓库的信息。</div><div class=\"line\">git push origin beanch-name 推送本地分支到远程仓库，如果推送失败，先git pull远程分支</div></pre></td></tr></table></figure>\n<h1 id=\"修改错误的提交信息\"><a href=\"#修改错误的提交信息\" class=\"headerlink\" title=\"修改错误的提交信息\"></a>修改错误的提交信息</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git commit --amend -m ”YOUR-NEW-COMMIT-MESSAGE”</div><div class=\"line\">git push &lt;remote&gt; &lt;branch&gt; —force (修改推送后的提交信息)</div></pre></td></tr></table></figure>\n<h1 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">git tag 查看所有标签</div><div class=\"line\">git tag v1.0 打标签</div><div class=\"line\">git tag v1.0  committID 给指定分支打标签</div><div class=\"line\">git show v1.0 查看标签信息</div><div class=\"line\">git tag -d v1.0 删除标签</div><div class=\"line\">git push orgin v1.0 推送标签到远程分支</div><div class=\"line\">git push orgin --tags  推送全部尚未推送的标签</div></pre></td></tr></table></figure>\n<h2 id=\"删除已推送的远程仓库的标签\"><a href=\"#删除已推送的远程仓库的标签\" class=\"headerlink\" title=\"删除已推送的远程仓库的标签\"></a>删除已推送的远程仓库的标签</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git tag -d v1.0 删除标签</div><div class=\"line\">git push orgin:refs/tags/v1.0</div></pre></td></tr></table></figure>\n<h1 id=\"编写文档步骤\"><a href=\"#编写文档步骤\" class=\"headerlink\" title=\"编写文档步骤\"></a>编写文档步骤</h1><figure class=\"highlight plain\"><figcaption><span>checkout master  </span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">git pull</div><div class=\"line\">git checkout feature-add_insurance_docs  </div><div class=\"line\">git rebase origin/master  </div><div class=\"line\">git status  </div><div class=\"line\">vim  </div><div class=\"line\">git add .</div><div class=\"line\">git rebase —continue</div><div class=\"line\">hexo g</div><div class=\"line\">hexo s</div><div class=\"line\"> git push -f   </div><div class=\"line\">浏览器</div><div class=\"line\">merge 更新文档步骤</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"版本间的切换\"><a href=\"#版本间的切换\" class=\"headerlink\" title=\"版本间的切换\"></a>版本间的切换</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">git log --pretty=online 版本记录</div><div class=\"line\"></div><div class=\"line\">git reset -hard HEAD^ 会退上一个版本</div><div class=\"line\"></div><div class=\"line\">git reflog 记录每一次命令，通过commitID可以回退</div><div class=\"line\"></div><div class=\"line\">git reset --hard  commitID 回退到某个版本</div><div class=\"line\">git log 可以查看提交历史确认commitID</div><div class=\"line\">要重返未来，用git reflog 查看历史命令，确定版本。</div></pre></td></tr></table></figure>\n<h1 id=\"三种回退文件修改内容\"><a href=\"#三种回退文件修改内容\" class=\"headerlink\" title=\"三种回退文件修改内容\"></a>三种回退文件修改内容</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. 修改文件，未暂存，git checkout -- file 丢弃工作区的修改</div><div class=\"line\">2. 修改文件，暂存 </div><div class=\"line\">git reset HEAD file 把暂存区的修改撤销掉</div><div class=\"line\">git checkout -- file 丢弃工作区的修改</div><div class=\"line\">3. 修改文件，暂存，已提交本地。使用版本回退。</div><div class=\"line\"></div><div class=\"line\">git diff 查看修改与仓库的不同</div><div class=\"line\"></div><div class=\"line\">提交之前撤销git add</div><div class=\"line\">如果只需要移除一个文件，那么请输入：</div><div class=\"line\">$ git reset &lt;文件名&gt;</div><div class=\"line\">移除所有没有提交的修改：</div><div class=\"line\">$ git reset</div></pre></td></tr></table></figure>\n<p>#关联远程分支<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git remote add orgin git@github.com:仓库地址。</div><div class=\"line\">git push -u orgin master第一次推送master分支的所有内容，之后就可以使用 git push orgin master推送 最新修改。</div></pre></td></tr></table></figure></p>\n<h1 id=\"创建并切换分支\"><a href=\"#创建并切换分支\" class=\"headerlink\" title=\"创建并切换分支\"></a>创建并切换分支</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">git checkout -b newbranch </div><div class=\"line\">创建分支</div><div class=\"line\">git branch newbranch </div><div class=\"line\">切换分支</div><div class=\"line\">git checkout branch</div></pre></td></tr></table></figure>\n<h1 id=\"拉取远程分支，并创建本地之分\"><a href=\"#拉取远程分支，并创建本地之分\" class=\"headerlink\" title=\"拉取远程分支，并创建本地之分\"></a>拉取远程分支，并创建本地之分</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git checkout -b branchname  orgin/branchname 在本地创建和远程对应的分支</div><div class=\"line\">git fetch origin 远程分支名x:本地分支名x。   git checkout branch</div></pre></td></tr></table></figure>\n<h1 id=\"合并分支-合并dev到当前分支\"><a href=\"#合并分支-合并dev到当前分支\" class=\"headerlink\" title=\"合并分支(合并dev到当前分支)\"></a>合并分支(合并dev到当前分支)</h1><p>git merge dev</p>\n<h1 id=\"查看分支\"><a href=\"#查看分支\" class=\"headerlink\" title=\"查看分支\"></a>查看分支</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git branch 查看本地分支</div><div class=\"line\">git branch -r 查看远程分支</div></pre></td></tr></table></figure>\n<h1 id=\"推送本地分支到远程\"><a href=\"#推送本地分支到远程\" class=\"headerlink\" title=\"推送本地分支到远程\"></a>推送本地分支到远程</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git push origin local_branch:remote_branch</div><div class=\"line\">git branch --set-upstream branchname orgin/branchname 建立本地分支与远程分支关联</div></pre></td></tr></table></figure>\n<h1 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git branch -d newbranch</div><div class=\"line\">git branch -D newbranch(强删)</div><div class=\"line\">git push origin --delete &lt;branchName&gt;  删除远程分支</div></pre></td></tr></table></figure>\n<h1 id=\"修复bug\"><a href=\"#修复bug\" class=\"headerlink\" title=\"修复bug\"></a>修复bug</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">创建分支，修复bug，合并，删除。当手上工作并没有完成时，先把工作现场git stash 储藏现场工作一下，修复完后切回本分支，再git stash pop,回到现场。</div><div class=\"line\">git stash list 查看储藏的工作现场</div><div class=\"line\">git stash apply 恢复stash的内容不删除</div><div class=\"line\">git stash drop 删除储藏的内容</div><div class=\"line\">git stash pop 恢复工作现场并删除</div><div class=\"line\"></div><div class=\"line\">git remove -v 查看远程仓库的信息。</div><div class=\"line\">git push origin beanch-name 推送本地分支到远程仓库，如果推送失败，先git pull远程分支</div></pre></td></tr></table></figure>\n<h1 id=\"修改错误的提交信息\"><a href=\"#修改错误的提交信息\" class=\"headerlink\" title=\"修改错误的提交信息\"></a>修改错误的提交信息</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git commit --amend -m ”YOUR-NEW-COMMIT-MESSAGE”</div><div class=\"line\">git push &lt;remote&gt; &lt;branch&gt; —force (修改推送后的提交信息)</div></pre></td></tr></table></figure>\n<h1 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">git tag 查看所有标签</div><div class=\"line\">git tag v1.0 打标签</div><div class=\"line\">git tag v1.0  committID 给指定分支打标签</div><div class=\"line\">git show v1.0 查看标签信息</div><div class=\"line\">git tag -d v1.0 删除标签</div><div class=\"line\">git push orgin v1.0 推送标签到远程分支</div><div class=\"line\">git push orgin --tags  推送全部尚未推送的标签</div></pre></td></tr></table></figure>\n<h2 id=\"删除已推送的远程仓库的标签\"><a href=\"#删除已推送的远程仓库的标签\" class=\"headerlink\" title=\"删除已推送的远程仓库的标签\"></a>删除已推送的远程仓库的标签</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git tag -d v1.0 删除标签</div><div class=\"line\">git push orgin:refs/tags/v1.0</div></pre></td></tr></table></figure>\n<h1 id=\"编写文档步骤\"><a href=\"#编写文档步骤\" class=\"headerlink\" title=\"编写文档步骤\"></a>编写文档步骤</h1><figure class=\"highlight plain\"><figcaption><span>checkout master  </span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">git pull</div><div class=\"line\">git checkout feature-add_insurance_docs  </div><div class=\"line\">git rebase origin/master  </div><div class=\"line\">git status  </div><div class=\"line\">vim  </div><div class=\"line\">git add .</div><div class=\"line\">git rebase —continue</div><div class=\"line\">hexo g</div><div class=\"line\">hexo s</div><div class=\"line\"> git push -f   </div><div class=\"line\">浏览器</div><div class=\"line\">merge 更新文档步骤</div></pre></td></tr></table></figure>\n"},{"title":"linux 基础常识","comments":1,"date":"2017-03-05T10:18:13.000Z","update":"2017-03-05T10:18:13.000Z","_content":"\n# 概要\n\n1. Linux可划分为：linux内核、GNU工具、图形化桌面环境、应用软件。\r2. 内核主要负责：系统内存管理、软件程序管理、硬件设备管理、文件系统管理。\r3. 交换空间：内核通过硬盘上的存储空间来实现虚拟内存的这块区域。\n\r# linux内核\n\r## 1.内存管理:\n分段分页\n\r## 2.软件程序管理：\n\n内核控制着linux系统如何管理运行在系统上的所有进程。内核创建的第一个进程称为init进程，它是用来启动系统上所有其他进程的。当内核启动时，它会将init进程加载到虚拟内存中。内核在启动任何其他进程，都会在虚拟内存中给新进程分配一块专有的区域来存储该进程用到的数据和代码。\n\r一些linux发行版使用一个表来管理在系统开机时要启动的进程。在linux上这个表通常位于专门文件/etc/inittab中。Ubuntu则采用/etc/init.d目录，将开机时启动或者停止某个应用脚本放在这个目录下。这个脚本通过/etc/rcX.d目录下的入口启动，这里X代表运行级别。Linux操作系统的init系统采用了运行级别。运行级别决定了init进程运行/etc/inittab文件或/etc/rcX.d目录中定义好的某些特定的进程。Linux操作系统有5个启动运行级别。\n\r运行级别为一时，只启动基本的系统进程以及一个控制台终端进程，我们称之为单用户模式。单用户模式通常用来在系统有问题的时候进行紧急的文件系统维护。\n\r标准的启动运行级别是3，在这个运行级别上，大多数应用软件，比如网络支持程序都会启动。\r运行级别5上系统启动图形化的X window系统，允许用户通过图形化桌面窗口登录系统。\n\r3.\t硬件设备管理：任何linux系统需要与之通讯的设备，都需要在内核代码中加入其驱动程序代码。驱动程序代码相当于应用程序和硬件设备的中间人，允许内核与设备之间交互数据。在linux内核中有两种方法用于插入设备驱动的代码，第一，编译进内核的设备驱动代码，第二，可插入内核的设备驱动代码。\rLinux将硬件设备当成特殊的文件，称为设备文件。设备文件有：字符型设备文件、块设备文件、网络设备文件。\n\r4.\t文件系统管理：linux内核支持不同类型的文件系统从硬盘中读取数据。\n\n| 类型 | 描述 |\n|-----|:---|\r| Ext |Linux 扩展文件系统，最早的linux文件系统 |\n| Ext2 | 第二扩展文件系统，在ext的基础上提供了更多的功能。|\r| Ext3 | 第三扩展文件系统，支持日志功能。|\r| Ext4 | 第四扩展文件系统，支持高级日志功能。|\r| Hpfs | Os/2高性能文件系统。|\r| Nfs | 网络文件系统 |\r| Proc | 访问系统信息 |\r| ReiserFS |高级linux文件系统，能够提供更好的性能和硬盘恢复功能 |\r\rLinux内核采用虚拟文件系统（VFS）作为和每个文件系统交互的接口。这为linux内核同任何类型的文件系统通信提供了一个标准的接口。当每个文件系统都被挂载和使用的时候，VFS将信息都缓存在内存中。\n\r# GNU工具\rGNU(GNU‘s Not Unix 的缩写) linux 内核和GNU工具的结合成为linux\n\r1.\t核心GNU工具：GNU项目的主旨在于为UNIX系统管理员设计出一套类似于UNIX的环境。这个目标促使该项目移植了很多常见的unix系统命令行工具。供linux系统使用的这组核心工具被称为coreutils(core utilities)软件包。它由三部分构成：处理文件的工具、操作文本的工具、管理进程的工具。\r2.\tShell\rGNU/Linux shell是一种特殊的交互式工具。它为用户提供了启动程序、管理文件系统中的文件以及运行在linux系统上的进程的途径。Shell的核心是命令提示符。命令提示符是设立负责交互的部分。它允许你输入文本命令，然后解释命令，并在内核中运行。\r\t\tShell包含一组内部命令，它也允许你输入程序的名称，将程序名称传递给内核以启动它。\r\t\t所有linux发行版本默认的shell都是bash shell。Bash shell 由GNU项目开发，被当作标准的Unix shell(bourne shell以创建者命名)的替代品。Bash shell 的名字就是针对bourne shell 的拼写玩的一个文字游戏，称为bourne again shell。\n\t\t\n| shell | 描述 |\n|-------|:---|\t\t\r| Ash |一个运行在内存受限环境中简单的轻量级的shell，但和bash shell 完全兼容\r| Korn |一种与bourne shell 兼容的编程shell，但支持一些高级编程特性：关联数组和浮点运算\r| Tcsh |一种将C语言中的一些元素引入shell脚本中的shell。|\r| Zsh |一种结合了bash tcsh korn 的特性，同时提供了高级编程特性，共享历史文件和主题的高级shell。|\r\r\r# linux桌面环境\n\r1.\tx window系统:它是直接和PC上的显示器以及显卡打交道的底层程序。它控制这linux程序如何在电脑上显示漂亮的窗口和图形。\r2.\tKDE(K Desktop Enivironment): 它允许你把应用程序图标和文件图标放置在桌面上。单击应用程序图标，linux就会运行该应用程序。\r3.\tGNOME（the GNU Network Object Model Environment, GNU网络对象模型环境），用的最多是Red Hat Linux.\r4.\tUnity桌面：ubuntu的桌面环境。目标为工作站、平板电脑以及移动设备提供一致的桌面体验。\r\r\r\r\r# Linux发行版通常分为三类：\r1.\t完整的核心linux发行版\r2.\t特定用途的发行版\r3.\tLiveCD测试发行版\n\r## 核心linux发行版\n含有内核、一个多个图形化桌面环境以编译好的几乎所有能见到的linux应用。它提供了一站式完整的安装。比较流行的版本有\n\r| 发行版 | 描述|\n|-------|:-----|\r| Debian| 在linux专家和商用linux产品中流行的发行版。|\r| OpenSUSE | 用于商用和家用的发行版 |\r| Slackware | 最早的linux发行版的一员，在linux极客中比较流行。|\r| Red Hat | 主要用于Internet服务器的商业发行版|\r| Fedora | 从RedHat分离出的家用发行版|\r| Gentoo| 为高级linux用户设计的发行版，仅包含Linux源码。|\n\r## 特殊用途的linux发行版：\n\n他们通常基于某个主流发行版，但仅包含主流发行版的一小部分用于某种特定用途的应用程序。定制化发行版还尝试通过自动检测和自动配置常见的硬件来帮助新手安装linux。\n\r| 发行版  | 描述                                    |\n|--------|:--------------------------------------|\r| Centos | 基于Red Hat企业版linux源代码构建的免费发行版 |\r| Ubuntu | 用于学校和家庭的免费发行版 |\r| PClinuxOS |  用于家庭和办公 |\r| Mint | 用于家庭娱乐 |\r\r \r","source":"_posts/linux-基础常识.md","raw":"---\ntitle: linux 基础常识\ncomments: true\ntags:\n  - LINUX\ncategories:\n  - LINUX\ndate: 2017-03-05 18:18:13\nupdate: 2017-03-05 18:18:13\n---\n\n# 概要\n\n1. Linux可划分为：linux内核、GNU工具、图形化桌面环境、应用软件。\r2. 内核主要负责：系统内存管理、软件程序管理、硬件设备管理、文件系统管理。\r3. 交换空间：内核通过硬盘上的存储空间来实现虚拟内存的这块区域。\n\r# linux内核\n\r## 1.内存管理:\n分段分页\n\r## 2.软件程序管理：\n\n内核控制着linux系统如何管理运行在系统上的所有进程。内核创建的第一个进程称为init进程，它是用来启动系统上所有其他进程的。当内核启动时，它会将init进程加载到虚拟内存中。内核在启动任何其他进程，都会在虚拟内存中给新进程分配一块专有的区域来存储该进程用到的数据和代码。\n\r一些linux发行版使用一个表来管理在系统开机时要启动的进程。在linux上这个表通常位于专门文件/etc/inittab中。Ubuntu则采用/etc/init.d目录，将开机时启动或者停止某个应用脚本放在这个目录下。这个脚本通过/etc/rcX.d目录下的入口启动，这里X代表运行级别。Linux操作系统的init系统采用了运行级别。运行级别决定了init进程运行/etc/inittab文件或/etc/rcX.d目录中定义好的某些特定的进程。Linux操作系统有5个启动运行级别。\n\r运行级别为一时，只启动基本的系统进程以及一个控制台终端进程，我们称之为单用户模式。单用户模式通常用来在系统有问题的时候进行紧急的文件系统维护。\n\r标准的启动运行级别是3，在这个运行级别上，大多数应用软件，比如网络支持程序都会启动。\r运行级别5上系统启动图形化的X window系统，允许用户通过图形化桌面窗口登录系统。\n\r3.\t硬件设备管理：任何linux系统需要与之通讯的设备，都需要在内核代码中加入其驱动程序代码。驱动程序代码相当于应用程序和硬件设备的中间人，允许内核与设备之间交互数据。在linux内核中有两种方法用于插入设备驱动的代码，第一，编译进内核的设备驱动代码，第二，可插入内核的设备驱动代码。\rLinux将硬件设备当成特殊的文件，称为设备文件。设备文件有：字符型设备文件、块设备文件、网络设备文件。\n\r4.\t文件系统管理：linux内核支持不同类型的文件系统从硬盘中读取数据。\n\n| 类型 | 描述 |\n|-----|:---|\r| Ext |Linux 扩展文件系统，最早的linux文件系统 |\n| Ext2 | 第二扩展文件系统，在ext的基础上提供了更多的功能。|\r| Ext3 | 第三扩展文件系统，支持日志功能。|\r| Ext4 | 第四扩展文件系统，支持高级日志功能。|\r| Hpfs | Os/2高性能文件系统。|\r| Nfs | 网络文件系统 |\r| Proc | 访问系统信息 |\r| ReiserFS |高级linux文件系统，能够提供更好的性能和硬盘恢复功能 |\r\rLinux内核采用虚拟文件系统（VFS）作为和每个文件系统交互的接口。这为linux内核同任何类型的文件系统通信提供了一个标准的接口。当每个文件系统都被挂载和使用的时候，VFS将信息都缓存在内存中。\n\r# GNU工具\rGNU(GNU‘s Not Unix 的缩写) linux 内核和GNU工具的结合成为linux\n\r1.\t核心GNU工具：GNU项目的主旨在于为UNIX系统管理员设计出一套类似于UNIX的环境。这个目标促使该项目移植了很多常见的unix系统命令行工具。供linux系统使用的这组核心工具被称为coreutils(core utilities)软件包。它由三部分构成：处理文件的工具、操作文本的工具、管理进程的工具。\r2.\tShell\rGNU/Linux shell是一种特殊的交互式工具。它为用户提供了启动程序、管理文件系统中的文件以及运行在linux系统上的进程的途径。Shell的核心是命令提示符。命令提示符是设立负责交互的部分。它允许你输入文本命令，然后解释命令，并在内核中运行。\r\t\tShell包含一组内部命令，它也允许你输入程序的名称，将程序名称传递给内核以启动它。\r\t\t所有linux发行版本默认的shell都是bash shell。Bash shell 由GNU项目开发，被当作标准的Unix shell(bourne shell以创建者命名)的替代品。Bash shell 的名字就是针对bourne shell 的拼写玩的一个文字游戏，称为bourne again shell。\n\t\t\n| shell | 描述 |\n|-------|:---|\t\t\r| Ash |一个运行在内存受限环境中简单的轻量级的shell，但和bash shell 完全兼容\r| Korn |一种与bourne shell 兼容的编程shell，但支持一些高级编程特性：关联数组和浮点运算\r| Tcsh |一种将C语言中的一些元素引入shell脚本中的shell。|\r| Zsh |一种结合了bash tcsh korn 的特性，同时提供了高级编程特性，共享历史文件和主题的高级shell。|\r\r\r# linux桌面环境\n\r1.\tx window系统:它是直接和PC上的显示器以及显卡打交道的底层程序。它控制这linux程序如何在电脑上显示漂亮的窗口和图形。\r2.\tKDE(K Desktop Enivironment): 它允许你把应用程序图标和文件图标放置在桌面上。单击应用程序图标，linux就会运行该应用程序。\r3.\tGNOME（the GNU Network Object Model Environment, GNU网络对象模型环境），用的最多是Red Hat Linux.\r4.\tUnity桌面：ubuntu的桌面环境。目标为工作站、平板电脑以及移动设备提供一致的桌面体验。\r\r\r\r\r# Linux发行版通常分为三类：\r1.\t完整的核心linux发行版\r2.\t特定用途的发行版\r3.\tLiveCD测试发行版\n\r## 核心linux发行版\n含有内核、一个多个图形化桌面环境以编译好的几乎所有能见到的linux应用。它提供了一站式完整的安装。比较流行的版本有\n\r| 发行版 | 描述|\n|-------|:-----|\r| Debian| 在linux专家和商用linux产品中流行的发行版。|\r| OpenSUSE | 用于商用和家用的发行版 |\r| Slackware | 最早的linux发行版的一员，在linux极客中比较流行。|\r| Red Hat | 主要用于Internet服务器的商业发行版|\r| Fedora | 从RedHat分离出的家用发行版|\r| Gentoo| 为高级linux用户设计的发行版，仅包含Linux源码。|\n\r## 特殊用途的linux发行版：\n\n他们通常基于某个主流发行版，但仅包含主流发行版的一小部分用于某种特定用途的应用程序。定制化发行版还尝试通过自动检测和自动配置常见的硬件来帮助新手安装linux。\n\r| 发行版  | 描述                                    |\n|--------|:--------------------------------------|\r| Centos | 基于Red Hat企业版linux源代码构建的免费发行版 |\r| Ubuntu | 用于学校和家庭的免费发行版 |\r| PClinuxOS |  用于家庭和办公 |\r| Mint | 用于家庭娱乐 |\r\r \r","slug":"linux-基础常识","published":1,"updated":"2017-09-02T10:12:42.000Z","layout":"post","photos":[],"link":"","_id":"cjd4d1a070011ryx4wnr3poi1","content":"<h1 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h1><ol>\n<li>Linux可划分为：linux内核、GNU工具、图形化桌面环境、应用软件。</li>\n<li>内核主要负责：系统内存管理、软件程序管理、硬件设备管理、文件系统管理。</li>\n<li>交换空间：内核通过硬盘上的存储空间来实现虚拟内存的这块区域。</li>\n</ol>\n<h1 id=\"linux内核\"><a href=\"#linux内核\" class=\"headerlink\" title=\"linux内核\"></a>linux内核</h1><h2 id=\"1-内存管理\"><a href=\"#1-内存管理\" class=\"headerlink\" title=\"1.内存管理:\"></a>1.内存管理:</h2><p>分段分页</p>\n<h2 id=\"2-软件程序管理：\"><a href=\"#2-软件程序管理：\" class=\"headerlink\" title=\"2.软件程序管理：\"></a>2.软件程序管理：</h2><p>内核控制着linux系统如何管理运行在系统上的所有进程。内核创建的第一个进程称为init进程，它是用来启动系统上所有其他进程的。当内核启动时，它会将init进程加载到虚拟内存中。内核在启动任何其他进程，都会在虚拟内存中给新进程分配一块专有的区域来存储该进程用到的数据和代码。</p>\n<p>一些linux发行版使用一个表来管理在系统开机时要启动的进程。在linux上这个表通常位于专门文件/etc/inittab中。Ubuntu则采用/etc/init.d目录，将开机时启动或者停止某个应用脚本放在这个目录下。这个脚本通过/etc/rcX.d目录下的入口启动，这里X代表运行级别。Linux操作系统的init系统采用了运行级别。运行级别决定了init进程运行/etc/inittab文件或/etc/rcX.d目录中定义好的某些特定的进程。Linux操作系统有5个启动运行级别。</p>\n<p>运行级别为一时，只启动基本的系统进程以及一个控制台终端进程，我们称之为单用户模式。单用户模式通常用来在系统有问题的时候进行紧急的文件系统维护。</p>\n<p>标准的启动运行级别是3，在这个运行级别上，大多数应用软件，比如网络支持程序都会启动。<br>运行级别5上系统启动图形化的X window系统，允许用户通过图形化桌面窗口登录系统。</p>\n<ol>\n<li><p>硬件设备管理：任何linux系统需要与之通讯的设备，都需要在内核代码中加入其驱动程序代码。驱动程序代码相当于应用程序和硬件设备的中间人，允许内核与设备之间交互数据。在linux内核中有两种方法用于插入设备驱动的代码，第一，编译进内核的设备驱动代码，第二，可插入内核的设备驱动代码。<br>Linux将硬件设备当成特殊的文件，称为设备文件。设备文件有：字符型设备文件、块设备文件、网络设备文件。</p>\n</li>\n<li><p>文件系统管理：linux内核支持不同类型的文件系统从硬盘中读取数据。</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Ext</td>\n<td style=\"text-align:left\">Linux 扩展文件系统，最早的linux文件系统</td>\n</tr>\n<tr>\n<td>Ext2</td>\n<td style=\"text-align:left\">第二扩展文件系统，在ext的基础上提供了更多的功能。</td>\n</tr>\n<tr>\n<td>Ext3</td>\n<td style=\"text-align:left\">第三扩展文件系统，支持日志功能。</td>\n</tr>\n<tr>\n<td>Ext4</td>\n<td style=\"text-align:left\">第四扩展文件系统，支持高级日志功能。</td>\n</tr>\n<tr>\n<td>Hpfs</td>\n<td style=\"text-align:left\">Os/2高性能文件系统。</td>\n</tr>\n<tr>\n<td>Nfs</td>\n<td style=\"text-align:left\">网络文件系统</td>\n</tr>\n<tr>\n<td>Proc</td>\n<td style=\"text-align:left\">访问系统信息</td>\n</tr>\n<tr>\n<td>ReiserFS</td>\n<td style=\"text-align:left\">高级linux文件系统，能够提供更好的性能和硬盘恢复功能</td>\n</tr>\n</tbody>\n</table>\n<p>Linux内核采用虚拟文件系统（VFS）作为和每个文件系统交互的接口。这为linux内核同任何类型的文件系统通信提供了一个标准的接口。当每个文件系统都被挂载和使用的时候，VFS将信息都缓存在内存中。</p>\n<h1 id=\"GNU工具\"><a href=\"#GNU工具\" class=\"headerlink\" title=\"GNU工具\"></a>GNU工具</h1><p>GNU(GNU‘s Not Unix 的缩写) linux 内核和GNU工具的结合成为linux</p>\n<ol>\n<li>核心GNU工具：GNU项目的主旨在于为UNIX系统管理员设计出一套类似于UNIX的环境。这个目标促使该项目移植了很多常见的unix系统命令行工具。供linux系统使用的这组核心工具被称为coreutils(core utilities)软件包。它由三部分构成：处理文件的工具、操作文本的工具、管理进程的工具。</li>\n<li>Shell<br>GNU/Linux shell是一种特殊的交互式工具。它为用户提供了启动程序、管理文件系统中的文件以及运行在linux系统上的进程的途径。Shell的核心是命令提示符。命令提示符是设立负责交互的部分。它允许你输入文本命令，然后解释命令，并在内核中运行。<br>  Shell包含一组内部命令，它也允许你输入程序的名称，将程序名称传递给内核以启动它。<br>  所有linux发行版本默认的shell都是bash shell。Bash shell 由GNU项目开发，被当作标准的Unix shell(bourne shell以创建者命名)的替代品。Bash shell 的名字就是针对bourne shell 的拼写玩的一个文字游戏，称为bourne again shell。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>shell</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Ash</td>\n<td style=\"text-align:left\">一个运行在内存受限环境中简单的轻量级的shell，但和bash shell 完全兼容</td>\n</tr>\n<tr>\n<td>Korn</td>\n<td style=\"text-align:left\">一种与bourne shell 兼容的编程shell，但支持一些高级编程特性：关联数组和浮点运算</td>\n</tr>\n<tr>\n<td>Tcsh</td>\n<td style=\"text-align:left\">一种将C语言中的一些元素引入shell脚本中的shell。</td>\n</tr>\n<tr>\n<td>Zsh</td>\n<td style=\"text-align:left\">一种结合了bash tcsh korn 的特性，同时提供了高级编程特性，共享历史文件和主题的高级shell。</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"linux桌面环境\"><a href=\"#linux桌面环境\" class=\"headerlink\" title=\"linux桌面环境\"></a>linux桌面环境</h1><ol>\n<li>x window系统:它是直接和PC上的显示器以及显卡打交道的底层程序。它控制这linux程序如何在电脑上显示漂亮的窗口和图形。</li>\n<li>KDE(K Desktop Enivironment): 它允许你把应用程序图标和文件图标放置在桌面上。单击应用程序图标，linux就会运行该应用程序。</li>\n<li>GNOME（the GNU Network Object Model Environment, GNU网络对象模型环境），用的最多是Red Hat Linux.</li>\n<li>Unity桌面：ubuntu的桌面环境。目标为工作站、平板电脑以及移动设备提供一致的桌面体验。</li>\n</ol>\n<h1 id=\"Linux发行版通常分为三类：\"><a href=\"#Linux发行版通常分为三类：\" class=\"headerlink\" title=\"Linux发行版通常分为三类：\"></a>Linux发行版通常分为三类：</h1><ol>\n<li>完整的核心linux发行版</li>\n<li>特定用途的发行版</li>\n<li>LiveCD测试发行版</li>\n</ol>\n<h2 id=\"核心linux发行版\"><a href=\"#核心linux发行版\" class=\"headerlink\" title=\"核心linux发行版\"></a>核心linux发行版</h2><p>含有内核、一个多个图形化桌面环境以编译好的几乎所有能见到的linux应用。它提供了一站式完整的安装。比较流行的版本有</p>\n<table>\n<thead>\n<tr>\n<th>发行版</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Debian</td>\n<td style=\"text-align:left\">在linux专家和商用linux产品中流行的发行版。</td>\n</tr>\n<tr>\n<td>OpenSUSE</td>\n<td style=\"text-align:left\">用于商用和家用的发行版</td>\n</tr>\n<tr>\n<td>Slackware</td>\n<td style=\"text-align:left\">最早的linux发行版的一员，在linux极客中比较流行。</td>\n</tr>\n<tr>\n<td>Red Hat</td>\n<td style=\"text-align:left\">主要用于Internet服务器的商业发行版</td>\n</tr>\n<tr>\n<td>Fedora</td>\n<td style=\"text-align:left\">从RedHat分离出的家用发行版</td>\n</tr>\n<tr>\n<td>Gentoo</td>\n<td style=\"text-align:left\">为高级linux用户设计的发行版，仅包含Linux源码。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"特殊用途的linux发行版：\"><a href=\"#特殊用途的linux发行版：\" class=\"headerlink\" title=\"特殊用途的linux发行版：\"></a>特殊用途的linux发行版：</h2><p>他们通常基于某个主流发行版，但仅包含主流发行版的一小部分用于某种特定用途的应用程序。定制化发行版还尝试通过自动检测和自动配置常见的硬件来帮助新手安装linux。</p>\n<table>\n<thead>\n<tr>\n<th>发行版</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Centos</td>\n<td style=\"text-align:left\">基于Red Hat企业版linux源代码构建的免费发行版</td>\n</tr>\n<tr>\n<td>Ubuntu</td>\n<td style=\"text-align:left\">用于学校和家庭的免费发行版</td>\n</tr>\n<tr>\n<td>PClinuxOS</td>\n<td style=\"text-align:left\">用于家庭和办公</td>\n</tr>\n<tr>\n<td>Mint</td>\n<td style=\"text-align:left\">用于家庭娱乐</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h1><ol>\n<li>Linux可划分为：linux内核、GNU工具、图形化桌面环境、应用软件。</li>\n<li>内核主要负责：系统内存管理、软件程序管理、硬件设备管理、文件系统管理。</li>\n<li>交换空间：内核通过硬盘上的存储空间来实现虚拟内存的这块区域。</li>\n</ol>\n<h1 id=\"linux内核\"><a href=\"#linux内核\" class=\"headerlink\" title=\"linux内核\"></a>linux内核</h1><h2 id=\"1-内存管理\"><a href=\"#1-内存管理\" class=\"headerlink\" title=\"1.内存管理:\"></a>1.内存管理:</h2><p>分段分页</p>\n<h2 id=\"2-软件程序管理：\"><a href=\"#2-软件程序管理：\" class=\"headerlink\" title=\"2.软件程序管理：\"></a>2.软件程序管理：</h2><p>内核控制着linux系统如何管理运行在系统上的所有进程。内核创建的第一个进程称为init进程，它是用来启动系统上所有其他进程的。当内核启动时，它会将init进程加载到虚拟内存中。内核在启动任何其他进程，都会在虚拟内存中给新进程分配一块专有的区域来存储该进程用到的数据和代码。</p>\n<p>一些linux发行版使用一个表来管理在系统开机时要启动的进程。在linux上这个表通常位于专门文件/etc/inittab中。Ubuntu则采用/etc/init.d目录，将开机时启动或者停止某个应用脚本放在这个目录下。这个脚本通过/etc/rcX.d目录下的入口启动，这里X代表运行级别。Linux操作系统的init系统采用了运行级别。运行级别决定了init进程运行/etc/inittab文件或/etc/rcX.d目录中定义好的某些特定的进程。Linux操作系统有5个启动运行级别。</p>\n<p>运行级别为一时，只启动基本的系统进程以及一个控制台终端进程，我们称之为单用户模式。单用户模式通常用来在系统有问题的时候进行紧急的文件系统维护。</p>\n<p>标准的启动运行级别是3，在这个运行级别上，大多数应用软件，比如网络支持程序都会启动。<br>运行级别5上系统启动图形化的X window系统，允许用户通过图形化桌面窗口登录系统。</p>\n<ol>\n<li><p>硬件设备管理：任何linux系统需要与之通讯的设备，都需要在内核代码中加入其驱动程序代码。驱动程序代码相当于应用程序和硬件设备的中间人，允许内核与设备之间交互数据。在linux内核中有两种方法用于插入设备驱动的代码，第一，编译进内核的设备驱动代码，第二，可插入内核的设备驱动代码。<br>Linux将硬件设备当成特殊的文件，称为设备文件。设备文件有：字符型设备文件、块设备文件、网络设备文件。</p>\n</li>\n<li><p>文件系统管理：linux内核支持不同类型的文件系统从硬盘中读取数据。</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Ext</td>\n<td style=\"text-align:left\">Linux 扩展文件系统，最早的linux文件系统</td>\n</tr>\n<tr>\n<td>Ext2</td>\n<td style=\"text-align:left\">第二扩展文件系统，在ext的基础上提供了更多的功能。</td>\n</tr>\n<tr>\n<td>Ext3</td>\n<td style=\"text-align:left\">第三扩展文件系统，支持日志功能。</td>\n</tr>\n<tr>\n<td>Ext4</td>\n<td style=\"text-align:left\">第四扩展文件系统，支持高级日志功能。</td>\n</tr>\n<tr>\n<td>Hpfs</td>\n<td style=\"text-align:left\">Os/2高性能文件系统。</td>\n</tr>\n<tr>\n<td>Nfs</td>\n<td style=\"text-align:left\">网络文件系统</td>\n</tr>\n<tr>\n<td>Proc</td>\n<td style=\"text-align:left\">访问系统信息</td>\n</tr>\n<tr>\n<td>ReiserFS</td>\n<td style=\"text-align:left\">高级linux文件系统，能够提供更好的性能和硬盘恢复功能</td>\n</tr>\n</tbody>\n</table>\n<p>Linux内核采用虚拟文件系统（VFS）作为和每个文件系统交互的接口。这为linux内核同任何类型的文件系统通信提供了一个标准的接口。当每个文件系统都被挂载和使用的时候，VFS将信息都缓存在内存中。</p>\n<h1 id=\"GNU工具\"><a href=\"#GNU工具\" class=\"headerlink\" title=\"GNU工具\"></a>GNU工具</h1><p>GNU(GNU‘s Not Unix 的缩写) linux 内核和GNU工具的结合成为linux</p>\n<ol>\n<li>核心GNU工具：GNU项目的主旨在于为UNIX系统管理员设计出一套类似于UNIX的环境。这个目标促使该项目移植了很多常见的unix系统命令行工具。供linux系统使用的这组核心工具被称为coreutils(core utilities)软件包。它由三部分构成：处理文件的工具、操作文本的工具、管理进程的工具。</li>\n<li>Shell<br>GNU/Linux shell是一种特殊的交互式工具。它为用户提供了启动程序、管理文件系统中的文件以及运行在linux系统上的进程的途径。Shell的核心是命令提示符。命令提示符是设立负责交互的部分。它允许你输入文本命令，然后解释命令，并在内核中运行。<br>  Shell包含一组内部命令，它也允许你输入程序的名称，将程序名称传递给内核以启动它。<br>  所有linux发行版本默认的shell都是bash shell。Bash shell 由GNU项目开发，被当作标准的Unix shell(bourne shell以创建者命名)的替代品。Bash shell 的名字就是针对bourne shell 的拼写玩的一个文字游戏，称为bourne again shell。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>shell</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Ash</td>\n<td style=\"text-align:left\">一个运行在内存受限环境中简单的轻量级的shell，但和bash shell 完全兼容</td>\n</tr>\n<tr>\n<td>Korn</td>\n<td style=\"text-align:left\">一种与bourne shell 兼容的编程shell，但支持一些高级编程特性：关联数组和浮点运算</td>\n</tr>\n<tr>\n<td>Tcsh</td>\n<td style=\"text-align:left\">一种将C语言中的一些元素引入shell脚本中的shell。</td>\n</tr>\n<tr>\n<td>Zsh</td>\n<td style=\"text-align:left\">一种结合了bash tcsh korn 的特性，同时提供了高级编程特性，共享历史文件和主题的高级shell。</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"linux桌面环境\"><a href=\"#linux桌面环境\" class=\"headerlink\" title=\"linux桌面环境\"></a>linux桌面环境</h1><ol>\n<li>x window系统:它是直接和PC上的显示器以及显卡打交道的底层程序。它控制这linux程序如何在电脑上显示漂亮的窗口和图形。</li>\n<li>KDE(K Desktop Enivironment): 它允许你把应用程序图标和文件图标放置在桌面上。单击应用程序图标，linux就会运行该应用程序。</li>\n<li>GNOME（the GNU Network Object Model Environment, GNU网络对象模型环境），用的最多是Red Hat Linux.</li>\n<li>Unity桌面：ubuntu的桌面环境。目标为工作站、平板电脑以及移动设备提供一致的桌面体验。</li>\n</ol>\n<h1 id=\"Linux发行版通常分为三类：\"><a href=\"#Linux发行版通常分为三类：\" class=\"headerlink\" title=\"Linux发行版通常分为三类：\"></a>Linux发行版通常分为三类：</h1><ol>\n<li>完整的核心linux发行版</li>\n<li>特定用途的发行版</li>\n<li>LiveCD测试发行版</li>\n</ol>\n<h2 id=\"核心linux发行版\"><a href=\"#核心linux发行版\" class=\"headerlink\" title=\"核心linux发行版\"></a>核心linux发行版</h2><p>含有内核、一个多个图形化桌面环境以编译好的几乎所有能见到的linux应用。它提供了一站式完整的安装。比较流行的版本有</p>\n<table>\n<thead>\n<tr>\n<th>发行版</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Debian</td>\n<td style=\"text-align:left\">在linux专家和商用linux产品中流行的发行版。</td>\n</tr>\n<tr>\n<td>OpenSUSE</td>\n<td style=\"text-align:left\">用于商用和家用的发行版</td>\n</tr>\n<tr>\n<td>Slackware</td>\n<td style=\"text-align:left\">最早的linux发行版的一员，在linux极客中比较流行。</td>\n</tr>\n<tr>\n<td>Red Hat</td>\n<td style=\"text-align:left\">主要用于Internet服务器的商业发行版</td>\n</tr>\n<tr>\n<td>Fedora</td>\n<td style=\"text-align:left\">从RedHat分离出的家用发行版</td>\n</tr>\n<tr>\n<td>Gentoo</td>\n<td style=\"text-align:left\">为高级linux用户设计的发行版，仅包含Linux源码。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"特殊用途的linux发行版：\"><a href=\"#特殊用途的linux发行版：\" class=\"headerlink\" title=\"特殊用途的linux发行版：\"></a>特殊用途的linux发行版：</h2><p>他们通常基于某个主流发行版，但仅包含主流发行版的一小部分用于某种特定用途的应用程序。定制化发行版还尝试通过自动检测和自动配置常见的硬件来帮助新手安装linux。</p>\n<table>\n<thead>\n<tr>\n<th>发行版</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Centos</td>\n<td style=\"text-align:left\">基于Red Hat企业版linux源代码构建的免费发行版</td>\n</tr>\n<tr>\n<td>Ubuntu</td>\n<td style=\"text-align:left\">用于学校和家庭的免费发行版</td>\n</tr>\n<tr>\n<td>PClinuxOS</td>\n<td style=\"text-align:left\">用于家庭和办公</td>\n</tr>\n<tr>\n<td>Mint</td>\n<td style=\"text-align:left\">用于家庭娱乐</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"linux 内存管理","comments":1,"date":"2017-03-05T10:00:46.000Z","update":"2017-03-05T10:00:46.000Z","_content":"\r# CPU位数和操作系统位数的关系：\r\r操作系统的位数其实是说的CPU的位数。因为计算机的所有功能都是基于CPU的指令集，也就是说，操作系统的所有功能几乎都跟CPU指令集有关系，操作系统的所有功能都会被翻译成一组CPU指令集。64位CPU的指令集是64位的，要想使用64位的功能，那么操作系统也必须是64位的。比如操作系统里的寻址，数据的大小都可以为64位。当然，64位CPU也会保存32位指令集，所以也兼容32位操作系统。\r \r现在来说CPU位数。众所周知，CPU里有8个通用寄存器，AX/BX/CX/DX/SI/DI/BP/SP，\r也就是说，由于64位CPU指令集会操作64位数据，如果寄存器是32位的，那么64位指令集便没有了可以运行的场所。所以，CPU位数说的是指令集的位数和通用寄存器的位数。\r\r下面是两个参考网站\r位什么要分段分页？\r> http://www.2cto.com/os/201210/161572.html\rhttp://www.cppblog.com/sixinquan/archive/2012/07/19/184234.html\r\r# 分段\r\r## 首先看一下分段的引入\r早期的8086处理器运算单元是16位的，也就是说，处理内存寻址的那部分指令集处理的也是16位的。而地址线是20位的。理论上，20位地址线寻址范围应该是1MB。但是由于指令集是16位的，所以也就不能直接使用这20位地址线。  \r### 解决方法有2种\r- 一种是，给CPU指令集增加一部分20位的指令集用来处理内存寻址，但是这会CPU内部结构不均匀（坏处网上我没搜到，反正肯定不好。我猜应该是，如果当这20位的指令集需要和16位的指令集进行交互时，那么就需要某种方式的映射，这会增加CPU功耗或者是拖慢CPU的速度）。\r- 另一种解决方法，CPU仍然使用16位指令集，增设一些16位的段寄存器。在把最终地址送上20位地址总线时，它会把某个段寄存器的16位放在地址总线的高16位，然后把指令集得到的16位地址放在低16位，那么相当于重叠了12位。但是，总能在20位的地址上模拟出1MB的访问空间。这就利用简单地加法模拟了一个映射，从而用16位的指令集使用了20位的地址线。这也就是为什么段的引入会加大寻址空间。\r\r而80386CPU的指令集是32位，地址线也是32位，按理来说根本不需要分段来增大寻址空间。但是，80386到底是8086的一员，它还得兼容之前的实模式，所以，16位的段寄存器必须保存下来。既然已经不需要分段的空大空间能力，所以，inter处理器的开发商便基于16位寄存器开发出了保护模式。在保护模式下,它的段范围不再受限于64K，可以达到4G。这一下真正解放了软件工程师,他们不必再费尽心思去压缩程序规模，软件功能也因此迅速提升。\r\r## 分段实现的功能：\r1. 扩大寻址空间。\r2. 实现保护模式\r\t\r保护模式会实现怎样的功能？  在保护模式下，一个地址空间是否可以被写入？可以被多少优先级的代码写入？是不是允许被执行等问题就显现出来了。例如，在还没有分页机制的时候，也就是没有多个进程利用多套虚拟地址空间使用同一个比如是4G的空间时，多个进程之间是如何共享内存的？如果没有保护，进程A访问了进程B的空间，并且修改了进程B的某个非常重要的参数，那么进程B可能会因此直接gg。程序员需要自己定义一个段，然后不允许其他进程访问。再例如，在面向对象的语言中，你可以把某个类的所有实例都写到一个段里，设置不是本类的成员方法不能对该段\r进行访问，这样就可以很好地管理一个类。说了半天，也就是，实现一套保护机制十分重要。那么到底是怎么实现的呢？（参考网址 http://www.techbulo.com/708.html）\r\r保护模式的实现除了CS,SS,DS,ES,FS,GS这6个段寄存器，还用到了GDT表和LDT表以及跟这两个表对应的两个寄存器：GDTR，LDTR。\r\r可能你现在想知道一个段的描述信息到底存放在哪，现在明确告诉你，对于某个段的描述信息来说，在内核中的某个线性地址，有一块连续内存，这块内存的起始地址可以由两个方法确定\r\r1. 段寄存器中的段选择子 +  GDTR中的GDT的起始位置 = 一个段的描述信息的描述信息。\r2. LDTR指向的内存地址。\r\r\rLDT1和LDT2等就是一个段的描述信息。GTD中存放的就是一个段的描述信息的描述信息。\rGDTＲ中存放GDT的起始地址，ＬＤＴＲ中存放某个段描述信息的起始地址。\r段寄存器中存放GDT的索引。\r而某个段描述信息中就有这个段的起始地址，终止地址，访问权限等。保护机制大功告成。\r\r但是linux并未使用如此细化的机制（参考网址：http://www.codesec.net/view/199560.html）\r\r逻辑地址就是指令中的偏移量，程序使用的都是这个。本来在分段机制下，线性地址是逻辑地址加上由16位段寄存器和GDT找到段描述信息中段起始的值得来的。但linux内逻辑地址和线性地址是一样的，如何做到的呢？那就是，在linux下，使所有的段起始地址都为0，终止地址都为oxfffffff，也就是4GB。所以对于任何用户来说，用户代码段描述符和用户数据段描述符都是一样的，而当切换到内核态时，所有的内核代码段描述符和内核数据段描述符都是一样的。也就是说，所有进程的用户代码段都共享着一个段描述信息（由上面的方法找到），所有的用户数据段也都共享。内核的代码段和数据段也一样。\r\r并且，只是通过段描述符中的DPL取值来进行权限管理。比如，内核代码段和数据段的DPL是0，那么就说明只有CPL为0时才能访问。而用户代码段和数据段的DPL为3。权限保护仅此而已，只是区分了内核态和用户态，并没有在多个进程之间进行保护。而进程之间更加细化的保护是页管理中进行的。\r\r\r> 对分段分页的总结：http://blog.sina.com.cn/s/blog_5420e00001013b7o.html\r\r这里有一个问题，分页既然能实现更细化的权限访问控制，那么就意味着分段的这点功能分页也完全能实现。那么为什么还非要强行使用分段，把逻辑地址转换为虚拟地址（线性地址），再使用分段，将虚拟地址再转换为物理地址？为什么不直接使用分页机制？\r\r因为linux是一个可以兼容多平台的操作系统。其中涉及到了对CPU的兼容。有些CPU，比如Intel的CPU，由于一是为了兼容其以前版本的CPU，二是由于分段存在了很长时间后才出现了分页，所以，CPU指令集中对寻址的指令会有这样一种逻辑：先分段，将逻辑转换为线性，再分页，将线性转换为物理。指令集使用的是逻辑地址，而Intel处理器对逻辑地址的定义是： 【段标识符：段内偏移量】， 也就是说，它硬性地规定了你的程序编译为二进制也就是机器语言后，必定是上面形式的逻辑地址，当程序运行后，它会把段内偏移量和由段标识符找到的段起始地址相加得到线性地址，然后放到地址总线上。也就是必须通过分段机制，才能得到线性地址，然后才能进行页映射。所以，linux为了兼容IntelCPU，也就必须使用分段机制。但是有些CPU，完全没有分段的概念，它的指令集里只有线性地址。那么这种矛盾怎么解决呢？linux巧妙地绕过了分段机制（让所有段起始地址为0，大小为4GB），而且还顺便利用了一下分段机制实现了用户和内核的分离（上面有讲）分页\r\t\t\t\r# 分页管理\r分页管理其实比分段管理简单，要了解的概念也能少一点。首先，分页管理是将线性地址转换为物理地址。\r\t\r上面分别是二级映射结构和四级映射结构的寻址方式。这里还是有多个硬件平台需要的映射结构不同。比如i386处理器支持二级映射方式，而有些CPU则需要三级甚至是四级。linux为了兼容各种平台，统一使用四级页表。具体二级和四级是怎么管理的.\r> 参考：http://blog.sina.com.cn/s/blog_5420e00001013b7o.html\r\rCPU将线性地址放到地址总线上，但不是直接使用这个线性地址操作内存，它会先经过MMU。ＣＲ３寄存器存放了页目录的起始地址，ＭＭＵ根据页目录的信息，将收到的线性地址转换为物理地址，再放到地址总线上，进行读写内存操作。\r\r### 分页实现的更细化的保护：\r1. 使用页表本身进行越界保护。每个进程只能映射到自己的物理内存。\r2. 在页表项中设置存取控制位。\r3. 在页表项中设置访问级别。\r\r### 分页的好处：\r\r实现了虚拟存储器，可以更高效地管理内存。\r\r### 虚拟存储器技术\r根据程序的局部性原理:\r\r1. 时间局部性：由于迭代循环等的存在，在ＣＰＵ访问后的单元在不久之后任然会受到多次循环访问。\r2. 空间局部性：对进程的某一空间的表或者对战数据进行集中访问。　　　　\r3. 顺序局部性：对于程序代码的执行，是顺序执行。即便使用了跳转指令跳转到另外一块程序，那么它任然会在跳转到的那块程序顺序访问。\r\r也就是说，在某一时间内，程序只会被访问到一部分，那么只需要把这部分装入内存就行了，其他的可以先暂时在磁盘上存放。\r　　　\r### 虚拟存储技术需要考虑的点：\r\r1. 调入策略：请求页式管理　预调入\r2. 分配策略：分配空闲内存\r3. 置换策略：随机淘汰，轮询，先进先出，最近少用\r\r# 抖动问题：\r由于设计问题，给一个进程在内存中分配的页面非常少，内存页面经常出现不足，就需要换出某些页。而如果置换算法设计的方法或者流程不好，则可能刚换出的页马上又要用到，频繁地进行这样的操作，使ＣＰＵ在整个时间片中大部分时间用在了页面换出换入上。这宗现象成为抖动。\r\r## 消除方法：\r\r1. 根据实际情况，设计出一个合理的工作集。\r2. 挂起某些进程。\r3. 缺页频度法：根据缺页发生的频率动态地更改给进程分配的空间。\r","source":"_posts/linux-内存管理.md","raw":"---\ntitle: linux 内存管理\ncomments: true\ntags:\n  - LINUX\n  - 内存管理\ncategories:\n  - LINUX\ndate: 2017-03-05 18:00:46\nupdate: 2017-03-05 18:00:46\n\n---\n\r# CPU位数和操作系统位数的关系：\r\r操作系统的位数其实是说的CPU的位数。因为计算机的所有功能都是基于CPU的指令集，也就是说，操作系统的所有功能几乎都跟CPU指令集有关系，操作系统的所有功能都会被翻译成一组CPU指令集。64位CPU的指令集是64位的，要想使用64位的功能，那么操作系统也必须是64位的。比如操作系统里的寻址，数据的大小都可以为64位。当然，64位CPU也会保存32位指令集，所以也兼容32位操作系统。\r \r现在来说CPU位数。众所周知，CPU里有8个通用寄存器，AX/BX/CX/DX/SI/DI/BP/SP，\r也就是说，由于64位CPU指令集会操作64位数据，如果寄存器是32位的，那么64位指令集便没有了可以运行的场所。所以，CPU位数说的是指令集的位数和通用寄存器的位数。\r\r下面是两个参考网站\r位什么要分段分页？\r> http://www.2cto.com/os/201210/161572.html\rhttp://www.cppblog.com/sixinquan/archive/2012/07/19/184234.html\r\r# 分段\r\r## 首先看一下分段的引入\r早期的8086处理器运算单元是16位的，也就是说，处理内存寻址的那部分指令集处理的也是16位的。而地址线是20位的。理论上，20位地址线寻址范围应该是1MB。但是由于指令集是16位的，所以也就不能直接使用这20位地址线。  \r### 解决方法有2种\r- 一种是，给CPU指令集增加一部分20位的指令集用来处理内存寻址，但是这会CPU内部结构不均匀（坏处网上我没搜到，反正肯定不好。我猜应该是，如果当这20位的指令集需要和16位的指令集进行交互时，那么就需要某种方式的映射，这会增加CPU功耗或者是拖慢CPU的速度）。\r- 另一种解决方法，CPU仍然使用16位指令集，增设一些16位的段寄存器。在把最终地址送上20位地址总线时，它会把某个段寄存器的16位放在地址总线的高16位，然后把指令集得到的16位地址放在低16位，那么相当于重叠了12位。但是，总能在20位的地址上模拟出1MB的访问空间。这就利用简单地加法模拟了一个映射，从而用16位的指令集使用了20位的地址线。这也就是为什么段的引入会加大寻址空间。\r\r而80386CPU的指令集是32位，地址线也是32位，按理来说根本不需要分段来增大寻址空间。但是，80386到底是8086的一员，它还得兼容之前的实模式，所以，16位的段寄存器必须保存下来。既然已经不需要分段的空大空间能力，所以，inter处理器的开发商便基于16位寄存器开发出了保护模式。在保护模式下,它的段范围不再受限于64K，可以达到4G。这一下真正解放了软件工程师,他们不必再费尽心思去压缩程序规模，软件功能也因此迅速提升。\r\r## 分段实现的功能：\r1. 扩大寻址空间。\r2. 实现保护模式\r\t\r保护模式会实现怎样的功能？  在保护模式下，一个地址空间是否可以被写入？可以被多少优先级的代码写入？是不是允许被执行等问题就显现出来了。例如，在还没有分页机制的时候，也就是没有多个进程利用多套虚拟地址空间使用同一个比如是4G的空间时，多个进程之间是如何共享内存的？如果没有保护，进程A访问了进程B的空间，并且修改了进程B的某个非常重要的参数，那么进程B可能会因此直接gg。程序员需要自己定义一个段，然后不允许其他进程访问。再例如，在面向对象的语言中，你可以把某个类的所有实例都写到一个段里，设置不是本类的成员方法不能对该段\r进行访问，这样就可以很好地管理一个类。说了半天，也就是，实现一套保护机制十分重要。那么到底是怎么实现的呢？（参考网址 http://www.techbulo.com/708.html）\r\r保护模式的实现除了CS,SS,DS,ES,FS,GS这6个段寄存器，还用到了GDT表和LDT表以及跟这两个表对应的两个寄存器：GDTR，LDTR。\r\r可能你现在想知道一个段的描述信息到底存放在哪，现在明确告诉你，对于某个段的描述信息来说，在内核中的某个线性地址，有一块连续内存，这块内存的起始地址可以由两个方法确定\r\r1. 段寄存器中的段选择子 +  GDTR中的GDT的起始位置 = 一个段的描述信息的描述信息。\r2. LDTR指向的内存地址。\r\r\rLDT1和LDT2等就是一个段的描述信息。GTD中存放的就是一个段的描述信息的描述信息。\rGDTＲ中存放GDT的起始地址，ＬＤＴＲ中存放某个段描述信息的起始地址。\r段寄存器中存放GDT的索引。\r而某个段描述信息中就有这个段的起始地址，终止地址，访问权限等。保护机制大功告成。\r\r但是linux并未使用如此细化的机制（参考网址：http://www.codesec.net/view/199560.html）\r\r逻辑地址就是指令中的偏移量，程序使用的都是这个。本来在分段机制下，线性地址是逻辑地址加上由16位段寄存器和GDT找到段描述信息中段起始的值得来的。但linux内逻辑地址和线性地址是一样的，如何做到的呢？那就是，在linux下，使所有的段起始地址都为0，终止地址都为oxfffffff，也就是4GB。所以对于任何用户来说，用户代码段描述符和用户数据段描述符都是一样的，而当切换到内核态时，所有的内核代码段描述符和内核数据段描述符都是一样的。也就是说，所有进程的用户代码段都共享着一个段描述信息（由上面的方法找到），所有的用户数据段也都共享。内核的代码段和数据段也一样。\r\r并且，只是通过段描述符中的DPL取值来进行权限管理。比如，内核代码段和数据段的DPL是0，那么就说明只有CPL为0时才能访问。而用户代码段和数据段的DPL为3。权限保护仅此而已，只是区分了内核态和用户态，并没有在多个进程之间进行保护。而进程之间更加细化的保护是页管理中进行的。\r\r\r> 对分段分页的总结：http://blog.sina.com.cn/s/blog_5420e00001013b7o.html\r\r这里有一个问题，分页既然能实现更细化的权限访问控制，那么就意味着分段的这点功能分页也完全能实现。那么为什么还非要强行使用分段，把逻辑地址转换为虚拟地址（线性地址），再使用分段，将虚拟地址再转换为物理地址？为什么不直接使用分页机制？\r\r因为linux是一个可以兼容多平台的操作系统。其中涉及到了对CPU的兼容。有些CPU，比如Intel的CPU，由于一是为了兼容其以前版本的CPU，二是由于分段存在了很长时间后才出现了分页，所以，CPU指令集中对寻址的指令会有这样一种逻辑：先分段，将逻辑转换为线性，再分页，将线性转换为物理。指令集使用的是逻辑地址，而Intel处理器对逻辑地址的定义是： 【段标识符：段内偏移量】， 也就是说，它硬性地规定了你的程序编译为二进制也就是机器语言后，必定是上面形式的逻辑地址，当程序运行后，它会把段内偏移量和由段标识符找到的段起始地址相加得到线性地址，然后放到地址总线上。也就是必须通过分段机制，才能得到线性地址，然后才能进行页映射。所以，linux为了兼容IntelCPU，也就必须使用分段机制。但是有些CPU，完全没有分段的概念，它的指令集里只有线性地址。那么这种矛盾怎么解决呢？linux巧妙地绕过了分段机制（让所有段起始地址为0，大小为4GB），而且还顺便利用了一下分段机制实现了用户和内核的分离（上面有讲）分页\r\t\t\t\r# 分页管理\r分页管理其实比分段管理简单，要了解的概念也能少一点。首先，分页管理是将线性地址转换为物理地址。\r\t\r上面分别是二级映射结构和四级映射结构的寻址方式。这里还是有多个硬件平台需要的映射结构不同。比如i386处理器支持二级映射方式，而有些CPU则需要三级甚至是四级。linux为了兼容各种平台，统一使用四级页表。具体二级和四级是怎么管理的.\r> 参考：http://blog.sina.com.cn/s/blog_5420e00001013b7o.html\r\rCPU将线性地址放到地址总线上，但不是直接使用这个线性地址操作内存，它会先经过MMU。ＣＲ３寄存器存放了页目录的起始地址，ＭＭＵ根据页目录的信息，将收到的线性地址转换为物理地址，再放到地址总线上，进行读写内存操作。\r\r### 分页实现的更细化的保护：\r1. 使用页表本身进行越界保护。每个进程只能映射到自己的物理内存。\r2. 在页表项中设置存取控制位。\r3. 在页表项中设置访问级别。\r\r### 分页的好处：\r\r实现了虚拟存储器，可以更高效地管理内存。\r\r### 虚拟存储器技术\r根据程序的局部性原理:\r\r1. 时间局部性：由于迭代循环等的存在，在ＣＰＵ访问后的单元在不久之后任然会受到多次循环访问。\r2. 空间局部性：对进程的某一空间的表或者对战数据进行集中访问。　　　　\r3. 顺序局部性：对于程序代码的执行，是顺序执行。即便使用了跳转指令跳转到另外一块程序，那么它任然会在跳转到的那块程序顺序访问。\r\r也就是说，在某一时间内，程序只会被访问到一部分，那么只需要把这部分装入内存就行了，其他的可以先暂时在磁盘上存放。\r　　　\r### 虚拟存储技术需要考虑的点：\r\r1. 调入策略：请求页式管理　预调入\r2. 分配策略：分配空闲内存\r3. 置换策略：随机淘汰，轮询，先进先出，最近少用\r\r# 抖动问题：\r由于设计问题，给一个进程在内存中分配的页面非常少，内存页面经常出现不足，就需要换出某些页。而如果置换算法设计的方法或者流程不好，则可能刚换出的页马上又要用到，频繁地进行这样的操作，使ＣＰＵ在整个时间片中大部分时间用在了页面换出换入上。这宗现象成为抖动。\r\r## 消除方法：\r\r1. 根据实际情况，设计出一个合理的工作集。\r2. 挂起某些进程。\r3. 缺页频度法：根据缺页发生的频率动态地更改给进程分配的空间。\r","slug":"linux-内存管理","published":1,"updated":"2017-09-02T10:12:55.000Z","layout":"post","photos":[],"link":"","_id":"cjd4d1a080014ryx4gvnubet8","content":"<h1 id=\"CPU位数和操作系统位数的关系：\"><a href=\"#CPU位数和操作系统位数的关系：\" class=\"headerlink\" title=\"CPU位数和操作系统位数的关系：\"></a>CPU位数和操作系统位数的关系：</h1><p>操作系统的位数其实是说的CPU的位数。因为计算机的所有功能都是基于CPU的指令集，也就是说，操作系统的所有功能几乎都跟CPU指令集有关系，操作系统的所有功能都会被翻译成一组CPU指令集。64位CPU的指令集是64位的，要想使用64位的功能，那么操作系统也必须是64位的。比如操作系统里的寻址，数据的大小都可以为64位。当然，64位CPU也会保存32位指令集，所以也兼容32位操作系统。</p>\n<p>现在来说CPU位数。众所周知，CPU里有8个通用寄存器，AX/BX/CX/DX/SI/DI/BP/SP，<br>也就是说，由于64位CPU指令集会操作64位数据，如果寄存器是32位的，那么64位指令集便没有了可以运行的场所。所以，CPU位数说的是指令集的位数和通用寄存器的位数。</p>\n<p>下面是两个参考网站<br>位什么要分段分页？</p>\n<blockquote>\n<p><a href=\"http://www.2cto.com/os/201210/161572.html\" target=\"_blank\" rel=\"external\">http://www.2cto.com/os/201210/161572.html</a><br><a href=\"http://www.cppblog.com/sixinquan/archive/2012/07/19/184234.html\" target=\"_blank\" rel=\"external\">http://www.cppblog.com/sixinquan/archive/2012/07/19/184234.html</a></p>\n</blockquote>\n<h1 id=\"分段\"><a href=\"#分段\" class=\"headerlink\" title=\"分段\"></a>分段</h1><h2 id=\"首先看一下分段的引入\"><a href=\"#首先看一下分段的引入\" class=\"headerlink\" title=\"首先看一下分段的引入\"></a>首先看一下分段的引入</h2><p>早期的8086处理器运算单元是16位的，也就是说，处理内存寻址的那部分指令集处理的也是16位的。而地址线是20位的。理论上，20位地址线寻址范围应该是1MB。但是由于指令集是16位的，所以也就不能直接使用这20位地址线。  </p>\n<h3 id=\"解决方法有2种\"><a href=\"#解决方法有2种\" class=\"headerlink\" title=\"解决方法有2种\"></a>解决方法有2种</h3><ul>\n<li>一种是，给CPU指令集增加一部分20位的指令集用来处理内存寻址，但是这会CPU内部结构不均匀（坏处网上我没搜到，反正肯定不好。我猜应该是，如果当这20位的指令集需要和16位的指令集进行交互时，那么就需要某种方式的映射，这会增加CPU功耗或者是拖慢CPU的速度）。</li>\n<li>另一种解决方法，CPU仍然使用16位指令集，增设一些16位的段寄存器。在把最终地址送上20位地址总线时，它会把某个段寄存器的16位放在地址总线的高16位，然后把指令集得到的16位地址放在低16位，那么相当于重叠了12位。但是，总能在20位的地址上模拟出1MB的访问空间。这就利用简单地加法模拟了一个映射，从而用16位的指令集使用了20位的地址线。这也就是为什么段的引入会加大寻址空间。</li>\n</ul>\n<p>而80386CPU的指令集是32位，地址线也是32位，按理来说根本不需要分段来增大寻址空间。但是，80386到底是8086的一员，它还得兼容之前的实模式，所以，16位的段寄存器必须保存下来。既然已经不需要分段的空大空间能力，所以，inter处理器的开发商便基于16位寄存器开发出了保护模式。在保护模式下,它的段范围不再受限于64K，可以达到4G。这一下真正解放了软件工程师,他们不必再费尽心思去压缩程序规模，软件功能也因此迅速提升。</p>\n<h2 id=\"分段实现的功能：\"><a href=\"#分段实现的功能：\" class=\"headerlink\" title=\"分段实现的功能：\"></a>分段实现的功能：</h2><ol>\n<li>扩大寻址空间。</li>\n<li>实现保护模式</li>\n</ol>\n<p>保护模式会实现怎样的功能？  在保护模式下，一个地址空间是否可以被写入？可以被多少优先级的代码写入？是不是允许被执行等问题就显现出来了。例如，在还没有分页机制的时候，也就是没有多个进程利用多套虚拟地址空间使用同一个比如是4G的空间时，多个进程之间是如何共享内存的？如果没有保护，进程A访问了进程B的空间，并且修改了进程B的某个非常重要的参数，那么进程B可能会因此直接gg。程序员需要自己定义一个段，然后不允许其他进程访问。再例如，在面向对象的语言中，你可以把某个类的所有实例都写到一个段里，设置不是本类的成员方法不能对该段<br>进行访问，这样就可以很好地管理一个类。说了半天，也就是，实现一套保护机制十分重要。那么到底是怎么实现的呢？（参考网址 <a href=\"http://www.techbulo.com/708.html）\" target=\"_blank\" rel=\"external\">http://www.techbulo.com/708.html）</a></p>\n<p>保护模式的实现除了CS,SS,DS,ES,FS,GS这6个段寄存器，还用到了GDT表和LDT表以及跟这两个表对应的两个寄存器：GDTR，LDTR。</p>\n<p>可能你现在想知道一个段的描述信息到底存放在哪，现在明确告诉你，对于某个段的描述信息来说，在内核中的某个线性地址，有一块连续内存，这块内存的起始地址可以由两个方法确定</p>\n<ol>\n<li>段寄存器中的段选择子 +  GDTR中的GDT的起始位置 = 一个段的描述信息的描述信息。</li>\n<li>LDTR指向的内存地址。</li>\n</ol>\n<p>LDT1和LDT2等就是一个段的描述信息。GTD中存放的就是一个段的描述信息的描述信息。<br>GDTＲ中存放GDT的起始地址，ＬＤＴＲ中存放某个段描述信息的起始地址。<br>段寄存器中存放GDT的索引。<br>而某个段描述信息中就有这个段的起始地址，终止地址，访问权限等。保护机制大功告成。</p>\n<p>但是linux并未使用如此细化的机制（参考网址：<a href=\"http://www.codesec.net/view/199560.html）\" target=\"_blank\" rel=\"external\">http://www.codesec.net/view/199560.html）</a></p>\n<p>逻辑地址就是指令中的偏移量，程序使用的都是这个。本来在分段机制下，线性地址是逻辑地址加上由16位段寄存器和GDT找到段描述信息中段起始的值得来的。但linux内逻辑地址和线性地址是一样的，如何做到的呢？那就是，在linux下，使所有的段起始地址都为0，终止地址都为oxfffffff，也就是4GB。所以对于任何用户来说，用户代码段描述符和用户数据段描述符都是一样的，而当切换到内核态时，所有的内核代码段描述符和内核数据段描述符都是一样的。也就是说，所有进程的用户代码段都共享着一个段描述信息（由上面的方法找到），所有的用户数据段也都共享。内核的代码段和数据段也一样。</p>\n<p>并且，只是通过段描述符中的DPL取值来进行权限管理。比如，内核代码段和数据段的DPL是0，那么就说明只有CPL为0时才能访问。而用户代码段和数据段的DPL为3。权限保护仅此而已，只是区分了内核态和用户态，并没有在多个进程之间进行保护。而进程之间更加细化的保护是页管理中进行的。</p>\n<blockquote>\n<p>对分段分页的总结：<a href=\"http://blog.sina.com.cn/s/blog_5420e00001013b7o.html\" target=\"_blank\" rel=\"external\">http://blog.sina.com.cn/s/blog_5420e00001013b7o.html</a></p>\n</blockquote>\n<p>这里有一个问题，分页既然能实现更细化的权限访问控制，那么就意味着分段的这点功能分页也完全能实现。那么为什么还非要强行使用分段，把逻辑地址转换为虚拟地址（线性地址），再使用分段，将虚拟地址再转换为物理地址？为什么不直接使用分页机制？</p>\n<p>因为linux是一个可以兼容多平台的操作系统。其中涉及到了对CPU的兼容。有些CPU，比如Intel的CPU，由于一是为了兼容其以前版本的CPU，二是由于分段存在了很长时间后才出现了分页，所以，CPU指令集中对寻址的指令会有这样一种逻辑：先分段，将逻辑转换为线性，再分页，将线性转换为物理。指令集使用的是逻辑地址，而Intel处理器对逻辑地址的定义是： 【段标识符：段内偏移量】， 也就是说，它硬性地规定了你的程序编译为二进制也就是机器语言后，必定是上面形式的逻辑地址，当程序运行后，它会把段内偏移量和由段标识符找到的段起始地址相加得到线性地址，然后放到地址总线上。也就是必须通过分段机制，才能得到线性地址，然后才能进行页映射。所以，linux为了兼容IntelCPU，也就必须使用分段机制。但是有些CPU，完全没有分段的概念，它的指令集里只有线性地址。那么这种矛盾怎么解决呢？linux巧妙地绕过了分段机制（让所有段起始地址为0，大小为4GB），而且还顺便利用了一下分段机制实现了用户和内核的分离（上面有讲）分页</p>\n<h1 id=\"分页管理\"><a href=\"#分页管理\" class=\"headerlink\" title=\"分页管理\"></a>分页管理</h1><p>分页管理其实比分段管理简单，要了解的概念也能少一点。首先，分页管理是将线性地址转换为物理地址。</p>\n<p>上面分别是二级映射结构和四级映射结构的寻址方式。这里还是有多个硬件平台需要的映射结构不同。比如i386处理器支持二级映射方式，而有些CPU则需要三级甚至是四级。linux为了兼容各种平台，统一使用四级页表。具体二级和四级是怎么管理的.</p>\n<blockquote>\n<p>参考：<a href=\"http://blog.sina.com.cn/s/blog_5420e00001013b7o.html\" target=\"_blank\" rel=\"external\">http://blog.sina.com.cn/s/blog_5420e00001013b7o.html</a></p>\n</blockquote>\n<p>CPU将线性地址放到地址总线上，但不是直接使用这个线性地址操作内存，它会先经过MMU。ＣＲ３寄存器存放了页目录的起始地址，ＭＭＵ根据页目录的信息，将收到的线性地址转换为物理地址，再放到地址总线上，进行读写内存操作。</p>\n<h3 id=\"分页实现的更细化的保护：\"><a href=\"#分页实现的更细化的保护：\" class=\"headerlink\" title=\"分页实现的更细化的保护：\"></a>分页实现的更细化的保护：</h3><ol>\n<li>使用页表本身进行越界保护。每个进程只能映射到自己的物理内存。</li>\n<li>在页表项中设置存取控制位。</li>\n<li>在页表项中设置访问级别。</li>\n</ol>\n<h3 id=\"分页的好处：\"><a href=\"#分页的好处：\" class=\"headerlink\" title=\"分页的好处：\"></a>分页的好处：</h3><p>实现了虚拟存储器，可以更高效地管理内存。</p>\n<h3 id=\"虚拟存储器技术\"><a href=\"#虚拟存储器技术\" class=\"headerlink\" title=\"虚拟存储器技术\"></a>虚拟存储器技术</h3><p>根据程序的局部性原理:</p>\n<ol>\n<li>时间局部性：由于迭代循环等的存在，在ＣＰＵ访问后的单元在不久之后任然会受到多次循环访问。</li>\n<li>空间局部性：对进程的某一空间的表或者对战数据进行集中访问。　　　　</li>\n<li>顺序局部性：对于程序代码的执行，是顺序执行。即便使用了跳转指令跳转到另外一块程序，那么它任然会在跳转到的那块程序顺序访问。</li>\n</ol>\n<p>也就是说，在某一时间内，程序只会被访问到一部分，那么只需要把这部分装入内存就行了，其他的可以先暂时在磁盘上存放。\n　　　</p>\n<h3 id=\"虚拟存储技术需要考虑的点：\"><a href=\"#虚拟存储技术需要考虑的点：\" class=\"headerlink\" title=\"虚拟存储技术需要考虑的点：\"></a>虚拟存储技术需要考虑的点：</h3><ol>\n<li>调入策略：请求页式管理　预调入</li>\n<li>分配策略：分配空闲内存</li>\n<li>置换策略：随机淘汰，轮询，先进先出，最近少用</li>\n</ol>\n<h1 id=\"抖动问题：\"><a href=\"#抖动问题：\" class=\"headerlink\" title=\"抖动问题：\"></a>抖动问题：</h1><p>由于设计问题，给一个进程在内存中分配的页面非常少，内存页面经常出现不足，就需要换出某些页。而如果置换算法设计的方法或者流程不好，则可能刚换出的页马上又要用到，频繁地进行这样的操作，使ＣＰＵ在整个时间片中大部分时间用在了页面换出换入上。这宗现象成为抖动。</p>\n<h2 id=\"消除方法：\"><a href=\"#消除方法：\" class=\"headerlink\" title=\"消除方法：\"></a>消除方法：</h2><ol>\n<li>根据实际情况，设计出一个合理的工作集。</li>\n<li>挂起某些进程。</li>\n<li>缺页频度法：根据缺页发生的频率动态地更改给进程分配的空间。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"CPU位数和操作系统位数的关系：\"><a href=\"#CPU位数和操作系统位数的关系：\" class=\"headerlink\" title=\"CPU位数和操作系统位数的关系：\"></a>CPU位数和操作系统位数的关系：</h1><p>操作系统的位数其实是说的CPU的位数。因为计算机的所有功能都是基于CPU的指令集，也就是说，操作系统的所有功能几乎都跟CPU指令集有关系，操作系统的所有功能都会被翻译成一组CPU指令集。64位CPU的指令集是64位的，要想使用64位的功能，那么操作系统也必须是64位的。比如操作系统里的寻址，数据的大小都可以为64位。当然，64位CPU也会保存32位指令集，所以也兼容32位操作系统。</p>\n<p>现在来说CPU位数。众所周知，CPU里有8个通用寄存器，AX/BX/CX/DX/SI/DI/BP/SP，<br>也就是说，由于64位CPU指令集会操作64位数据，如果寄存器是32位的，那么64位指令集便没有了可以运行的场所。所以，CPU位数说的是指令集的位数和通用寄存器的位数。</p>\n<p>下面是两个参考网站<br>位什么要分段分页？</p>\n<blockquote>\n<p><a href=\"http://www.2cto.com/os/201210/161572.html\" target=\"_blank\" rel=\"external\">http://www.2cto.com/os/201210/161572.html</a><br><a href=\"http://www.cppblog.com/sixinquan/archive/2012/07/19/184234.html\" target=\"_blank\" rel=\"external\">http://www.cppblog.com/sixinquan/archive/2012/07/19/184234.html</a></p>\n</blockquote>\n<h1 id=\"分段\"><a href=\"#分段\" class=\"headerlink\" title=\"分段\"></a>分段</h1><h2 id=\"首先看一下分段的引入\"><a href=\"#首先看一下分段的引入\" class=\"headerlink\" title=\"首先看一下分段的引入\"></a>首先看一下分段的引入</h2><p>早期的8086处理器运算单元是16位的，也就是说，处理内存寻址的那部分指令集处理的也是16位的。而地址线是20位的。理论上，20位地址线寻址范围应该是1MB。但是由于指令集是16位的，所以也就不能直接使用这20位地址线。  </p>\n<h3 id=\"解决方法有2种\"><a href=\"#解决方法有2种\" class=\"headerlink\" title=\"解决方法有2种\"></a>解决方法有2种</h3><ul>\n<li>一种是，给CPU指令集增加一部分20位的指令集用来处理内存寻址，但是这会CPU内部结构不均匀（坏处网上我没搜到，反正肯定不好。我猜应该是，如果当这20位的指令集需要和16位的指令集进行交互时，那么就需要某种方式的映射，这会增加CPU功耗或者是拖慢CPU的速度）。</li>\n<li>另一种解决方法，CPU仍然使用16位指令集，增设一些16位的段寄存器。在把最终地址送上20位地址总线时，它会把某个段寄存器的16位放在地址总线的高16位，然后把指令集得到的16位地址放在低16位，那么相当于重叠了12位。但是，总能在20位的地址上模拟出1MB的访问空间。这就利用简单地加法模拟了一个映射，从而用16位的指令集使用了20位的地址线。这也就是为什么段的引入会加大寻址空间。</li>\n</ul>\n<p>而80386CPU的指令集是32位，地址线也是32位，按理来说根本不需要分段来增大寻址空间。但是，80386到底是8086的一员，它还得兼容之前的实模式，所以，16位的段寄存器必须保存下来。既然已经不需要分段的空大空间能力，所以，inter处理器的开发商便基于16位寄存器开发出了保护模式。在保护模式下,它的段范围不再受限于64K，可以达到4G。这一下真正解放了软件工程师,他们不必再费尽心思去压缩程序规模，软件功能也因此迅速提升。</p>\n<h2 id=\"分段实现的功能：\"><a href=\"#分段实现的功能：\" class=\"headerlink\" title=\"分段实现的功能：\"></a>分段实现的功能：</h2><ol>\n<li>扩大寻址空间。</li>\n<li>实现保护模式</li>\n</ol>\n<p>保护模式会实现怎样的功能？  在保护模式下，一个地址空间是否可以被写入？可以被多少优先级的代码写入？是不是允许被执行等问题就显现出来了。例如，在还没有分页机制的时候，也就是没有多个进程利用多套虚拟地址空间使用同一个比如是4G的空间时，多个进程之间是如何共享内存的？如果没有保护，进程A访问了进程B的空间，并且修改了进程B的某个非常重要的参数，那么进程B可能会因此直接gg。程序员需要自己定义一个段，然后不允许其他进程访问。再例如，在面向对象的语言中，你可以把某个类的所有实例都写到一个段里，设置不是本类的成员方法不能对该段<br>进行访问，这样就可以很好地管理一个类。说了半天，也就是，实现一套保护机制十分重要。那么到底是怎么实现的呢？（参考网址 <a href=\"http://www.techbulo.com/708.html）\" target=\"_blank\" rel=\"external\">http://www.techbulo.com/708.html）</a></p>\n<p>保护模式的实现除了CS,SS,DS,ES,FS,GS这6个段寄存器，还用到了GDT表和LDT表以及跟这两个表对应的两个寄存器：GDTR，LDTR。</p>\n<p>可能你现在想知道一个段的描述信息到底存放在哪，现在明确告诉你，对于某个段的描述信息来说，在内核中的某个线性地址，有一块连续内存，这块内存的起始地址可以由两个方法确定</p>\n<ol>\n<li>段寄存器中的段选择子 +  GDTR中的GDT的起始位置 = 一个段的描述信息的描述信息。</li>\n<li>LDTR指向的内存地址。</li>\n</ol>\n<p>LDT1和LDT2等就是一个段的描述信息。GTD中存放的就是一个段的描述信息的描述信息。<br>GDTＲ中存放GDT的起始地址，ＬＤＴＲ中存放某个段描述信息的起始地址。<br>段寄存器中存放GDT的索引。<br>而某个段描述信息中就有这个段的起始地址，终止地址，访问权限等。保护机制大功告成。</p>\n<p>但是linux并未使用如此细化的机制（参考网址：<a href=\"http://www.codesec.net/view/199560.html）\" target=\"_blank\" rel=\"external\">http://www.codesec.net/view/199560.html）</a></p>\n<p>逻辑地址就是指令中的偏移量，程序使用的都是这个。本来在分段机制下，线性地址是逻辑地址加上由16位段寄存器和GDT找到段描述信息中段起始的值得来的。但linux内逻辑地址和线性地址是一样的，如何做到的呢？那就是，在linux下，使所有的段起始地址都为0，终止地址都为oxfffffff，也就是4GB。所以对于任何用户来说，用户代码段描述符和用户数据段描述符都是一样的，而当切换到内核态时，所有的内核代码段描述符和内核数据段描述符都是一样的。也就是说，所有进程的用户代码段都共享着一个段描述信息（由上面的方法找到），所有的用户数据段也都共享。内核的代码段和数据段也一样。</p>\n<p>并且，只是通过段描述符中的DPL取值来进行权限管理。比如，内核代码段和数据段的DPL是0，那么就说明只有CPL为0时才能访问。而用户代码段和数据段的DPL为3。权限保护仅此而已，只是区分了内核态和用户态，并没有在多个进程之间进行保护。而进程之间更加细化的保护是页管理中进行的。</p>\n<blockquote>\n<p>对分段分页的总结：<a href=\"http://blog.sina.com.cn/s/blog_5420e00001013b7o.html\" target=\"_blank\" rel=\"external\">http://blog.sina.com.cn/s/blog_5420e00001013b7o.html</a></p>\n</blockquote>\n<p>这里有一个问题，分页既然能实现更细化的权限访问控制，那么就意味着分段的这点功能分页也完全能实现。那么为什么还非要强行使用分段，把逻辑地址转换为虚拟地址（线性地址），再使用分段，将虚拟地址再转换为物理地址？为什么不直接使用分页机制？</p>\n<p>因为linux是一个可以兼容多平台的操作系统。其中涉及到了对CPU的兼容。有些CPU，比如Intel的CPU，由于一是为了兼容其以前版本的CPU，二是由于分段存在了很长时间后才出现了分页，所以，CPU指令集中对寻址的指令会有这样一种逻辑：先分段，将逻辑转换为线性，再分页，将线性转换为物理。指令集使用的是逻辑地址，而Intel处理器对逻辑地址的定义是： 【段标识符：段内偏移量】， 也就是说，它硬性地规定了你的程序编译为二进制也就是机器语言后，必定是上面形式的逻辑地址，当程序运行后，它会把段内偏移量和由段标识符找到的段起始地址相加得到线性地址，然后放到地址总线上。也就是必须通过分段机制，才能得到线性地址，然后才能进行页映射。所以，linux为了兼容IntelCPU，也就必须使用分段机制。但是有些CPU，完全没有分段的概念，它的指令集里只有线性地址。那么这种矛盾怎么解决呢？linux巧妙地绕过了分段机制（让所有段起始地址为0，大小为4GB），而且还顺便利用了一下分段机制实现了用户和内核的分离（上面有讲）分页</p>\n<h1 id=\"分页管理\"><a href=\"#分页管理\" class=\"headerlink\" title=\"分页管理\"></a>分页管理</h1><p>分页管理其实比分段管理简单，要了解的概念也能少一点。首先，分页管理是将线性地址转换为物理地址。</p>\n<p>上面分别是二级映射结构和四级映射结构的寻址方式。这里还是有多个硬件平台需要的映射结构不同。比如i386处理器支持二级映射方式，而有些CPU则需要三级甚至是四级。linux为了兼容各种平台，统一使用四级页表。具体二级和四级是怎么管理的.</p>\n<blockquote>\n<p>参考：<a href=\"http://blog.sina.com.cn/s/blog_5420e00001013b7o.html\" target=\"_blank\" rel=\"external\">http://blog.sina.com.cn/s/blog_5420e00001013b7o.html</a></p>\n</blockquote>\n<p>CPU将线性地址放到地址总线上，但不是直接使用这个线性地址操作内存，它会先经过MMU。ＣＲ３寄存器存放了页目录的起始地址，ＭＭＵ根据页目录的信息，将收到的线性地址转换为物理地址，再放到地址总线上，进行读写内存操作。</p>\n<h3 id=\"分页实现的更细化的保护：\"><a href=\"#分页实现的更细化的保护：\" class=\"headerlink\" title=\"分页实现的更细化的保护：\"></a>分页实现的更细化的保护：</h3><ol>\n<li>使用页表本身进行越界保护。每个进程只能映射到自己的物理内存。</li>\n<li>在页表项中设置存取控制位。</li>\n<li>在页表项中设置访问级别。</li>\n</ol>\n<h3 id=\"分页的好处：\"><a href=\"#分页的好处：\" class=\"headerlink\" title=\"分页的好处：\"></a>分页的好处：</h3><p>实现了虚拟存储器，可以更高效地管理内存。</p>\n<h3 id=\"虚拟存储器技术\"><a href=\"#虚拟存储器技术\" class=\"headerlink\" title=\"虚拟存储器技术\"></a>虚拟存储器技术</h3><p>根据程序的局部性原理:</p>\n<ol>\n<li>时间局部性：由于迭代循环等的存在，在ＣＰＵ访问后的单元在不久之后任然会受到多次循环访问。</li>\n<li>空间局部性：对进程的某一空间的表或者对战数据进行集中访问。　　　　</li>\n<li>顺序局部性：对于程序代码的执行，是顺序执行。即便使用了跳转指令跳转到另外一块程序，那么它任然会在跳转到的那块程序顺序访问。</li>\n</ol>\n<p>也就是说，在某一时间内，程序只会被访问到一部分，那么只需要把这部分装入内存就行了，其他的可以先暂时在磁盘上存放。\n　　　</p>\n<h3 id=\"虚拟存储技术需要考虑的点：\"><a href=\"#虚拟存储技术需要考虑的点：\" class=\"headerlink\" title=\"虚拟存储技术需要考虑的点：\"></a>虚拟存储技术需要考虑的点：</h3><ol>\n<li>调入策略：请求页式管理　预调入</li>\n<li>分配策略：分配空闲内存</li>\n<li>置换策略：随机淘汰，轮询，先进先出，最近少用</li>\n</ol>\n<h1 id=\"抖动问题：\"><a href=\"#抖动问题：\" class=\"headerlink\" title=\"抖动问题：\"></a>抖动问题：</h1><p>由于设计问题，给一个进程在内存中分配的页面非常少，内存页面经常出现不足，就需要换出某些页。而如果置换算法设计的方法或者流程不好，则可能刚换出的页马上又要用到，频繁地进行这样的操作，使ＣＰＵ在整个时间片中大部分时间用在了页面换出换入上。这宗现象成为抖动。</p>\n<h2 id=\"消除方法：\"><a href=\"#消除方法：\" class=\"headerlink\" title=\"消除方法：\"></a>消除方法：</h2><ol>\n<li>根据实际情况，设计出一个合理的工作集。</li>\n<li>挂起某些进程。</li>\n<li>缺页频度法：根据缺页发生的频率动态地更改给进程分配的空间。</li>\n</ol>\n"},{"title":"linux 文件系统","comments":1,"date":"2017-03-05T10:00:46.000Z","update":"2017-03-05T10:00:46.000Z","_content":"\r# 文件系统\r\r概念：是操作系统的一部分，用来管理磁盘空间，向外提供操纵接口。比如fread，fwrite，fopen等系统调用就是文件系统提供的功能。\r\r作用：管理用户的逻辑文件，替用户保存逻辑文件到存储块的映射。并提供缓存机制，做到存取速度快，存储空间利用率高，数据安全性好。\r\r>NFS（Network File System）即网络文件系统  \r>NTFS (New Technology File System)  \r>FAT是文件配置表（英语：File Allocation Table，首字母缩略字：FAT）  \r>EXT4是第四代扩展文件系统（英语：Fourth extended filesystem，缩写为 ext4）\r\r文件系统中存储的最小单位是块（Block）Ext2文件系统将整个分区划成若干个同样大小的块组（Block Group），如图1所示，每个块组都由以下部分组成：\n\r![磁盘分区和文件系统结构图](linux-文件系统/image1.png)\r![图2](linux-文件系统/图片2.png)\n\r## 1. Super Block（超级块）\r描述整个分区的文件系统信息，例如块大小、文件系统版本号、上次mount的时间等等。超级块在每个块组的开头都有一份拷贝。\r\r先介绍几个结构体：\r\r### file结构体：\r存在于task_struct的 文件描述符表 的每个元素指向的内存中。fd为文件描述符表的索引。文件描述符表  是个指针数组，每个元素指向一个file结构体。\r\r文件结构体代表一个打开的文件，系统中的每个打开的文件在内核空间都有一个关联的 struct file。它由内核在打开文件时创建，并传递给在文件上进行操作的任何函数。在文件的所有实例都关闭后，内核释放这个数据结构。并且一个文件即使是在一个进程中多次打开，也会存在多个file结构。（http://blog.sina.com.cn/s/blog_7943319e01018m3w.html）\r\r为什么要设置file结构体？\r\t因为linux下，文件是共享的。意味着多个进程对这个文件的读写有着不同的偏移量。首先文件偏移量不能放在inode，因为多个进程可能会共享一个inode。所以只能创建一个中间结构struct file 来保存文件偏移量。即使是这样，父进程和子进程还是有这方面问题的矛盾。因为子进程会继承父进程打开的文件，也就是说，子进程的文件描述符表和父进程的文件描述符表指向的是同一组file结构（仅仅增加了file结构体中的引用计数）。所以，子进程对文件偏移量的操作必然会影响到父进程。所以，一般在父进程和子进程之间需要同步机制或者在父子进程中分别关闭不用的文件，以免互相影响。(详细见http://woshiniezhenhua.blog.163.com/blog/static/191376928201291344920408/      http://www.tuicool.com/articles/I3AZF3）\t\t\r几个比较重要的元素：\r\r1. \tf_flag：文件标志， O_RDONLY, O_NONBLOCK, 和 O_SYNC. 驱动应当检查O_NONBLOCK 标志来看是否是请求非阻塞操作。\r2. f_count：引用计数\r3. f_pos：文件偏移量\r4. f_dentry：关联到文件的目录入口( dentry )结构. 设备驱动编写者正常地不需要关心 dentry 结构, 除了作为 filp->f_dentry->d_inode 存取 inode 结构.\r\r说道这里，文件是怎么共享的？\r### 静态共享和动态共享\r静态共享分为硬链接和软链接。\r\r二者的区别是，硬链接修改文件目录项，把两个不同名的文件的inode指针指向同一个inode。\r而软链接则是使用另外一个独立的文件，只不过文件内容是需要指向文件的路径名。然后使用某个系统调用，利用路径名打开指向的文件，实现共享。\r\r- 硬链接的优点是简单，但是不能跨越文件系统。\r- 软链接的优点是可以跨越文件系统，但是要占用额外的空间和inode，而且容易形成死链的情况。\r- 最重要的是，无论是硬链接还是软连接，都属于静态链接，他们最终映射到同一个inode，但是两个进程持有不同的file结构，也就是说，静态链接不能实现共享偏移量。\r动态共享\r\t\r为什么会出现动态共享，是为了解决上面说的不能共享读写偏移量的问题。现实生活中，有两种需求。一种是需要共享读写指针，另一种是不需要共享。为了实现前者，linux系统提出了系统打开文件表的概念。\r主要是将一些需要被共享的file结构体统一放在系统打开文件表中。如果两个进程希望共享文件读写指针，则使二者的文件描述符表指向系统打开文件表中的同一个file结构体。而如果不需要共享，则指向不同的系统打开文件表即可。\r\rdentry结构体，只需要知道其中有指向inode的指针即可\r\ropen函数的执行过程（http://blog.chinaunix.net/uid-25968088-id-3426026.html）\r（1）task_sruct中保存有该进程可以使用的但是未使用的文件描述符，先通过某个函数获取一个文件描述符。\r（2）在task_struct的文件描述符表中文件描述符对应的位置初始化一个file指针，并分配一个全新的file结构体。\r（3）利用传入的参数查找或者建立dentry，并绑定inode，至此，file结构的初始化到此为止。\r（4）建立fd与file结构的关系，返回fd、\r网络教程：\r\r1.  找到一个本进程没有使用的文件描述符fd（int型）\r2.  分配一个全新的struct file结构体\r3.  根据传人的pathname查找或建立对应的dentry\r4.  建立fd到这个struct file结构体的联系\r\r\rread函数的执行过程（http://blog.csdn.net/lwj103862095/article/details/38518069）\r\r![图4](linux-文件系统/图片4.png)\r\r图1显示了 read 系统调用在核心空间中所要经历的层次模型。从图中看出：对于磁盘的一次读请求，首先经过虚拟文件系统层（vfs layer），其次是具体的文件系统层（例如 ext2），接下来是 cache 层（page cache 层）、通用块层（generic block layer）、IO 调度层（I/O scheduler layer）、块设备驱动层（block device driver layer），最后是物理块设备层（block device layer）\r\r1. 虚拟文件系统层的作用：屏蔽下层具体文件系统操作的差异，为上层的操作提供一个统一的接口。正是因为有了这个层次，所以可以把设备抽象成文件，使得操作设备就像操作文件一样简单。\r2. 在具体的文件系统层中，不同的文件系统（例如 ext2 和 NTFS）具体的操作过程也是不同的。每种文件系统定义了自己的操作集合。关于文件系统的更多内容，请参见参考资料。\r3. 引入 cache 层的目的是为了提高 linux 操作系统对磁盘访问的性能。 Cache 层在内存中缓存了磁盘上的部分数据。当数据的请求到达时，如果在 cache 中存在该数据且是最新的，则直接将数据传递给用户程序，免除了对底层磁盘的操作，提高了性能。\r4. 通用块层的主要工作是：接收上层发出的磁盘请求，并最终发出 IO 请求。该层隐藏了底层硬件块设备的特性，为块设备提供了一个通用的抽象视图。\r5. IO 调度层的功能：接收通用块层发出的 IO 请求，缓存请求并试图合并相邻的请求（如果这两个请求的数据在磁盘上是相邻的）。并根据设置好的调度算法，回调驱动层提供的请求处理函数，以处理具体的 IO 请求。\r6. 驱动层中的驱动程序对应具体的物理块设备。它从上层中取出 IO 请求，并根据该 IO 请求中指定的信息，通过向具体块设备的设备控制器发送命令的方式，来操纵设备传输数据。\r7. 设备层中都是具体的物理设备。定义了操作具体设备的规范。\r\r### 相关的内核数据结构：\r\r- Dentry ： 联系了文件名和文件的 i 节点  \r- inode ： 文件 i 节点，保存文件标识、权限和内容等信息  \r- file ： 保存文件的相关信息和各种操作文件的函数指针集合  \r- file_operations ：操作文件的函数接口集合  \r- address_space ：描述文件的 page cache 结构以及相关信息，并包含有操作 page cache 的函数指针集合  \r- address_space_operations ：操作 page cache 的函数接口集合  \r- bio ： IO 请求的描述  \r\r![图5](linux-文件系统/图片5.png)\r\r图5显示了一个文件的 page cache 结构。文件被分割为一个个以 page 大小为单元的数据块,这些数据块（页）被组织成一个多叉树（称为 radix 树）。此树的层次可以从0层到6层，所支持的文件大小从0字节到16 T 个字节。树的根节点指针可以从和文件相关的 address_space 对象（该对象保存在和文件关联的 inode 对象中）中取得\r\r\r（1）产生系统调用，in0x80，根据中断号，在中断向量表中找到read函数的入口地址，将cpu执行权给read系统调用。\r（2）read通过传入的fd，取出file结构体中的文件偏移量，并通过dentry找到inode结构。\r（3）inode中存放着该文件对应的page cache的结构以及相关信息，并且有一组操纵page cache结构的函数指针。read在真正向底层发送读取信息之前，会先操纵page cache 来查看 \r其中有没有需要读取的页。如果有，有专门函数讲page chache 中的数据拷贝到用户空间，read调用链到此结束。如果没有，lock计算出的页，则向下层发送添页请求，当再次lock成功时，说明数据已经在page cache 中了，拷贝到用户空间，结束。\r\r\r# 文件操作的一般步骤：\r1. 根据路径名找到对应的dentry结构，并绑定inode。\r2. 根据dentry找到inode\r3. 根据inode中的某个数组获得对应文件的信息存放在哪些数据块上。\r4. 调用文件系统函数向更下一层发送命令，从而从磁盘读取数据。\r# page cache机制：\r\tlinux访问文件的方式分为直接IO和非直接IO两大类。其中，非直接IO就会用到page cache。上层程序写的数据先写到page cache，再有内核线程定期刷到磁盘。用户程序需要读的数据，先读到page cache，再从page cache拷贝到用户空间。\r\r# ext2文件系统\rext2文件系统会将磁盘空间格式化为几个部分，分别保存\r\r1. MBR ：MBR的作用是把操作系统自己的引导程序读入内存并跳转到操作系统的引导程序。本身与任何操作系统无关。MBR前446字节是主引导记录，后64字节是分区表。最后2个字节是结束标志。（具体我讲）\r2. inode信息\r3. 真正的数据\r\r但是如果一个文件系统容量很大，那么将所有的inode和block都放在一起管理很不明智的。所以便有了块组的概念。\r\t\r超级块描述了整个文件系统的信息，比如大小，inode/block的总数,已使用数量和剩余数量，其他文件系统的信息。\rblock块组描述符则也类似，描述了一个块组的信息，例如在这个块组中从哪里开始是inode表，从哪里开始是数据块，空闲的inode和数据块还有多少个等等。块描述符和超级块一样，在每个块组开头都有一份拷贝，系统一般只使用到第0组的拷贝。一个块组中的所有inode组成了一个inode表。这里还有块位图，inode位图的概念。\r# lvm磁盘组织结构图 \r\r![图6](linux-文件系统/图片6.png)\r\t\r","source":"_posts/linux-文件系统.md","raw":"---\ntitle: linux 文件系统\ncomments: true\ntags:\n  - LINUX\n  - 文件系统\ncategories:\n  - LINUX\ndate: 2017-03-05 18:00:46\nupdate: 2017-03-05 18:00:46\n\n---\n\r# 文件系统\r\r概念：是操作系统的一部分，用来管理磁盘空间，向外提供操纵接口。比如fread，fwrite，fopen等系统调用就是文件系统提供的功能。\r\r作用：管理用户的逻辑文件，替用户保存逻辑文件到存储块的映射。并提供缓存机制，做到存取速度快，存储空间利用率高，数据安全性好。\r\r>NFS（Network File System）即网络文件系统  \r>NTFS (New Technology File System)  \r>FAT是文件配置表（英语：File Allocation Table，首字母缩略字：FAT）  \r>EXT4是第四代扩展文件系统（英语：Fourth extended filesystem，缩写为 ext4）\r\r文件系统中存储的最小单位是块（Block）Ext2文件系统将整个分区划成若干个同样大小的块组（Block Group），如图1所示，每个块组都由以下部分组成：\n\r![磁盘分区和文件系统结构图](linux-文件系统/image1.png)\r![图2](linux-文件系统/图片2.png)\n\r## 1. Super Block（超级块）\r描述整个分区的文件系统信息，例如块大小、文件系统版本号、上次mount的时间等等。超级块在每个块组的开头都有一份拷贝。\r\r先介绍几个结构体：\r\r### file结构体：\r存在于task_struct的 文件描述符表 的每个元素指向的内存中。fd为文件描述符表的索引。文件描述符表  是个指针数组，每个元素指向一个file结构体。\r\r文件结构体代表一个打开的文件，系统中的每个打开的文件在内核空间都有一个关联的 struct file。它由内核在打开文件时创建，并传递给在文件上进行操作的任何函数。在文件的所有实例都关闭后，内核释放这个数据结构。并且一个文件即使是在一个进程中多次打开，也会存在多个file结构。（http://blog.sina.com.cn/s/blog_7943319e01018m3w.html）\r\r为什么要设置file结构体？\r\t因为linux下，文件是共享的。意味着多个进程对这个文件的读写有着不同的偏移量。首先文件偏移量不能放在inode，因为多个进程可能会共享一个inode。所以只能创建一个中间结构struct file 来保存文件偏移量。即使是这样，父进程和子进程还是有这方面问题的矛盾。因为子进程会继承父进程打开的文件，也就是说，子进程的文件描述符表和父进程的文件描述符表指向的是同一组file结构（仅仅增加了file结构体中的引用计数）。所以，子进程对文件偏移量的操作必然会影响到父进程。所以，一般在父进程和子进程之间需要同步机制或者在父子进程中分别关闭不用的文件，以免互相影响。(详细见http://woshiniezhenhua.blog.163.com/blog/static/191376928201291344920408/      http://www.tuicool.com/articles/I3AZF3）\t\t\r几个比较重要的元素：\r\r1. \tf_flag：文件标志， O_RDONLY, O_NONBLOCK, 和 O_SYNC. 驱动应当检查O_NONBLOCK 标志来看是否是请求非阻塞操作。\r2. f_count：引用计数\r3. f_pos：文件偏移量\r4. f_dentry：关联到文件的目录入口( dentry )结构. 设备驱动编写者正常地不需要关心 dentry 结构, 除了作为 filp->f_dentry->d_inode 存取 inode 结构.\r\r说道这里，文件是怎么共享的？\r### 静态共享和动态共享\r静态共享分为硬链接和软链接。\r\r二者的区别是，硬链接修改文件目录项，把两个不同名的文件的inode指针指向同一个inode。\r而软链接则是使用另外一个独立的文件，只不过文件内容是需要指向文件的路径名。然后使用某个系统调用，利用路径名打开指向的文件，实现共享。\r\r- 硬链接的优点是简单，但是不能跨越文件系统。\r- 软链接的优点是可以跨越文件系统，但是要占用额外的空间和inode，而且容易形成死链的情况。\r- 最重要的是，无论是硬链接还是软连接，都属于静态链接，他们最终映射到同一个inode，但是两个进程持有不同的file结构，也就是说，静态链接不能实现共享偏移量。\r动态共享\r\t\r为什么会出现动态共享，是为了解决上面说的不能共享读写偏移量的问题。现实生活中，有两种需求。一种是需要共享读写指针，另一种是不需要共享。为了实现前者，linux系统提出了系统打开文件表的概念。\r主要是将一些需要被共享的file结构体统一放在系统打开文件表中。如果两个进程希望共享文件读写指针，则使二者的文件描述符表指向系统打开文件表中的同一个file结构体。而如果不需要共享，则指向不同的系统打开文件表即可。\r\rdentry结构体，只需要知道其中有指向inode的指针即可\r\ropen函数的执行过程（http://blog.chinaunix.net/uid-25968088-id-3426026.html）\r（1）task_sruct中保存有该进程可以使用的但是未使用的文件描述符，先通过某个函数获取一个文件描述符。\r（2）在task_struct的文件描述符表中文件描述符对应的位置初始化一个file指针，并分配一个全新的file结构体。\r（3）利用传入的参数查找或者建立dentry，并绑定inode，至此，file结构的初始化到此为止。\r（4）建立fd与file结构的关系，返回fd、\r网络教程：\r\r1.  找到一个本进程没有使用的文件描述符fd（int型）\r2.  分配一个全新的struct file结构体\r3.  根据传人的pathname查找或建立对应的dentry\r4.  建立fd到这个struct file结构体的联系\r\r\rread函数的执行过程（http://blog.csdn.net/lwj103862095/article/details/38518069）\r\r![图4](linux-文件系统/图片4.png)\r\r图1显示了 read 系统调用在核心空间中所要经历的层次模型。从图中看出：对于磁盘的一次读请求，首先经过虚拟文件系统层（vfs layer），其次是具体的文件系统层（例如 ext2），接下来是 cache 层（page cache 层）、通用块层（generic block layer）、IO 调度层（I/O scheduler layer）、块设备驱动层（block device driver layer），最后是物理块设备层（block device layer）\r\r1. 虚拟文件系统层的作用：屏蔽下层具体文件系统操作的差异，为上层的操作提供一个统一的接口。正是因为有了这个层次，所以可以把设备抽象成文件，使得操作设备就像操作文件一样简单。\r2. 在具体的文件系统层中，不同的文件系统（例如 ext2 和 NTFS）具体的操作过程也是不同的。每种文件系统定义了自己的操作集合。关于文件系统的更多内容，请参见参考资料。\r3. 引入 cache 层的目的是为了提高 linux 操作系统对磁盘访问的性能。 Cache 层在内存中缓存了磁盘上的部分数据。当数据的请求到达时，如果在 cache 中存在该数据且是最新的，则直接将数据传递给用户程序，免除了对底层磁盘的操作，提高了性能。\r4. 通用块层的主要工作是：接收上层发出的磁盘请求，并最终发出 IO 请求。该层隐藏了底层硬件块设备的特性，为块设备提供了一个通用的抽象视图。\r5. IO 调度层的功能：接收通用块层发出的 IO 请求，缓存请求并试图合并相邻的请求（如果这两个请求的数据在磁盘上是相邻的）。并根据设置好的调度算法，回调驱动层提供的请求处理函数，以处理具体的 IO 请求。\r6. 驱动层中的驱动程序对应具体的物理块设备。它从上层中取出 IO 请求，并根据该 IO 请求中指定的信息，通过向具体块设备的设备控制器发送命令的方式，来操纵设备传输数据。\r7. 设备层中都是具体的物理设备。定义了操作具体设备的规范。\r\r### 相关的内核数据结构：\r\r- Dentry ： 联系了文件名和文件的 i 节点  \r- inode ： 文件 i 节点，保存文件标识、权限和内容等信息  \r- file ： 保存文件的相关信息和各种操作文件的函数指针集合  \r- file_operations ：操作文件的函数接口集合  \r- address_space ：描述文件的 page cache 结构以及相关信息，并包含有操作 page cache 的函数指针集合  \r- address_space_operations ：操作 page cache 的函数接口集合  \r- bio ： IO 请求的描述  \r\r![图5](linux-文件系统/图片5.png)\r\r图5显示了一个文件的 page cache 结构。文件被分割为一个个以 page 大小为单元的数据块,这些数据块（页）被组织成一个多叉树（称为 radix 树）。此树的层次可以从0层到6层，所支持的文件大小从0字节到16 T 个字节。树的根节点指针可以从和文件相关的 address_space 对象（该对象保存在和文件关联的 inode 对象中）中取得\r\r\r（1）产生系统调用，in0x80，根据中断号，在中断向量表中找到read函数的入口地址，将cpu执行权给read系统调用。\r（2）read通过传入的fd，取出file结构体中的文件偏移量，并通过dentry找到inode结构。\r（3）inode中存放着该文件对应的page cache的结构以及相关信息，并且有一组操纵page cache结构的函数指针。read在真正向底层发送读取信息之前，会先操纵page cache 来查看 \r其中有没有需要读取的页。如果有，有专门函数讲page chache 中的数据拷贝到用户空间，read调用链到此结束。如果没有，lock计算出的页，则向下层发送添页请求，当再次lock成功时，说明数据已经在page cache 中了，拷贝到用户空间，结束。\r\r\r# 文件操作的一般步骤：\r1. 根据路径名找到对应的dentry结构，并绑定inode。\r2. 根据dentry找到inode\r3. 根据inode中的某个数组获得对应文件的信息存放在哪些数据块上。\r4. 调用文件系统函数向更下一层发送命令，从而从磁盘读取数据。\r# page cache机制：\r\tlinux访问文件的方式分为直接IO和非直接IO两大类。其中，非直接IO就会用到page cache。上层程序写的数据先写到page cache，再有内核线程定期刷到磁盘。用户程序需要读的数据，先读到page cache，再从page cache拷贝到用户空间。\r\r# ext2文件系统\rext2文件系统会将磁盘空间格式化为几个部分，分别保存\r\r1. MBR ：MBR的作用是把操作系统自己的引导程序读入内存并跳转到操作系统的引导程序。本身与任何操作系统无关。MBR前446字节是主引导记录，后64字节是分区表。最后2个字节是结束标志。（具体我讲）\r2. inode信息\r3. 真正的数据\r\r但是如果一个文件系统容量很大，那么将所有的inode和block都放在一起管理很不明智的。所以便有了块组的概念。\r\t\r超级块描述了整个文件系统的信息，比如大小，inode/block的总数,已使用数量和剩余数量，其他文件系统的信息。\rblock块组描述符则也类似，描述了一个块组的信息，例如在这个块组中从哪里开始是inode表，从哪里开始是数据块，空闲的inode和数据块还有多少个等等。块描述符和超级块一样，在每个块组开头都有一份拷贝，系统一般只使用到第0组的拷贝。一个块组中的所有inode组成了一个inode表。这里还有块位图，inode位图的概念。\r# lvm磁盘组织结构图 \r\r![图6](linux-文件系统/图片6.png)\r\t\r","slug":"linux-文件系统","published":1,"updated":"2017-09-02T10:13:06.000Z","layout":"post","photos":[],"link":"","_id":"cjd4d1a0c0016ryx48od9pqbc","content":"<h1 id=\"文件系统\"><a href=\"#文件系统\" class=\"headerlink\" title=\"文件系统\"></a>文件系统</h1><p>概念：是操作系统的一部分，用来管理磁盘空间，向外提供操纵接口。比如fread，fwrite，fopen等系统调用就是文件系统提供的功能。</p>\n<p>作用：管理用户的逻辑文件，替用户保存逻辑文件到存储块的映射。并提供缓存机制，做到存取速度快，存储空间利用率高，数据安全性好。</p>\n<blockquote>\n<p>NFS（Network File System）即网络文件系统<br>NTFS (New Technology File System)<br>FAT是文件配置表（英语：File Allocation Table，首字母缩略字：FAT）<br>EXT4是第四代扩展文件系统（英语：Fourth extended filesystem，缩写为 ext4）</p>\n</blockquote>\n<p>文件系统中存储的最小单位是块（Block）Ext2文件系统将整个分区划成若干个同样大小的块组（Block Group），如图1所示，每个块组都由以下部分组成：</p>\n<p><img src=\"linux-文件系统/image1.png\" alt=\"磁盘分区和文件系统结构图\"><br><img src=\"linux-文件系统/图片2.png\" alt=\"图2\"></p>\n<h2 id=\"1-Super-Block（超级块）\"><a href=\"#1-Super-Block（超级块）\" class=\"headerlink\" title=\"1. Super Block（超级块）\"></a>1. Super Block（超级块）</h2><p>描述整个分区的文件系统信息，例如块大小、文件系统版本号、上次mount的时间等等。超级块在每个块组的开头都有一份拷贝。</p>\n<p>先介绍几个结构体：</p>\n<h3 id=\"file结构体：\"><a href=\"#file结构体：\" class=\"headerlink\" title=\"file结构体：\"></a>file结构体：</h3><p>存在于task_struct的 文件描述符表 的每个元素指向的内存中。fd为文件描述符表的索引。文件描述符表  是个指针数组，每个元素指向一个file结构体。</p>\n<p>文件结构体代表一个打开的文件，系统中的每个打开的文件在内核空间都有一个关联的 struct file。它由内核在打开文件时创建，并传递给在文件上进行操作的任何函数。在文件的所有实例都关闭后，内核释放这个数据结构。并且一个文件即使是在一个进程中多次打开，也会存在多个file结构。（<a href=\"http://blog.sina.com.cn/s/blog_7943319e01018m3w.html）\" target=\"_blank\" rel=\"external\">http://blog.sina.com.cn/s/blog_7943319e01018m3w.html）</a></p>\n<p>为什么要设置file结构体？<br>    因为linux下，文件是共享的。意味着多个进程对这个文件的读写有着不同的偏移量。首先文件偏移量不能放在inode，因为多个进程可能会共享一个inode。所以只能创建一个中间结构struct file 来保存文件偏移量。即使是这样，父进程和子进程还是有这方面问题的矛盾。因为子进程会继承父进程打开的文件，也就是说，子进程的文件描述符表和父进程的文件描述符表指向的是同一组file结构（仅仅增加了file结构体中的引用计数）。所以，子进程对文件偏移量的操作必然会影响到父进程。所以，一般在父进程和子进程之间需要同步机制或者在父子进程中分别关闭不用的文件，以免互相影响。(详细见<a href=\"http://woshiniezhenhua.blog.163.com/blog/static/191376928201291344920408/\" target=\"_blank\" rel=\"external\">http://woshiniezhenhua.blog.163.com/blog/static/191376928201291344920408/</a>      <a href=\"http://www.tuicool.com/articles/I3AZF3）\" target=\"_blank\" rel=\"external\">http://www.tuicool.com/articles/I3AZF3）</a><br>几个比较重要的元素：</p>\n<ol>\n<li>f_flag：文件标志， O_RDONLY, O_NONBLOCK, 和 O_SYNC. 驱动应当检查O_NONBLOCK 标志来看是否是请求非阻塞操作。</li>\n<li>f_count：引用计数</li>\n<li>f_pos：文件偏移量</li>\n<li>f_dentry：关联到文件的目录入口( dentry )结构. 设备驱动编写者正常地不需要关心 dentry 结构, 除了作为 filp-&gt;f_dentry-&gt;d_inode 存取 inode 结构.</li>\n</ol>\n<p>说道这里，文件是怎么共享的？</p>\n<h3 id=\"静态共享和动态共享\"><a href=\"#静态共享和动态共享\" class=\"headerlink\" title=\"静态共享和动态共享\"></a>静态共享和动态共享</h3><p>静态共享分为硬链接和软链接。</p>\n<p>二者的区别是，硬链接修改文件目录项，把两个不同名的文件的inode指针指向同一个inode。<br>而软链接则是使用另外一个独立的文件，只不过文件内容是需要指向文件的路径名。然后使用某个系统调用，利用路径名打开指向的文件，实现共享。</p>\n<ul>\n<li>硬链接的优点是简单，但是不能跨越文件系统。</li>\n<li>软链接的优点是可以跨越文件系统，但是要占用额外的空间和inode，而且容易形成死链的情况。</li>\n<li>最重要的是，无论是硬链接还是软连接，都属于静态链接，他们最终映射到同一个inode，但是两个进程持有不同的file结构，也就是说，静态链接不能实现共享偏移量。<br>动态共享</li>\n</ul>\n<p>为什么会出现动态共享，是为了解决上面说的不能共享读写偏移量的问题。现实生活中，有两种需求。一种是需要共享读写指针，另一种是不需要共享。为了实现前者，linux系统提出了系统打开文件表的概念。<br>主要是将一些需要被共享的file结构体统一放在系统打开文件表中。如果两个进程希望共享文件读写指针，则使二者的文件描述符表指向系统打开文件表中的同一个file结构体。而如果不需要共享，则指向不同的系统打开文件表即可。</p>\n<p>dentry结构体，只需要知道其中有指向inode的指针即可</p>\n<p>open函数的执行过程（<a href=\"http://blog.chinaunix.net/uid-25968088-id-3426026.html）\" target=\"_blank\" rel=\"external\">http://blog.chinaunix.net/uid-25968088-id-3426026.html）</a><br>（1）task_sruct中保存有该进程可以使用的但是未使用的文件描述符，先通过某个函数获取一个文件描述符。<br>（2）在task_struct的文件描述符表中文件描述符对应的位置初始化一个file指针，并分配一个全新的file结构体。<br>（3）利用传入的参数查找或者建立dentry，并绑定inode，至此，file结构的初始化到此为止。<br>（4）建立fd与file结构的关系，返回fd、<br>网络教程：</p>\n<ol>\n<li>找到一个本进程没有使用的文件描述符fd（int型）</li>\n<li>分配一个全新的struct file结构体</li>\n<li>根据传人的pathname查找或建立对应的dentry</li>\n<li>建立fd到这个struct file结构体的联系</li>\n</ol>\n<p>read函数的执行过程（<a href=\"http://blog.csdn.net/lwj103862095/article/details/38518069）\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/lwj103862095/article/details/38518069）</a></p>\n<p><img src=\"linux-文件系统/图片4.png\" alt=\"图4\"></p>\n<p>图1显示了 read 系统调用在核心空间中所要经历的层次模型。从图中看出：对于磁盘的一次读请求，首先经过虚拟文件系统层（vfs layer），其次是具体的文件系统层（例如 ext2），接下来是 cache 层（page cache 层）、通用块层（generic block layer）、IO 调度层（I/O scheduler layer）、块设备驱动层（block device driver layer），最后是物理块设备层（block device layer）</p>\n<ol>\n<li>虚拟文件系统层的作用：屏蔽下层具体文件系统操作的差异，为上层的操作提供一个统一的接口。正是因为有了这个层次，所以可以把设备抽象成文件，使得操作设备就像操作文件一样简单。</li>\n<li>在具体的文件系统层中，不同的文件系统（例如 ext2 和 NTFS）具体的操作过程也是不同的。每种文件系统定义了自己的操作集合。关于文件系统的更多内容，请参见参考资料。</li>\n<li>引入 cache 层的目的是为了提高 linux 操作系统对磁盘访问的性能。 Cache 层在内存中缓存了磁盘上的部分数据。当数据的请求到达时，如果在 cache 中存在该数据且是最新的，则直接将数据传递给用户程序，免除了对底层磁盘的操作，提高了性能。</li>\n<li>通用块层的主要工作是：接收上层发出的磁盘请求，并最终发出 IO 请求。该层隐藏了底层硬件块设备的特性，为块设备提供了一个通用的抽象视图。</li>\n<li>IO 调度层的功能：接收通用块层发出的 IO 请求，缓存请求并试图合并相邻的请求（如果这两个请求的数据在磁盘上是相邻的）。并根据设置好的调度算法，回调驱动层提供的请求处理函数，以处理具体的 IO 请求。</li>\n<li>驱动层中的驱动程序对应具体的物理块设备。它从上层中取出 IO 请求，并根据该 IO 请求中指定的信息，通过向具体块设备的设备控制器发送命令的方式，来操纵设备传输数据。</li>\n<li>设备层中都是具体的物理设备。定义了操作具体设备的规范。</li>\n</ol>\n<h3 id=\"相关的内核数据结构：\"><a href=\"#相关的内核数据结构：\" class=\"headerlink\" title=\"相关的内核数据结构：\"></a>相关的内核数据结构：</h3><ul>\n<li>Dentry ： 联系了文件名和文件的 i 节点  </li>\n<li>inode ： 文件 i 节点，保存文件标识、权限和内容等信息  </li>\n<li>file ： 保存文件的相关信息和各种操作文件的函数指针集合  </li>\n<li>file_operations ：操作文件的函数接口集合  </li>\n<li>address_space ：描述文件的 page cache 结构以及相关信息，并包含有操作 page cache 的函数指针集合  </li>\n<li>address_space_operations ：操作 page cache 的函数接口集合  </li>\n<li>bio ： IO 请求的描述  </li>\n</ul>\n<p><img src=\"linux-文件系统/图片5.png\" alt=\"图5\"></p>\n<p>图5显示了一个文件的 page cache 结构。文件被分割为一个个以 page 大小为单元的数据块,这些数据块（页）被组织成一个多叉树（称为 radix 树）。此树的层次可以从0层到6层，所支持的文件大小从0字节到16 T 个字节。树的根节点指针可以从和文件相关的 address_space 对象（该对象保存在和文件关联的 inode 对象中）中取得</p>\n<p>（1）产生系统调用，in0x80，根据中断号，在中断向量表中找到read函数的入口地址，将cpu执行权给read系统调用。<br>（2）read通过传入的fd，取出file结构体中的文件偏移量，并通过dentry找到inode结构。<br>（3）inode中存放着该文件对应的page cache的结构以及相关信息，并且有一组操纵page cache结构的函数指针。read在真正向底层发送读取信息之前，会先操纵page cache 来查看<br>其中有没有需要读取的页。如果有，有专门函数讲page chache 中的数据拷贝到用户空间，read调用链到此结束。如果没有，lock计算出的页，则向下层发送添页请求，当再次lock成功时，说明数据已经在page cache 中了，拷贝到用户空间，结束。</p>\n<h1 id=\"文件操作的一般步骤：\"><a href=\"#文件操作的一般步骤：\" class=\"headerlink\" title=\"文件操作的一般步骤：\"></a>文件操作的一般步骤：</h1><ol>\n<li>根据路径名找到对应的dentry结构，并绑定inode。</li>\n<li>根据dentry找到inode</li>\n<li>根据inode中的某个数组获得对应文件的信息存放在哪些数据块上。</li>\n<li>调用文件系统函数向更下一层发送命令，从而从磁盘读取数据。<h1 id=\"page-cache机制：\"><a href=\"#page-cache机制：\" class=\"headerlink\" title=\"page cache机制：\"></a>page cache机制：</h1> linux访问文件的方式分为直接IO和非直接IO两大类。其中，非直接IO就会用到page cache。上层程序写的数据先写到page cache，再有内核线程定期刷到磁盘。用户程序需要读的数据，先读到page cache，再从page cache拷贝到用户空间。</li>\n</ol>\n<h1 id=\"ext2文件系统\"><a href=\"#ext2文件系统\" class=\"headerlink\" title=\"ext2文件系统\"></a>ext2文件系统</h1><p>ext2文件系统会将磁盘空间格式化为几个部分，分别保存</p>\n<ol>\n<li>MBR ：MBR的作用是把操作系统自己的引导程序读入内存并跳转到操作系统的引导程序。本身与任何操作系统无关。MBR前446字节是主引导记录，后64字节是分区表。最后2个字节是结束标志。（具体我讲）</li>\n<li>inode信息</li>\n<li>真正的数据</li>\n</ol>\n<p>但是如果一个文件系统容量很大，那么将所有的inode和block都放在一起管理很不明智的。所以便有了块组的概念。</p>\n<p>超级块描述了整个文件系统的信息，比如大小，inode/block的总数,已使用数量和剩余数量，其他文件系统的信息。<br>block块组描述符则也类似，描述了一个块组的信息，例如在这个块组中从哪里开始是inode表，从哪里开始是数据块，空闲的inode和数据块还有多少个等等。块描述符和超级块一样，在每个块组开头都有一份拷贝，系统一般只使用到第0组的拷贝。一个块组中的所有inode组成了一个inode表。这里还有块位图，inode位图的概念。</p>\n<h1 id=\"lvm磁盘组织结构图\"><a href=\"#lvm磁盘组织结构图\" class=\"headerlink\" title=\"lvm磁盘组织结构图\"></a>lvm磁盘组织结构图</h1><p><img src=\"linux-文件系统/图片6.png\" alt=\"图6\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"文件系统\"><a href=\"#文件系统\" class=\"headerlink\" title=\"文件系统\"></a>文件系统</h1><p>概念：是操作系统的一部分，用来管理磁盘空间，向外提供操纵接口。比如fread，fwrite，fopen等系统调用就是文件系统提供的功能。</p>\n<p>作用：管理用户的逻辑文件，替用户保存逻辑文件到存储块的映射。并提供缓存机制，做到存取速度快，存储空间利用率高，数据安全性好。</p>\n<blockquote>\n<p>NFS（Network File System）即网络文件系统<br>NTFS (New Technology File System)<br>FAT是文件配置表（英语：File Allocation Table，首字母缩略字：FAT）<br>EXT4是第四代扩展文件系统（英语：Fourth extended filesystem，缩写为 ext4）</p>\n</blockquote>\n<p>文件系统中存储的最小单位是块（Block）Ext2文件系统将整个分区划成若干个同样大小的块组（Block Group），如图1所示，每个块组都由以下部分组成：</p>\n<p><img src=\"linux-文件系统/image1.png\" alt=\"磁盘分区和文件系统结构图\"><br><img src=\"linux-文件系统/图片2.png\" alt=\"图2\"></p>\n<h2 id=\"1-Super-Block（超级块）\"><a href=\"#1-Super-Block（超级块）\" class=\"headerlink\" title=\"1. Super Block（超级块）\"></a>1. Super Block（超级块）</h2><p>描述整个分区的文件系统信息，例如块大小、文件系统版本号、上次mount的时间等等。超级块在每个块组的开头都有一份拷贝。</p>\n<p>先介绍几个结构体：</p>\n<h3 id=\"file结构体：\"><a href=\"#file结构体：\" class=\"headerlink\" title=\"file结构体：\"></a>file结构体：</h3><p>存在于task_struct的 文件描述符表 的每个元素指向的内存中。fd为文件描述符表的索引。文件描述符表  是个指针数组，每个元素指向一个file结构体。</p>\n<p>文件结构体代表一个打开的文件，系统中的每个打开的文件在内核空间都有一个关联的 struct file。它由内核在打开文件时创建，并传递给在文件上进行操作的任何函数。在文件的所有实例都关闭后，内核释放这个数据结构。并且一个文件即使是在一个进程中多次打开，也会存在多个file结构。（<a href=\"http://blog.sina.com.cn/s/blog_7943319e01018m3w.html）\" target=\"_blank\" rel=\"external\">http://blog.sina.com.cn/s/blog_7943319e01018m3w.html）</a></p>\n<p>为什么要设置file结构体？<br>    因为linux下，文件是共享的。意味着多个进程对这个文件的读写有着不同的偏移量。首先文件偏移量不能放在inode，因为多个进程可能会共享一个inode。所以只能创建一个中间结构struct file 来保存文件偏移量。即使是这样，父进程和子进程还是有这方面问题的矛盾。因为子进程会继承父进程打开的文件，也就是说，子进程的文件描述符表和父进程的文件描述符表指向的是同一组file结构（仅仅增加了file结构体中的引用计数）。所以，子进程对文件偏移量的操作必然会影响到父进程。所以，一般在父进程和子进程之间需要同步机制或者在父子进程中分别关闭不用的文件，以免互相影响。(详细见<a href=\"http://woshiniezhenhua.blog.163.com/blog/static/191376928201291344920408/\" target=\"_blank\" rel=\"external\">http://woshiniezhenhua.blog.163.com/blog/static/191376928201291344920408/</a>      <a href=\"http://www.tuicool.com/articles/I3AZF3）\" target=\"_blank\" rel=\"external\">http://www.tuicool.com/articles/I3AZF3）</a><br>几个比较重要的元素：</p>\n<ol>\n<li>f_flag：文件标志， O_RDONLY, O_NONBLOCK, 和 O_SYNC. 驱动应当检查O_NONBLOCK 标志来看是否是请求非阻塞操作。</li>\n<li>f_count：引用计数</li>\n<li>f_pos：文件偏移量</li>\n<li>f_dentry：关联到文件的目录入口( dentry )结构. 设备驱动编写者正常地不需要关心 dentry 结构, 除了作为 filp-&gt;f_dentry-&gt;d_inode 存取 inode 结构.</li>\n</ol>\n<p>说道这里，文件是怎么共享的？</p>\n<h3 id=\"静态共享和动态共享\"><a href=\"#静态共享和动态共享\" class=\"headerlink\" title=\"静态共享和动态共享\"></a>静态共享和动态共享</h3><p>静态共享分为硬链接和软链接。</p>\n<p>二者的区别是，硬链接修改文件目录项，把两个不同名的文件的inode指针指向同一个inode。<br>而软链接则是使用另外一个独立的文件，只不过文件内容是需要指向文件的路径名。然后使用某个系统调用，利用路径名打开指向的文件，实现共享。</p>\n<ul>\n<li>硬链接的优点是简单，但是不能跨越文件系统。</li>\n<li>软链接的优点是可以跨越文件系统，但是要占用额外的空间和inode，而且容易形成死链的情况。</li>\n<li>最重要的是，无论是硬链接还是软连接，都属于静态链接，他们最终映射到同一个inode，但是两个进程持有不同的file结构，也就是说，静态链接不能实现共享偏移量。<br>动态共享</li>\n</ul>\n<p>为什么会出现动态共享，是为了解决上面说的不能共享读写偏移量的问题。现实生活中，有两种需求。一种是需要共享读写指针，另一种是不需要共享。为了实现前者，linux系统提出了系统打开文件表的概念。<br>主要是将一些需要被共享的file结构体统一放在系统打开文件表中。如果两个进程希望共享文件读写指针，则使二者的文件描述符表指向系统打开文件表中的同一个file结构体。而如果不需要共享，则指向不同的系统打开文件表即可。</p>\n<p>dentry结构体，只需要知道其中有指向inode的指针即可</p>\n<p>open函数的执行过程（<a href=\"http://blog.chinaunix.net/uid-25968088-id-3426026.html）\" target=\"_blank\" rel=\"external\">http://blog.chinaunix.net/uid-25968088-id-3426026.html）</a><br>（1）task_sruct中保存有该进程可以使用的但是未使用的文件描述符，先通过某个函数获取一个文件描述符。<br>（2）在task_struct的文件描述符表中文件描述符对应的位置初始化一个file指针，并分配一个全新的file结构体。<br>（3）利用传入的参数查找或者建立dentry，并绑定inode，至此，file结构的初始化到此为止。<br>（4）建立fd与file结构的关系，返回fd、<br>网络教程：</p>\n<ol>\n<li>找到一个本进程没有使用的文件描述符fd（int型）</li>\n<li>分配一个全新的struct file结构体</li>\n<li>根据传人的pathname查找或建立对应的dentry</li>\n<li>建立fd到这个struct file结构体的联系</li>\n</ol>\n<p>read函数的执行过程（<a href=\"http://blog.csdn.net/lwj103862095/article/details/38518069）\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/lwj103862095/article/details/38518069）</a></p>\n<p><img src=\"linux-文件系统/图片4.png\" alt=\"图4\"></p>\n<p>图1显示了 read 系统调用在核心空间中所要经历的层次模型。从图中看出：对于磁盘的一次读请求，首先经过虚拟文件系统层（vfs layer），其次是具体的文件系统层（例如 ext2），接下来是 cache 层（page cache 层）、通用块层（generic block layer）、IO 调度层（I/O scheduler layer）、块设备驱动层（block device driver layer），最后是物理块设备层（block device layer）</p>\n<ol>\n<li>虚拟文件系统层的作用：屏蔽下层具体文件系统操作的差异，为上层的操作提供一个统一的接口。正是因为有了这个层次，所以可以把设备抽象成文件，使得操作设备就像操作文件一样简单。</li>\n<li>在具体的文件系统层中，不同的文件系统（例如 ext2 和 NTFS）具体的操作过程也是不同的。每种文件系统定义了自己的操作集合。关于文件系统的更多内容，请参见参考资料。</li>\n<li>引入 cache 层的目的是为了提高 linux 操作系统对磁盘访问的性能。 Cache 层在内存中缓存了磁盘上的部分数据。当数据的请求到达时，如果在 cache 中存在该数据且是最新的，则直接将数据传递给用户程序，免除了对底层磁盘的操作，提高了性能。</li>\n<li>通用块层的主要工作是：接收上层发出的磁盘请求，并最终发出 IO 请求。该层隐藏了底层硬件块设备的特性，为块设备提供了一个通用的抽象视图。</li>\n<li>IO 调度层的功能：接收通用块层发出的 IO 请求，缓存请求并试图合并相邻的请求（如果这两个请求的数据在磁盘上是相邻的）。并根据设置好的调度算法，回调驱动层提供的请求处理函数，以处理具体的 IO 请求。</li>\n<li>驱动层中的驱动程序对应具体的物理块设备。它从上层中取出 IO 请求，并根据该 IO 请求中指定的信息，通过向具体块设备的设备控制器发送命令的方式，来操纵设备传输数据。</li>\n<li>设备层中都是具体的物理设备。定义了操作具体设备的规范。</li>\n</ol>\n<h3 id=\"相关的内核数据结构：\"><a href=\"#相关的内核数据结构：\" class=\"headerlink\" title=\"相关的内核数据结构：\"></a>相关的内核数据结构：</h3><ul>\n<li>Dentry ： 联系了文件名和文件的 i 节点  </li>\n<li>inode ： 文件 i 节点，保存文件标识、权限和内容等信息  </li>\n<li>file ： 保存文件的相关信息和各种操作文件的函数指针集合  </li>\n<li>file_operations ：操作文件的函数接口集合  </li>\n<li>address_space ：描述文件的 page cache 结构以及相关信息，并包含有操作 page cache 的函数指针集合  </li>\n<li>address_space_operations ：操作 page cache 的函数接口集合  </li>\n<li>bio ： IO 请求的描述  </li>\n</ul>\n<p><img src=\"linux-文件系统/图片5.png\" alt=\"图5\"></p>\n<p>图5显示了一个文件的 page cache 结构。文件被分割为一个个以 page 大小为单元的数据块,这些数据块（页）被组织成一个多叉树（称为 radix 树）。此树的层次可以从0层到6层，所支持的文件大小从0字节到16 T 个字节。树的根节点指针可以从和文件相关的 address_space 对象（该对象保存在和文件关联的 inode 对象中）中取得</p>\n<p>（1）产生系统调用，in0x80，根据中断号，在中断向量表中找到read函数的入口地址，将cpu执行权给read系统调用。<br>（2）read通过传入的fd，取出file结构体中的文件偏移量，并通过dentry找到inode结构。<br>（3）inode中存放着该文件对应的page cache的结构以及相关信息，并且有一组操纵page cache结构的函数指针。read在真正向底层发送读取信息之前，会先操纵page cache 来查看<br>其中有没有需要读取的页。如果有，有专门函数讲page chache 中的数据拷贝到用户空间，read调用链到此结束。如果没有，lock计算出的页，则向下层发送添页请求，当再次lock成功时，说明数据已经在page cache 中了，拷贝到用户空间，结束。</p>\n<h1 id=\"文件操作的一般步骤：\"><a href=\"#文件操作的一般步骤：\" class=\"headerlink\" title=\"文件操作的一般步骤：\"></a>文件操作的一般步骤：</h1><ol>\n<li>根据路径名找到对应的dentry结构，并绑定inode。</li>\n<li>根据dentry找到inode</li>\n<li>根据inode中的某个数组获得对应文件的信息存放在哪些数据块上。</li>\n<li>调用文件系统函数向更下一层发送命令，从而从磁盘读取数据。<h1 id=\"page-cache机制：\"><a href=\"#page-cache机制：\" class=\"headerlink\" title=\"page cache机制：\"></a>page cache机制：</h1> linux访问文件的方式分为直接IO和非直接IO两大类。其中，非直接IO就会用到page cache。上层程序写的数据先写到page cache，再有内核线程定期刷到磁盘。用户程序需要读的数据，先读到page cache，再从page cache拷贝到用户空间。</li>\n</ol>\n<h1 id=\"ext2文件系统\"><a href=\"#ext2文件系统\" class=\"headerlink\" title=\"ext2文件系统\"></a>ext2文件系统</h1><p>ext2文件系统会将磁盘空间格式化为几个部分，分别保存</p>\n<ol>\n<li>MBR ：MBR的作用是把操作系统自己的引导程序读入内存并跳转到操作系统的引导程序。本身与任何操作系统无关。MBR前446字节是主引导记录，后64字节是分区表。最后2个字节是结束标志。（具体我讲）</li>\n<li>inode信息</li>\n<li>真正的数据</li>\n</ol>\n<p>但是如果一个文件系统容量很大，那么将所有的inode和block都放在一起管理很不明智的。所以便有了块组的概念。</p>\n<p>超级块描述了整个文件系统的信息，比如大小，inode/block的总数,已使用数量和剩余数量，其他文件系统的信息。<br>block块组描述符则也类似，描述了一个块组的信息，例如在这个块组中从哪里开始是inode表，从哪里开始是数据块，空闲的inode和数据块还有多少个等等。块描述符和超级块一样，在每个块组开头都有一份拷贝，系统一般只使用到第0组的拷贝。一个块组中的所有inode组成了一个inode表。这里还有块位图，inode位图的概念。</p>\n<h1 id=\"lvm磁盘组织结构图\"><a href=\"#lvm磁盘组织结构图\" class=\"headerlink\" title=\"lvm磁盘组织结构图\"></a>lvm磁盘组织结构图</h1><p><img src=\"linux-文件系统/图片6.png\" alt=\"图6\"></p>\n"},{"title":"maven","comments":1,"date":"2017-09-09T02:56:08.000Z","update":"2017-09-09T02:56:08.000Z","_content":"# 常用难记命令\n1. mvn clean install -D maven.test.skip=true   \n2. mvn clean package -U -DfailIfNoTests=false -f pom.xml\n\n\n1. 创建Maven的普通java项目： \n   mvn archetype:create  -DgroupId=packageName -DartifactId=projectName  \n2. 创建Maven的Web项目：   \n    mvn archetype:create -DgroupId=packageName    -DartifactId=webappName  -DarchetypeArtifactId=maven-archetype-webapp    \n\n7. 生成eclipse项目：mvn eclipse:eclipse  \n8. 生成idea项目：mvn idea:idea \n11. 跳过测试:  mvn install -Dmaven.test.skip=true  \n11. 指定端口:  mvn -Dmaven.tomcat.port=9090\n\n\n# Jar包冲突：\nClassNotFoundException，NoSuchFieldException，NoSuchMethodException\n\n解决jar包冲突\n\n```\n  mvn dependency:tree -Dverbose\n```\n\n当遇到jar包冲突时，我们首先确定是哪个jar包冲突了，这个很容易，看我们调用的类或方法，是属于哪个Jar包。然后就是要找出冲突了，我这里使用命令\n\n```\nmvn dependency:tree -Dverbose -Dincludes=<groupId>:<artifactId>\n```\n\n填写上Jar包的groupId和artifactId，可以只有一个，但是中间的冒号不要少，这样就会输出依赖树，而且是仅包含这个Jar包的依赖树，这样那些地方依赖了这个Jar包的那个版本就一目了然了。\n例如，我的项目中notify-common包存在冲突，我们使用命令\n\n```\nmvn dependency:tree -Dverbose -Dincludes=:notify-common\n```\n加上Dincludes或者Dexcludes说出你喜欢或讨厌，dependency:tree就会帮你过滤出来： \n过滤串使用groupId:artifactId:version的方式进行过滤，可以不写全啦，如： \n\nJava代码  \n```\nmvn dependency:tree -Dverbose -Dincludes=asm:asm  \n```\n\n排除不要的jar包。在依赖包中排除相应的包。在POM排除掉依赖，OK了\n\n```\n1.     <exclusions>  \n2.         <!-- 这个就是我们要加的片断 -->  \n3.         <exclusion>  \n4.             <artifactId>asm</artifactId>  \n5.             <groupId>asm</groupId>  \n6.         </exclusion>  \n7.     </exclusions>  \n```\n\n","source":"_posts/maven.md","raw":"---\ntitle: maven\ncomments: true\ntags:\n  - maven\ncategories:\n  - MAVEN\ndate: 2017-09-09 10:56:08\nupdate: 2017-09-09 10:56:08\n\n---\n# 常用难记命令\n1. mvn clean install -D maven.test.skip=true   \n2. mvn clean package -U -DfailIfNoTests=false -f pom.xml\n\n\n1. 创建Maven的普通java项目： \n   mvn archetype:create  -DgroupId=packageName -DartifactId=projectName  \n2. 创建Maven的Web项目：   \n    mvn archetype:create -DgroupId=packageName    -DartifactId=webappName  -DarchetypeArtifactId=maven-archetype-webapp    \n\n7. 生成eclipse项目：mvn eclipse:eclipse  \n8. 生成idea项目：mvn idea:idea \n11. 跳过测试:  mvn install -Dmaven.test.skip=true  \n11. 指定端口:  mvn -Dmaven.tomcat.port=9090\n\n\n# Jar包冲突：\nClassNotFoundException，NoSuchFieldException，NoSuchMethodException\n\n解决jar包冲突\n\n```\n  mvn dependency:tree -Dverbose\n```\n\n当遇到jar包冲突时，我们首先确定是哪个jar包冲突了，这个很容易，看我们调用的类或方法，是属于哪个Jar包。然后就是要找出冲突了，我这里使用命令\n\n```\nmvn dependency:tree -Dverbose -Dincludes=<groupId>:<artifactId>\n```\n\n填写上Jar包的groupId和artifactId，可以只有一个，但是中间的冒号不要少，这样就会输出依赖树，而且是仅包含这个Jar包的依赖树，这样那些地方依赖了这个Jar包的那个版本就一目了然了。\n例如，我的项目中notify-common包存在冲突，我们使用命令\n\n```\nmvn dependency:tree -Dverbose -Dincludes=:notify-common\n```\n加上Dincludes或者Dexcludes说出你喜欢或讨厌，dependency:tree就会帮你过滤出来： \n过滤串使用groupId:artifactId:version的方式进行过滤，可以不写全啦，如： \n\nJava代码  \n```\nmvn dependency:tree -Dverbose -Dincludes=asm:asm  \n```\n\n排除不要的jar包。在依赖包中排除相应的包。在POM排除掉依赖，OK了\n\n```\n1.     <exclusions>  \n2.         <!-- 这个就是我们要加的片断 -->  \n3.         <exclusion>  \n4.             <artifactId>asm</artifactId>  \n5.             <groupId>asm</groupId>  \n6.         </exclusion>  \n7.     </exclusions>  \n```\n\n","slug":"maven","published":1,"updated":"2017-09-09T03:00:14.000Z","layout":"post","photos":[],"link":"","_id":"cjd4d1a0e001aryx4htiz4np7","content":"<h1 id=\"常用难记命令\"><a href=\"#常用难记命令\" class=\"headerlink\" title=\"常用难记命令\"></a>常用难记命令</h1><ol>\n<li>mvn clean install -D maven.test.skip=true   </li>\n<li>mvn clean package -U -DfailIfNoTests=false -f pom.xml</li>\n</ol>\n<ol>\n<li>创建Maven的普通java项目：<br>mvn archetype:create  -DgroupId=packageName -DartifactId=projectName  </li>\n<li><p>创建Maven的Web项目：<br> mvn archetype:create -DgroupId=packageName    -DartifactId=webappName  -DarchetypeArtifactId=maven-archetype-webapp    </p>\n</li>\n<li><p>生成eclipse项目：mvn eclipse:eclipse  </p>\n</li>\n<li>生成idea项目：mvn idea:idea </li>\n<li>跳过测试:  mvn install -Dmaven.test.skip=true  </li>\n<li>指定端口:  mvn -Dmaven.tomcat.port=9090</li>\n</ol>\n<h1 id=\"Jar包冲突：\"><a href=\"#Jar包冲突：\" class=\"headerlink\" title=\"Jar包冲突：\"></a>Jar包冲突：</h1><p>ClassNotFoundException，NoSuchFieldException，NoSuchMethodException</p>\n<p>解决jar包冲突</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mvn dependency:tree -Dverbose</div></pre></td></tr></table></figure>\n<p>当遇到jar包冲突时，我们首先确定是哪个jar包冲突了，这个很容易，看我们调用的类或方法，是属于哪个Jar包。然后就是要找出冲突了，我这里使用命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mvn dependency:tree -Dverbose -Dincludes=&lt;groupId&gt;:&lt;artifactId&gt;</div></pre></td></tr></table></figure>\n<p>填写上Jar包的groupId和artifactId，可以只有一个，但是中间的冒号不要少，这样就会输出依赖树，而且是仅包含这个Jar包的依赖树，这样那些地方依赖了这个Jar包的那个版本就一目了然了。<br>例如，我的项目中notify-common包存在冲突，我们使用命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mvn dependency:tree -Dverbose -Dincludes=:notify-common</div></pre></td></tr></table></figure>\n<p>加上Dincludes或者Dexcludes说出你喜欢或讨厌，dependency:tree就会帮你过滤出来：<br>过滤串使用groupId:artifactId:version的方式进行过滤，可以不写全啦，如： </p>\n<p>Java代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mvn dependency:tree -Dverbose -Dincludes=asm:asm</div></pre></td></tr></table></figure></p>\n<p>排除不要的jar包。在依赖包中排除相应的包。在POM排除掉依赖，OK了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">1.     &lt;exclusions&gt;  </div><div class=\"line\">2.         &lt;!-- 这个就是我们要加的片断 --&gt;  </div><div class=\"line\">3.         &lt;exclusion&gt;  </div><div class=\"line\">4.             &lt;artifactId&gt;asm&lt;/artifactId&gt;  </div><div class=\"line\">5.             &lt;groupId&gt;asm&lt;/groupId&gt;  </div><div class=\"line\">6.         &lt;/exclusion&gt;  </div><div class=\"line\">7.     &lt;/exclusions&gt;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"常用难记命令\"><a href=\"#常用难记命令\" class=\"headerlink\" title=\"常用难记命令\"></a>常用难记命令</h1><ol>\n<li>mvn clean install -D maven.test.skip=true   </li>\n<li>mvn clean package -U -DfailIfNoTests=false -f pom.xml</li>\n</ol>\n<ol>\n<li>创建Maven的普通java项目：<br>mvn archetype:create  -DgroupId=packageName -DartifactId=projectName  </li>\n<li><p>创建Maven的Web项目：<br> mvn archetype:create -DgroupId=packageName    -DartifactId=webappName  -DarchetypeArtifactId=maven-archetype-webapp    </p>\n</li>\n<li><p>生成eclipse项目：mvn eclipse:eclipse  </p>\n</li>\n<li>生成idea项目：mvn idea:idea </li>\n<li>跳过测试:  mvn install -Dmaven.test.skip=true  </li>\n<li>指定端口:  mvn -Dmaven.tomcat.port=9090</li>\n</ol>\n<h1 id=\"Jar包冲突：\"><a href=\"#Jar包冲突：\" class=\"headerlink\" title=\"Jar包冲突：\"></a>Jar包冲突：</h1><p>ClassNotFoundException，NoSuchFieldException，NoSuchMethodException</p>\n<p>解决jar包冲突</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mvn dependency:tree -Dverbose</div></pre></td></tr></table></figure>\n<p>当遇到jar包冲突时，我们首先确定是哪个jar包冲突了，这个很容易，看我们调用的类或方法，是属于哪个Jar包。然后就是要找出冲突了，我这里使用命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mvn dependency:tree -Dverbose -Dincludes=&lt;groupId&gt;:&lt;artifactId&gt;</div></pre></td></tr></table></figure>\n<p>填写上Jar包的groupId和artifactId，可以只有一个，但是中间的冒号不要少，这样就会输出依赖树，而且是仅包含这个Jar包的依赖树，这样那些地方依赖了这个Jar包的那个版本就一目了然了。<br>例如，我的项目中notify-common包存在冲突，我们使用命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mvn dependency:tree -Dverbose -Dincludes=:notify-common</div></pre></td></tr></table></figure>\n<p>加上Dincludes或者Dexcludes说出你喜欢或讨厌，dependency:tree就会帮你过滤出来：<br>过滤串使用groupId:artifactId:version的方式进行过滤，可以不写全啦，如： </p>\n<p>Java代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mvn dependency:tree -Dverbose -Dincludes=asm:asm</div></pre></td></tr></table></figure></p>\n<p>排除不要的jar包。在依赖包中排除相应的包。在POM排除掉依赖，OK了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">1.     &lt;exclusions&gt;  </div><div class=\"line\">2.         &lt;!-- 这个就是我们要加的片断 --&gt;  </div><div class=\"line\">3.         &lt;exclusion&gt;  </div><div class=\"line\">4.             &lt;artifactId&gt;asm&lt;/artifactId&gt;  </div><div class=\"line\">5.             &lt;groupId&gt;asm&lt;/groupId&gt;  </div><div class=\"line\">6.         &lt;/exclusion&gt;  </div><div class=\"line\">7.     &lt;/exclusions&gt;</div></pre></td></tr></table></figure>\n"},{"title":"spring","comments":1,"date":"2017-09-09T09:43:35.000Z","update":"2017-09-09T09:43:35.000Z","_content":"\n\n# Spring\n\n\n为什么要使用Spring？\nSpring主要两个有功能为我们的业务对象管理提供了非常便捷的方法：\n\n1. DI（Dependency Injection，依赖注入）\n2. AOP（Aspect Oriented Programming，面向切面编程）\n\n## Java Bean\n\n1. 必须是个公有(public)类\n2. 有无参构造函数\n3. 用公共方法暴露内部成员属性(getter,setter)\n\n实现这样规范的类，被称为Java Bean。即是一种可重用的组件。\n\n## 声明Bean\n\n以下是声明Bean的注解：\n1. @Component 组件，没有明确的角色\n2. @Service 在业务逻辑层使用\n3. @Repository 在数据访问层使用\n4. @Controller 在展现层使用(MVC -> Spring MVC)使用\n\n>在这里，可以指定bean的id名：Component(\"yourBeanName\").同时，Spring支持将@Named作为@Component注解的替代方案。两者之间有一些细微的差异，但是在大多数场景中，它们是可以互相替换的。\n\n## 依赖注入\n注入Bean的注解\n\n@Autowired Spring提供的注解\n\n不仅仅是对象，还有在构造器上，还能用在属性的Setter方法上。\n\n不管是构造器、Setter方法还是其他的方法，Spring都会尝试满足方法参数上所声明的依赖。假如有且只有一个bean匹配依赖需求的话，那么这个bean将会被装配进来。\n\n如果没有匹配的bean，那么在应用上下文创建的时候，Spring会抛出一个异常。为了避免异常的出现，你可以将@Autowired的required属性设置为false。\n\n将required属性设置为false时，Spring会尝试执行自动装配，但是如果没有匹配的bean的话，Spring将会让这个bean处于未装配的状态。但是，把required属性设置为false时，你需要谨慎对待。如果在你的代码中没有进行null检查的话，这个处于未装配状态的属性有可能会出现NullPointerException。\n\n@Inject注解来源于Java依赖注入规范，该规范同时还为我们定义了@Named注解。在自动装配中，Spring同时支持@Inject和@Autowired。尽管@Inject和@Autowired之间有着一些细微的差别，但是在大多数场景下，它们都是可以互相替换的。\n\n@Autowired是最常见的注解之一，但在老项目中，你可能会看到这些注解，它们的作用和@Autowired相近：\n\n@Inject 是JSR-330提供的注解\n@Resource 是JSR-250提供的注解\n\n\n### 限定自动装配的bean\n@Qualifier注解是使用限定符的主要方式。它可以与@Autowired和@Inject协同使用，在注入的时候指定想要注入进去的是哪个bean。为@Qualifier注解所设置的参数就是想要注入的bean的ID\n\n```\n@Autowired\n@Qualifier(\"iceCream\")\npublic void setDessert(Dessert dessert){\n  this.dessert = dessert;\n}\n```","source":"_posts/spring.md","raw":"---\ntitle: spring\ncomments: true\ntags:\n  - spring\ncategories:\n  - SPRING\ndate: 2017-09-09 17:43:35\nupdate: 2017-09-09 17:43:35\n---\n\n\n# Spring\n\n\n为什么要使用Spring？\nSpring主要两个有功能为我们的业务对象管理提供了非常便捷的方法：\n\n1. DI（Dependency Injection，依赖注入）\n2. AOP（Aspect Oriented Programming，面向切面编程）\n\n## Java Bean\n\n1. 必须是个公有(public)类\n2. 有无参构造函数\n3. 用公共方法暴露内部成员属性(getter,setter)\n\n实现这样规范的类，被称为Java Bean。即是一种可重用的组件。\n\n## 声明Bean\n\n以下是声明Bean的注解：\n1. @Component 组件，没有明确的角色\n2. @Service 在业务逻辑层使用\n3. @Repository 在数据访问层使用\n4. @Controller 在展现层使用(MVC -> Spring MVC)使用\n\n>在这里，可以指定bean的id名：Component(\"yourBeanName\").同时，Spring支持将@Named作为@Component注解的替代方案。两者之间有一些细微的差异，但是在大多数场景中，它们是可以互相替换的。\n\n## 依赖注入\n注入Bean的注解\n\n@Autowired Spring提供的注解\n\n不仅仅是对象，还有在构造器上，还能用在属性的Setter方法上。\n\n不管是构造器、Setter方法还是其他的方法，Spring都会尝试满足方法参数上所声明的依赖。假如有且只有一个bean匹配依赖需求的话，那么这个bean将会被装配进来。\n\n如果没有匹配的bean，那么在应用上下文创建的时候，Spring会抛出一个异常。为了避免异常的出现，你可以将@Autowired的required属性设置为false。\n\n将required属性设置为false时，Spring会尝试执行自动装配，但是如果没有匹配的bean的话，Spring将会让这个bean处于未装配的状态。但是，把required属性设置为false时，你需要谨慎对待。如果在你的代码中没有进行null检查的话，这个处于未装配状态的属性有可能会出现NullPointerException。\n\n@Inject注解来源于Java依赖注入规范，该规范同时还为我们定义了@Named注解。在自动装配中，Spring同时支持@Inject和@Autowired。尽管@Inject和@Autowired之间有着一些细微的差别，但是在大多数场景下，它们都是可以互相替换的。\n\n@Autowired是最常见的注解之一，但在老项目中，你可能会看到这些注解，它们的作用和@Autowired相近：\n\n@Inject 是JSR-330提供的注解\n@Resource 是JSR-250提供的注解\n\n\n### 限定自动装配的bean\n@Qualifier注解是使用限定符的主要方式。它可以与@Autowired和@Inject协同使用，在注入的时候指定想要注入进去的是哪个bean。为@Qualifier注解所设置的参数就是想要注入的bean的ID\n\n```\n@Autowired\n@Qualifier(\"iceCream\")\npublic void setDessert(Dessert dessert){\n  this.dessert = dessert;\n}\n```","slug":"spring","published":1,"updated":"2017-09-09T09:44:30.000Z","layout":"post","photos":[],"link":"","_id":"cjd4d1a0f001cryx4yuei8l4j","content":"<h1 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h1><p>为什么要使用Spring？<br>Spring主要两个有功能为我们的业务对象管理提供了非常便捷的方法：</p>\n<ol>\n<li>DI（Dependency Injection，依赖注入）</li>\n<li>AOP（Aspect Oriented Programming，面向切面编程）</li>\n</ol>\n<h2 id=\"Java-Bean\"><a href=\"#Java-Bean\" class=\"headerlink\" title=\"Java Bean\"></a>Java Bean</h2><ol>\n<li>必须是个公有(public)类</li>\n<li>有无参构造函数</li>\n<li>用公共方法暴露内部成员属性(getter,setter)</li>\n</ol>\n<p>实现这样规范的类，被称为Java Bean。即是一种可重用的组件。</p>\n<h2 id=\"声明Bean\"><a href=\"#声明Bean\" class=\"headerlink\" title=\"声明Bean\"></a>声明Bean</h2><p>以下是声明Bean的注解：</p>\n<ol>\n<li>@Component 组件，没有明确的角色</li>\n<li>@Service 在业务逻辑层使用</li>\n<li>@Repository 在数据访问层使用</li>\n<li>@Controller 在展现层使用(MVC -&gt; Spring MVC)使用</li>\n</ol>\n<blockquote>\n<p>在这里，可以指定bean的id名：Component(“yourBeanName”).同时，Spring支持将@Named作为@Component注解的替代方案。两者之间有一些细微的差异，但是在大多数场景中，它们是可以互相替换的。</p>\n</blockquote>\n<h2 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h2><p>注入Bean的注解</p>\n<p>@Autowired Spring提供的注解</p>\n<p>不仅仅是对象，还有在构造器上，还能用在属性的Setter方法上。</p>\n<p>不管是构造器、Setter方法还是其他的方法，Spring都会尝试满足方法参数上所声明的依赖。假如有且只有一个bean匹配依赖需求的话，那么这个bean将会被装配进来。</p>\n<p>如果没有匹配的bean，那么在应用上下文创建的时候，Spring会抛出一个异常。为了避免异常的出现，你可以将@Autowired的required属性设置为false。</p>\n<p>将required属性设置为false时，Spring会尝试执行自动装配，但是如果没有匹配的bean的话，Spring将会让这个bean处于未装配的状态。但是，把required属性设置为false时，你需要谨慎对待。如果在你的代码中没有进行null检查的话，这个处于未装配状态的属性有可能会出现NullPointerException。</p>\n<p>@Inject注解来源于Java依赖注入规范，该规范同时还为我们定义了@Named注解。在自动装配中，Spring同时支持@Inject和@Autowired。尽管@Inject和@Autowired之间有着一些细微的差别，但是在大多数场景下，它们都是可以互相替换的。</p>\n<p>@Autowired是最常见的注解之一，但在老项目中，你可能会看到这些注解，它们的作用和@Autowired相近：</p>\n<p>@Inject 是JSR-330提供的注解<br>@Resource 是JSR-250提供的注解</p>\n<h3 id=\"限定自动装配的bean\"><a href=\"#限定自动装配的bean\" class=\"headerlink\" title=\"限定自动装配的bean\"></a>限定自动装配的bean</h3><p>@Qualifier注解是使用限定符的主要方式。它可以与@Autowired和@Inject协同使用，在注入的时候指定想要注入进去的是哪个bean。为@Qualifier注解所设置的参数就是想要注入的bean的ID</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Autowired</div><div class=\"line\">@Qualifier(&quot;iceCream&quot;)</div><div class=\"line\">public void setDessert(Dessert dessert)&#123;</div><div class=\"line\">  this.dessert = dessert;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h1><p>为什么要使用Spring？<br>Spring主要两个有功能为我们的业务对象管理提供了非常便捷的方法：</p>\n<ol>\n<li>DI（Dependency Injection，依赖注入）</li>\n<li>AOP（Aspect Oriented Programming，面向切面编程）</li>\n</ol>\n<h2 id=\"Java-Bean\"><a href=\"#Java-Bean\" class=\"headerlink\" title=\"Java Bean\"></a>Java Bean</h2><ol>\n<li>必须是个公有(public)类</li>\n<li>有无参构造函数</li>\n<li>用公共方法暴露内部成员属性(getter,setter)</li>\n</ol>\n<p>实现这样规范的类，被称为Java Bean。即是一种可重用的组件。</p>\n<h2 id=\"声明Bean\"><a href=\"#声明Bean\" class=\"headerlink\" title=\"声明Bean\"></a>声明Bean</h2><p>以下是声明Bean的注解：</p>\n<ol>\n<li>@Component 组件，没有明确的角色</li>\n<li>@Service 在业务逻辑层使用</li>\n<li>@Repository 在数据访问层使用</li>\n<li>@Controller 在展现层使用(MVC -&gt; Spring MVC)使用</li>\n</ol>\n<blockquote>\n<p>在这里，可以指定bean的id名：Component(“yourBeanName”).同时，Spring支持将@Named作为@Component注解的替代方案。两者之间有一些细微的差异，但是在大多数场景中，它们是可以互相替换的。</p>\n</blockquote>\n<h2 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h2><p>注入Bean的注解</p>\n<p>@Autowired Spring提供的注解</p>\n<p>不仅仅是对象，还有在构造器上，还能用在属性的Setter方法上。</p>\n<p>不管是构造器、Setter方法还是其他的方法，Spring都会尝试满足方法参数上所声明的依赖。假如有且只有一个bean匹配依赖需求的话，那么这个bean将会被装配进来。</p>\n<p>如果没有匹配的bean，那么在应用上下文创建的时候，Spring会抛出一个异常。为了避免异常的出现，你可以将@Autowired的required属性设置为false。</p>\n<p>将required属性设置为false时，Spring会尝试执行自动装配，但是如果没有匹配的bean的话，Spring将会让这个bean处于未装配的状态。但是，把required属性设置为false时，你需要谨慎对待。如果在你的代码中没有进行null检查的话，这个处于未装配状态的属性有可能会出现NullPointerException。</p>\n<p>@Inject注解来源于Java依赖注入规范，该规范同时还为我们定义了@Named注解。在自动装配中，Spring同时支持@Inject和@Autowired。尽管@Inject和@Autowired之间有着一些细微的差别，但是在大多数场景下，它们都是可以互相替换的。</p>\n<p>@Autowired是最常见的注解之一，但在老项目中，你可能会看到这些注解，它们的作用和@Autowired相近：</p>\n<p>@Inject 是JSR-330提供的注解<br>@Resource 是JSR-250提供的注解</p>\n<h3 id=\"限定自动装配的bean\"><a href=\"#限定自动装配的bean\" class=\"headerlink\" title=\"限定自动装配的bean\"></a>限定自动装配的bean</h3><p>@Qualifier注解是使用限定符的主要方式。它可以与@Autowired和@Inject协同使用，在注入的时候指定想要注入进去的是哪个bean。为@Qualifier注解所设置的参数就是想要注入的bean的ID</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Autowired</div><div class=\"line\">@Qualifier(&quot;iceCream&quot;)</div><div class=\"line\">public void setDessert(Dessert dessert)&#123;</div><div class=\"line\">  this.dessert = dessert;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"linux 进程与线程","comments":1,"date":"2017-03-05T10:00:46.000Z","update":"2017-03-05T10:00:46.000Z","_content":"\r# 什么是进程？\r1.\t进程是资源分配和和独立运行的单位；\r2. 进程是操作系统中可执行程序的一次执行，换句话说进程就是拥有资源（cpu,内存，磁盘，进程ID，文件描述符，虚拟地址空间，端口号等）的程序；它是动态的；\r3.\t一个进程是由程序控制块（pcb也就是task_struct结构体）,代码和数据组成；其中进程控制块是描述进程的资源和运行状态等；它有内核来管理；\r4.\t在linux中可以通过ps，pstree来查看当前系统中的进程；\n\n#\t什么是线程？\r1. 线程属于轻量级进程，一个进程可以拥有多个线程；linux下线程就是轻量级进程，所以线程的概念和进程是大同小异的。只不过是共享了大部分资源的进程罢了。\r2. 线程是进程的一个执行流，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程是进程中的最小调度单位；\r3. \t用户线程指的是完全建立在用户空间的线程库，用户线程的建立，同步，销毁，调度完全在用户空间完成，不需要内核的帮助。因此这种线程的操作是极其快速的且低消耗的。\r4.\t用户态线程和内核态线程；主要的区分就是“谁来管理”线程，用户态是用户管理，内核态是内核管理（但肯定要提供一些API，例如创建）。\r5.\t线程的模型有哪些\r - \tn : 1 多个线程对应一个核心线程(进程); 线程的创建和销毁以及管理全部在用户层的线程库中实现，在内核层完全不知情，内核层看到的只是一个个进程。所以内核会以进程为单位调度任务运行。\r -\t1：1\t一个线程对应核心线程(进程); 在1:1模式下，线程的创建，调度，销毁全由内核完成，而其他操作则由线程库完成。\r -\tm ：n ： 结合上面两种方式，如某些进程一一对应核内线程，其他线程完全在用户态实现。\r\r# linux是如何管理进程的？\n\r1.\t每个进程在linux内核拥有一个task_struct结构体（进程控制块的具体定义），里面包含了进程几乎所有的信息。在linux下，所谓的进程管理，就是反复操纵task_struct结构体的过程一点也不为过。\r2.\t操作系统对进程的所有管理都是围绕task_struct结构体为中心构建的。\n\r> 例如，给某个进程发送kill信息，操作系统就会根据task_struct结构体中的信息释放进程所占用的内存，信号量，打开文件相关的资源等等，然后当进程被切换出去时释放task_struct结构体，至此，系统再没有保存该进程的任意一点信息，标志着进程的死亡。\n> \r再例如，进程的调度，由于每个进程都有其自己的上下文环境，或者说是当前系统状态的总和。被切换出去进程的这种系统状态需要保存到task_struct结构体中，以便下次恢复。而被切换进来的进程的上下文环境从哪里来呢？显而易见，在这个被调度进来的进程在真正运行之前，调度程序会从该进程的task_struct结构体中找到之前保存的上下文环境，然后将系统恢复到之前保存的状态，被调度进来的程序才真正开始运行。\r\r#\t进程的创建过程：\n\r1.\t操作系统给新进程分配一个全局唯一的pid号;\r2.\t并在内核空间中创建和分配诸如task_struct结构体，kernel堆栈等必要的数据结构和物理资源。\r3.\t然后复制父进程的与信号有关，与文件系统有关的运行环境。最后还会给task_struct结构体某些变量赋值，将来使用这些变量来将新进程运行的某些环境（如kernel栈的起始地址，EAX的初值等）设置为子进程自己独有的运行环境。并加入运行队列中，之后就是调度程序的事了。\r4.\t这个过程中涉及到了写时拷贝技术。在Linux程序中，fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。\r\r#\t写时拷贝技术:\n\r> http://blog.sina.cn/dpool/blog/s/blog_96757e4b01011b1n.html?vt=4 \n\n\r在Linux程序中，fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。当子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。\n\r这就是分配内存的拖延战术，直到不得不做。操作系统中与此类似思想的还有页高速缓存器（page cache）。也就是，当有程序试图将数据写入文件的时候，linux操作系统并不会马上将数据写入disk中，而是将它们临时放在memory的一块区域。这块区域就叫做page cache。只有在关闭文件或者关机时，才有内核线程将page cache中的数据刷到磁盘中。这也就是非正常退出时，数据会损坏的原因。\r\r\r# 在Linux中主要提供了fork、vfork、clone三个进程创建方法。\n\n> 以下总结来源:http://www.360doc.com/content/14/1231/11/14530056_437075775.shtml \n\r在linux源码中这三个调用的执行过程是执行fork(),vfork(),clone()时，通过一个系统调用表映射到sys_fork(),sys_vfork(),sys_clone(),再在这三个函数中去调用do_fork()去做具体的创建进程工作。\n\r1. fork创建一个进程时，子进程只是完全复制父进程的资源，复制出来的子进程有自己的task_struct结构和pid,但却复制父进程其它所有的资源。这样看来，fork是一个开销十分大的系统调用，这些开销并不是所有的情况下都是必须的，比如某进程fork出一个子进程后，其子进程仅仅是为了调用exec执行另一个可执行文件，那么在fork过程中对于虚存空间的复制将是一个多余的过程。但由于现在Linux中是采取了copy-on-write(COW写时复制)技术，为了降低开销，fork最初并不会真的产生两个不同的拷贝，因为在那个时候，大量的数据其实完全是一样的。写时复制是在推迟真正的数据拷贝。所以有了写时复制后呢，vfork其实现意义就不大了。\r2. \tvfork系统调用不同于fork，用vfork创建的子进程与父进程共享地址空间，也就是说子进程完全运行在父进程的地址空间上，如果这时子进程修改了某个变量，这将影响到父进程。但此处有一点要注意的是用vfork()创建的子进程必须显示调用exit()来结束，否则子进程将不能结束，而fork()则不存在这个情况。用 vfork创建子进程后，父进程会被阻塞直到子进程调用exec(exec，将一个新的可执行文件载入到地址空间并执行之。)或exit。vfork的好处是在子进程被创建后往往仅仅是为了调用exec执行另一个程序，因为它就不会对父进程的地址空间有任何引用，所以对地址空间的复制是多余的 ，因此通过vfork共享内存可以减少不必要的开销。\r3. clone :系统调用fork()和vfork()是无参数的，而clone()则带有参数。fork()是全部复制，vfork()是共享内存，而clone() 是则可以将父进程资源有选择地复制给子进程，而没有复制的数据结构则通过指针的复制让子进程共享，具体要复制哪些资源给子进程，由参数列表中的 clone_flags来决定。另外，clone()返回的是子进程的pid。\r所以，这个就和上面说的轻量级进程联系起来，也可以这样说，linux通过clone调用生成线程。\r\r#\tfork，vfork，clone的区别 \r1.\tfork出来的子进程是父进程的一个拷贝，即，子进程从父进程得到了数据段和堆栈段的拷贝，这些需要分配新的内存；而对于只读的代码段，通常使用共享内存的方式访问；而vfork则是子进程与父进程共享内存空间, 子进程对虚拟地址空间任何数据的修改同样为父进程所见；clone则由用户通过参clone_flags 的设置来决定哪些资源共享，哪些资源拷贝。 \r\r2.\tfork不对父子进程的执行次序进行任何限制，fork返回后，子进程和父进程都从调用fork函数的下一条语句开始行，但父子进程运行顺序是不定的，它取决于内核的调度算法；而在vfork调用中，子进程先运行，父进程挂起，直到子进程调用了exec或exit之后，父子进程的执行次序才不再有限制；clone中由标志CLONE_VFORK来决定子进程在执行时父进程是阻塞还是运行，若没有设置该标志，则父子进程同时运行，设置了该标志，则父进程挂起，直到子进程结束为止。\r他们成功执行时，父进程中返回子进程的进程号，在子进程中返回0。\n\r#\t进程的调度\n\r主要结构就是运行队列(双向循环链表)。为什么会有运行队列的存在呢?\r当Linux内核要寻找一个新的进程在CPU上运行时，必须只考虑处于可运行状态的进程，（即在TASK_RUNNING状态的进程），因为扫描整个进程链表是相当低效的，所以引入了可运行状态进程的双向循环链表，也叫运行队列（runqueue）。运行队列容纳了系统中所有可以运行的进程，它是一个双向循环队列。\n\r也就是说，为了实现进程的调度，内核维护了一个叫做运行队列的数据结构。在这个数据结构中，active，expired，arrays是主要的三个结构。目前，咱们几个了解这三个就足够了。arrays也就是一个拥有两个成员的数组，每个数组有140个双向链表（也就是说，所有的就绪进程，按照时间片是否用完分成两个部分），对应了0~139 的140个优先级。active和expired分别指向arrays的两个成员。进程调度时，从active指针选择下一个要运行的程序。active中时间片用完的进程会被移动到expired队列，并且时间片会被重新计算，若active队列再无成员，则两个指针指向互换。\n\rlinux进程主要分为 实时进程（例如键盘中输入字母或者鼠标点击之类的） 和 交互式进程与批处理进程（例如word程序，你总是写一会停一会）。内核不会动态调整前者的优先级，如需调整，则需要调用特殊的系统调用。而且，前者的优先级别最高。只有没有实时进程的时候，交互式或者批处理才会被调度执行。而后者的优先级会被内核动态调整。\n\r#\t进程有哪些调度策略？ \r这时候你分开说。对于实时进程，一般采用的是FIFO或者RR（轮询）机制。而对于交互式或者批处理进程，则采用动态调整优先级加运行队列机制来执行调度。这里有个大原则，如果有实时进程，那么交互式或者批处理则不会被执行。这个从进程优先级就可以看出来：实时（0~99），交互式批处理（100~139）。这时，你还可以举个例子。比如，你正在复制100文件，文件是一个一个被复制的，当复制到第50个的时候，你点了一下停止符号，它不会说是继续第51个文件的复制，而是直接停止。说明你鼠标的点击被插入到第51个文件之前了。所以实时进程永远比后者优先级高。\n\r#\t进程会在什么时候被调度?  \r调度一般在进程退出内核态时，因为这时进程已经释放了可能导致内核死锁的资源。除了时间片用完触发调度，内核线程会在执行一些比较费时的任务时，自己调用调度函数，使其他进程有机会执行。\n\r首先进程调度不应该产生内核死锁之类的问题。如果进程在内核态，则它可能会占有产生死锁的资源（比如，进程想要操纵硬件必须使用系统调用。想想这样一种情况：用户想要使用打印机这种独占资源，内核线程，也就是代表用户进程在内核状态执行的那个线程，它一定改变了代表打印机的结构的某个标志位，或者持有打印机结构体内的自旋锁，互斥锁之类的资源，标志着打印机正在被使用，本来打算在返回用户态时释放这种互斥锁资源，但调度函数来了，我不管，我就要让你现在退出。然后该进程带着互斥锁退出。当下一个进程进来，也要使用打印机，这时，该进程向内核申请打印机，而内核却发现打印机正在被使用，所以内核等待打印机退出，而持有互斥锁的进程已经被内核踢出cpu了，谈何释放？所以这时，所有的进程都在等，被调度进来进程陷入内核出不来了,整条逻辑陷入了无限循环，如果是单核，那么死锁便产生了）。\n\r#\t关于僵尸进程 \r僵尸进程指的是那些虽然已经终止的进程，但仍然保留一些信息，等待其父进程为其收尸。\n\r1. 生的原因：\n父进程调用fork创建子进程后，子进程运行直至其终止，它立即从内存中移除，但进程描述符仍然保留在内存中（进程描述符占有极少的内存空间）。子进程的状态变成EXIT_ZOMBIE，并且向父进程发送SIGCHLD 信号，父进程此时应该调用 wait() 系 统调用来获取子进程的退出状态以及其它的信息。在 wait 调用之后，僵尸进程就完全从内存中移除。因此一个僵尸存在于其终止到父进程调用 wait 等函数这个时间的间隙，一般很快就消失，但如果编程不合理，父进程从不调用 wait 等系统调用来收集僵尸进程，那么这些进程会一直存在内存中。比如父进程死了，或者父进程忽略了SIGCHLD信号，或者父进程对SIGCHLD信号定义的信号处理函数有误。\n\r2. 如何避免：不能使用 kill 后接 SIGKILL 信号这样的命令像杀死普通进程一样杀死僵尸进程，因为僵尸进程是已经死掉的进程，它不能再接收任何信号。事实上，如果系统中僵尸进程并不多的话，我们也无需去消除它们，少数的僵尸进程并不会对系统的性能有什么影响。\n\r那么在编程时，如果能避免系统中大量产生僵尸进程呢？根据上面描述的，子进程在终止时会向父进程发 SIGCHLD 信号，Linux 默认是忽略该信号的，我们可以显示安装该信号，在信号处理函数中调用 wait 等函数来为其收尸，这样就能避免僵尸进程长期存在于系统中了。\r以上都是复制下面这个链接的，\r> http://www.cnblogs.com/hazir/p/zombie_process.html\n\r3. 危害：\n\r - 僵尸进程的pid不会释放，意味着如果有海量的僵尸进程，则会占满进程表项，是的后续进程无法执行fork（）\r - 内核栈无法释放，这个资源是很珍贵的。根本原因在于，task_stauct结构体没有释放。\r\r","source":"_posts/linux-杂记.md","raw":"---\ntitle: linux 进程与线程\ncomments: true\ntags:\n  - LINUX\n  - 进程\n  - 线程\ncategories:\n  - LINUX\ndate: 2017-03-05 18:00:46\nupdate: 2017-03-05 18:00:46\n---\n\r# 什么是进程？\r1.\t进程是资源分配和和独立运行的单位；\r2. 进程是操作系统中可执行程序的一次执行，换句话说进程就是拥有资源（cpu,内存，磁盘，进程ID，文件描述符，虚拟地址空间，端口号等）的程序；它是动态的；\r3.\t一个进程是由程序控制块（pcb也就是task_struct结构体）,代码和数据组成；其中进程控制块是描述进程的资源和运行状态等；它有内核来管理；\r4.\t在linux中可以通过ps，pstree来查看当前系统中的进程；\n\n#\t什么是线程？\r1. 线程属于轻量级进程，一个进程可以拥有多个线程；linux下线程就是轻量级进程，所以线程的概念和进程是大同小异的。只不过是共享了大部分资源的进程罢了。\r2. 线程是进程的一个执行流，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程是进程中的最小调度单位；\r3. \t用户线程指的是完全建立在用户空间的线程库，用户线程的建立，同步，销毁，调度完全在用户空间完成，不需要内核的帮助。因此这种线程的操作是极其快速的且低消耗的。\r4.\t用户态线程和内核态线程；主要的区分就是“谁来管理”线程，用户态是用户管理，内核态是内核管理（但肯定要提供一些API，例如创建）。\r5.\t线程的模型有哪些\r - \tn : 1 多个线程对应一个核心线程(进程); 线程的创建和销毁以及管理全部在用户层的线程库中实现，在内核层完全不知情，内核层看到的只是一个个进程。所以内核会以进程为单位调度任务运行。\r -\t1：1\t一个线程对应核心线程(进程); 在1:1模式下，线程的创建，调度，销毁全由内核完成，而其他操作则由线程库完成。\r -\tm ：n ： 结合上面两种方式，如某些进程一一对应核内线程，其他线程完全在用户态实现。\r\r# linux是如何管理进程的？\n\r1.\t每个进程在linux内核拥有一个task_struct结构体（进程控制块的具体定义），里面包含了进程几乎所有的信息。在linux下，所谓的进程管理，就是反复操纵task_struct结构体的过程一点也不为过。\r2.\t操作系统对进程的所有管理都是围绕task_struct结构体为中心构建的。\n\r> 例如，给某个进程发送kill信息，操作系统就会根据task_struct结构体中的信息释放进程所占用的内存，信号量，打开文件相关的资源等等，然后当进程被切换出去时释放task_struct结构体，至此，系统再没有保存该进程的任意一点信息，标志着进程的死亡。\n> \r再例如，进程的调度，由于每个进程都有其自己的上下文环境，或者说是当前系统状态的总和。被切换出去进程的这种系统状态需要保存到task_struct结构体中，以便下次恢复。而被切换进来的进程的上下文环境从哪里来呢？显而易见，在这个被调度进来的进程在真正运行之前，调度程序会从该进程的task_struct结构体中找到之前保存的上下文环境，然后将系统恢复到之前保存的状态，被调度进来的程序才真正开始运行。\r\r#\t进程的创建过程：\n\r1.\t操作系统给新进程分配一个全局唯一的pid号;\r2.\t并在内核空间中创建和分配诸如task_struct结构体，kernel堆栈等必要的数据结构和物理资源。\r3.\t然后复制父进程的与信号有关，与文件系统有关的运行环境。最后还会给task_struct结构体某些变量赋值，将来使用这些变量来将新进程运行的某些环境（如kernel栈的起始地址，EAX的初值等）设置为子进程自己独有的运行环境。并加入运行队列中，之后就是调度程序的事了。\r4.\t这个过程中涉及到了写时拷贝技术。在Linux程序中，fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。\r\r#\t写时拷贝技术:\n\r> http://blog.sina.cn/dpool/blog/s/blog_96757e4b01011b1n.html?vt=4 \n\n\r在Linux程序中，fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。当子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。\n\r这就是分配内存的拖延战术，直到不得不做。操作系统中与此类似思想的还有页高速缓存器（page cache）。也就是，当有程序试图将数据写入文件的时候，linux操作系统并不会马上将数据写入disk中，而是将它们临时放在memory的一块区域。这块区域就叫做page cache。只有在关闭文件或者关机时，才有内核线程将page cache中的数据刷到磁盘中。这也就是非正常退出时，数据会损坏的原因。\r\r\r# 在Linux中主要提供了fork、vfork、clone三个进程创建方法。\n\n> 以下总结来源:http://www.360doc.com/content/14/1231/11/14530056_437075775.shtml \n\r在linux源码中这三个调用的执行过程是执行fork(),vfork(),clone()时，通过一个系统调用表映射到sys_fork(),sys_vfork(),sys_clone(),再在这三个函数中去调用do_fork()去做具体的创建进程工作。\n\r1. fork创建一个进程时，子进程只是完全复制父进程的资源，复制出来的子进程有自己的task_struct结构和pid,但却复制父进程其它所有的资源。这样看来，fork是一个开销十分大的系统调用，这些开销并不是所有的情况下都是必须的，比如某进程fork出一个子进程后，其子进程仅仅是为了调用exec执行另一个可执行文件，那么在fork过程中对于虚存空间的复制将是一个多余的过程。但由于现在Linux中是采取了copy-on-write(COW写时复制)技术，为了降低开销，fork最初并不会真的产生两个不同的拷贝，因为在那个时候，大量的数据其实完全是一样的。写时复制是在推迟真正的数据拷贝。所以有了写时复制后呢，vfork其实现意义就不大了。\r2. \tvfork系统调用不同于fork，用vfork创建的子进程与父进程共享地址空间，也就是说子进程完全运行在父进程的地址空间上，如果这时子进程修改了某个变量，这将影响到父进程。但此处有一点要注意的是用vfork()创建的子进程必须显示调用exit()来结束，否则子进程将不能结束，而fork()则不存在这个情况。用 vfork创建子进程后，父进程会被阻塞直到子进程调用exec(exec，将一个新的可执行文件载入到地址空间并执行之。)或exit。vfork的好处是在子进程被创建后往往仅仅是为了调用exec执行另一个程序，因为它就不会对父进程的地址空间有任何引用，所以对地址空间的复制是多余的 ，因此通过vfork共享内存可以减少不必要的开销。\r3. clone :系统调用fork()和vfork()是无参数的，而clone()则带有参数。fork()是全部复制，vfork()是共享内存，而clone() 是则可以将父进程资源有选择地复制给子进程，而没有复制的数据结构则通过指针的复制让子进程共享，具体要复制哪些资源给子进程，由参数列表中的 clone_flags来决定。另外，clone()返回的是子进程的pid。\r所以，这个就和上面说的轻量级进程联系起来，也可以这样说，linux通过clone调用生成线程。\r\r#\tfork，vfork，clone的区别 \r1.\tfork出来的子进程是父进程的一个拷贝，即，子进程从父进程得到了数据段和堆栈段的拷贝，这些需要分配新的内存；而对于只读的代码段，通常使用共享内存的方式访问；而vfork则是子进程与父进程共享内存空间, 子进程对虚拟地址空间任何数据的修改同样为父进程所见；clone则由用户通过参clone_flags 的设置来决定哪些资源共享，哪些资源拷贝。 \r\r2.\tfork不对父子进程的执行次序进行任何限制，fork返回后，子进程和父进程都从调用fork函数的下一条语句开始行，但父子进程运行顺序是不定的，它取决于内核的调度算法；而在vfork调用中，子进程先运行，父进程挂起，直到子进程调用了exec或exit之后，父子进程的执行次序才不再有限制；clone中由标志CLONE_VFORK来决定子进程在执行时父进程是阻塞还是运行，若没有设置该标志，则父子进程同时运行，设置了该标志，则父进程挂起，直到子进程结束为止。\r他们成功执行时，父进程中返回子进程的进程号，在子进程中返回0。\n\r#\t进程的调度\n\r主要结构就是运行队列(双向循环链表)。为什么会有运行队列的存在呢?\r当Linux内核要寻找一个新的进程在CPU上运行时，必须只考虑处于可运行状态的进程，（即在TASK_RUNNING状态的进程），因为扫描整个进程链表是相当低效的，所以引入了可运行状态进程的双向循环链表，也叫运行队列（runqueue）。运行队列容纳了系统中所有可以运行的进程，它是一个双向循环队列。\n\r也就是说，为了实现进程的调度，内核维护了一个叫做运行队列的数据结构。在这个数据结构中，active，expired，arrays是主要的三个结构。目前，咱们几个了解这三个就足够了。arrays也就是一个拥有两个成员的数组，每个数组有140个双向链表（也就是说，所有的就绪进程，按照时间片是否用完分成两个部分），对应了0~139 的140个优先级。active和expired分别指向arrays的两个成员。进程调度时，从active指针选择下一个要运行的程序。active中时间片用完的进程会被移动到expired队列，并且时间片会被重新计算，若active队列再无成员，则两个指针指向互换。\n\rlinux进程主要分为 实时进程（例如键盘中输入字母或者鼠标点击之类的） 和 交互式进程与批处理进程（例如word程序，你总是写一会停一会）。内核不会动态调整前者的优先级，如需调整，则需要调用特殊的系统调用。而且，前者的优先级别最高。只有没有实时进程的时候，交互式或者批处理才会被调度执行。而后者的优先级会被内核动态调整。\n\r#\t进程有哪些调度策略？ \r这时候你分开说。对于实时进程，一般采用的是FIFO或者RR（轮询）机制。而对于交互式或者批处理进程，则采用动态调整优先级加运行队列机制来执行调度。这里有个大原则，如果有实时进程，那么交互式或者批处理则不会被执行。这个从进程优先级就可以看出来：实时（0~99），交互式批处理（100~139）。这时，你还可以举个例子。比如，你正在复制100文件，文件是一个一个被复制的，当复制到第50个的时候，你点了一下停止符号，它不会说是继续第51个文件的复制，而是直接停止。说明你鼠标的点击被插入到第51个文件之前了。所以实时进程永远比后者优先级高。\n\r#\t进程会在什么时候被调度?  \r调度一般在进程退出内核态时，因为这时进程已经释放了可能导致内核死锁的资源。除了时间片用完触发调度，内核线程会在执行一些比较费时的任务时，自己调用调度函数，使其他进程有机会执行。\n\r首先进程调度不应该产生内核死锁之类的问题。如果进程在内核态，则它可能会占有产生死锁的资源（比如，进程想要操纵硬件必须使用系统调用。想想这样一种情况：用户想要使用打印机这种独占资源，内核线程，也就是代表用户进程在内核状态执行的那个线程，它一定改变了代表打印机的结构的某个标志位，或者持有打印机结构体内的自旋锁，互斥锁之类的资源，标志着打印机正在被使用，本来打算在返回用户态时释放这种互斥锁资源，但调度函数来了，我不管，我就要让你现在退出。然后该进程带着互斥锁退出。当下一个进程进来，也要使用打印机，这时，该进程向内核申请打印机，而内核却发现打印机正在被使用，所以内核等待打印机退出，而持有互斥锁的进程已经被内核踢出cpu了，谈何释放？所以这时，所有的进程都在等，被调度进来进程陷入内核出不来了,整条逻辑陷入了无限循环，如果是单核，那么死锁便产生了）。\n\r#\t关于僵尸进程 \r僵尸进程指的是那些虽然已经终止的进程，但仍然保留一些信息，等待其父进程为其收尸。\n\r1. 生的原因：\n父进程调用fork创建子进程后，子进程运行直至其终止，它立即从内存中移除，但进程描述符仍然保留在内存中（进程描述符占有极少的内存空间）。子进程的状态变成EXIT_ZOMBIE，并且向父进程发送SIGCHLD 信号，父进程此时应该调用 wait() 系 统调用来获取子进程的退出状态以及其它的信息。在 wait 调用之后，僵尸进程就完全从内存中移除。因此一个僵尸存在于其终止到父进程调用 wait 等函数这个时间的间隙，一般很快就消失，但如果编程不合理，父进程从不调用 wait 等系统调用来收集僵尸进程，那么这些进程会一直存在内存中。比如父进程死了，或者父进程忽略了SIGCHLD信号，或者父进程对SIGCHLD信号定义的信号处理函数有误。\n\r2. 如何避免：不能使用 kill 后接 SIGKILL 信号这样的命令像杀死普通进程一样杀死僵尸进程，因为僵尸进程是已经死掉的进程，它不能再接收任何信号。事实上，如果系统中僵尸进程并不多的话，我们也无需去消除它们，少数的僵尸进程并不会对系统的性能有什么影响。\n\r那么在编程时，如果能避免系统中大量产生僵尸进程呢？根据上面描述的，子进程在终止时会向父进程发 SIGCHLD 信号，Linux 默认是忽略该信号的，我们可以显示安装该信号，在信号处理函数中调用 wait 等函数来为其收尸，这样就能避免僵尸进程长期存在于系统中了。\r以上都是复制下面这个链接的，\r> http://www.cnblogs.com/hazir/p/zombie_process.html\n\r3. 危害：\n\r - 僵尸进程的pid不会释放，意味着如果有海量的僵尸进程，则会占满进程表项，是的后续进程无法执行fork（）\r - 内核栈无法释放，这个资源是很珍贵的。根本原因在于，task_stauct结构体没有释放。\r\r","slug":"linux-杂记","published":1,"updated":"2017-09-02T10:13:17.000Z","layout":"post","photos":[],"link":"","_id":"cjd4d1a0g001gryx4ftw2evzx","content":"<h1 id=\"什么是进程？\"><a href=\"#什么是进程？\" class=\"headerlink\" title=\"什么是进程？\"></a>什么是进程？</h1><ol>\n<li>进程是资源分配和和独立运行的单位；</li>\n<li>进程是操作系统中可执行程序的一次执行，换句话说进程就是拥有资源（cpu,内存，磁盘，进程ID，文件描述符，虚拟地址空间，端口号等）的程序；它是动态的；</li>\n<li>一个进程是由程序控制块（pcb也就是task_struct结构体）,代码和数据组成；其中进程控制块是描述进程的资源和运行状态等；它有内核来管理；</li>\n<li>在linux中可以通过ps，pstree来查看当前系统中的进程；</li>\n</ol>\n<h1 id=\"什么是线程？\"><a href=\"#什么是线程？\" class=\"headerlink\" title=\"什么是线程？\"></a>什么是线程？</h1><ol>\n<li>线程属于轻量级进程，一个进程可以拥有多个线程；linux下线程就是轻量级进程，所以线程的概念和进程是大同小异的。只不过是共享了大部分资源的进程罢了。</li>\n<li>线程是进程的一个执行流，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程是进程中的最小调度单位；</li>\n<li>用户线程指的是完全建立在用户空间的线程库，用户线程的建立，同步，销毁，调度完全在用户空间完成，不需要内核的帮助。因此这种线程的操作是极其快速的且低消耗的。</li>\n<li>用户态线程和内核态线程；主要的区分就是“谁来管理”线程，用户态是用户管理，内核态是内核管理（但肯定要提供一些API，例如创建）。</li>\n<li>线程的模型有哪些<ul>\n<li>n : 1 多个线程对应一个核心线程(进程); 线程的创建和销毁以及管理全部在用户层的线程库中实现，在内核层完全不知情，内核层看到的只是一个个进程。所以内核会以进程为单位调度任务运行。</li>\n<li>1：1    一个线程对应核心线程(进程); 在1:1模式下，线程的创建，调度，销毁全由内核完成，而其他操作则由线程库完成。</li>\n<li>m ：n ： 结合上面两种方式，如某些进程一一对应核内线程，其他线程完全在用户态实现。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"linux是如何管理进程的？\"><a href=\"#linux是如何管理进程的？\" class=\"headerlink\" title=\"linux是如何管理进程的？\"></a>linux是如何管理进程的？</h1><ol>\n<li>每个进程在linux内核拥有一个task_struct结构体（进程控制块的具体定义），里面包含了进程几乎所有的信息。在linux下，所谓的进程管理，就是反复操纵task_struct结构体的过程一点也不为过。</li>\n<li>操作系统对进程的所有管理都是围绕task_struct结构体为中心构建的。</li>\n</ol>\n<blockquote>\n<p>例如，给某个进程发送kill信息，操作系统就会根据task_struct结构体中的信息释放进程所占用的内存，信号量，打开文件相关的资源等等，然后当进程被切换出去时释放task_struct结构体，至此，系统再没有保存该进程的任意一点信息，标志着进程的死亡。</p>\n<p>再例如，进程的调度，由于每个进程都有其自己的上下文环境，或者说是当前系统状态的总和。被切换出去进程的这种系统状态需要保存到task_struct结构体中，以便下次恢复。而被切换进来的进程的上下文环境从哪里来呢？显而易见，在这个被调度进来的进程在真正运行之前，调度程序会从该进程的task_struct结构体中找到之前保存的上下文环境，然后将系统恢复到之前保存的状态，被调度进来的程序才真正开始运行。</p>\n</blockquote>\n<h1 id=\"进程的创建过程：\"><a href=\"#进程的创建过程：\" class=\"headerlink\" title=\"进程的创建过程：\"></a>进程的创建过程：</h1><ol>\n<li>操作系统给新进程分配一个全局唯一的pid号;</li>\n<li>并在内核空间中创建和分配诸如task_struct结构体，kernel堆栈等必要的数据结构和物理资源。</li>\n<li>然后复制父进程的与信号有关，与文件系统有关的运行环境。最后还会给task_struct结构体某些变量赋值，将来使用这些变量来将新进程运行的某些环境（如kernel栈的起始地址，EAX的初值等）设置为子进程自己独有的运行环境。并加入运行队列中，之后就是调度程序的事了。</li>\n<li>这个过程中涉及到了写时拷贝技术。在Linux程序中，fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</li>\n</ol>\n<h1 id=\"写时拷贝技术\"><a href=\"#写时拷贝技术\" class=\"headerlink\" title=\"写时拷贝技术:\"></a>写时拷贝技术:</h1><blockquote>\n<p><a href=\"http://blog.sina.cn/dpool/blog/s/blog_96757e4b01011b1n.html?vt=4\" target=\"_blank\" rel=\"external\">http://blog.sina.cn/dpool/blog/s/blog_96757e4b01011b1n.html?vt=4</a> </p>\n</blockquote>\n<p>在Linux程序中，fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。当子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。</p>\n<p>这就是分配内存的拖延战术，直到不得不做。操作系统中与此类似思想的还有页高速缓存器（page cache）。也就是，当有程序试图将数据写入文件的时候，linux操作系统并不会马上将数据写入disk中，而是将它们临时放在memory的一块区域。这块区域就叫做page cache。只有在关闭文件或者关机时，才有内核线程将page cache中的数据刷到磁盘中。这也就是非正常退出时，数据会损坏的原因。</p>\n<h1 id=\"在Linux中主要提供了fork、vfork、clone三个进程创建方法。\"><a href=\"#在Linux中主要提供了fork、vfork、clone三个进程创建方法。\" class=\"headerlink\" title=\"在Linux中主要提供了fork、vfork、clone三个进程创建方法。\"></a>在Linux中主要提供了fork、vfork、clone三个进程创建方法。</h1><blockquote>\n<p>以下总结来源:<a href=\"http://www.360doc.com/content/14/1231/11/14530056_437075775.shtml\" target=\"_blank\" rel=\"external\">http://www.360doc.com/content/14/1231/11/14530056_437075775.shtml</a> </p>\n</blockquote>\n<p>在linux源码中这三个调用的执行过程是执行fork(),vfork(),clone()时，通过一个系统调用表映射到sys_fork(),sys_vfork(),sys_clone(),再在这三个函数中去调用do_fork()去做具体的创建进程工作。</p>\n<ol>\n<li>fork创建一个进程时，子进程只是完全复制父进程的资源，复制出来的子进程有自己的task_struct结构和pid,但却复制父进程其它所有的资源。这样看来，fork是一个开销十分大的系统调用，这些开销并不是所有的情况下都是必须的，比如某进程fork出一个子进程后，其子进程仅仅是为了调用exec执行另一个可执行文件，那么在fork过程中对于虚存空间的复制将是一个多余的过程。但由于现在Linux中是采取了copy-on-write(COW写时复制)技术，为了降低开销，fork最初并不会真的产生两个不同的拷贝，因为在那个时候，大量的数据其实完全是一样的。写时复制是在推迟真正的数据拷贝。所以有了写时复制后呢，vfork其实现意义就不大了。</li>\n<li>vfork系统调用不同于fork，用vfork创建的子进程与父进程共享地址空间，也就是说子进程完全运行在父进程的地址空间上，如果这时子进程修改了某个变量，这将影响到父进程。但此处有一点要注意的是用vfork()创建的子进程必须显示调用exit()来结束，否则子进程将不能结束，而fork()则不存在这个情况。用 vfork创建子进程后，父进程会被阻塞直到子进程调用exec(exec，将一个新的可执行文件载入到地址空间并执行之。)或exit。vfork的好处是在子进程被创建后往往仅仅是为了调用exec执行另一个程序，因为它就不会对父进程的地址空间有任何引用，所以对地址空间的复制是多余的 ，因此通过vfork共享内存可以减少不必要的开销。</li>\n<li>clone :系统调用fork()和vfork()是无参数的，而clone()则带有参数。fork()是全部复制，vfork()是共享内存，而clone() 是则可以将父进程资源有选择地复制给子进程，而没有复制的数据结构则通过指针的复制让子进程共享，具体要复制哪些资源给子进程，由参数列表中的 clone_flags来决定。另外，clone()返回的是子进程的pid。<br>所以，这个就和上面说的轻量级进程联系起来，也可以这样说，linux通过clone调用生成线程。</li>\n</ol>\n<h1 id=\"fork，vfork，clone的区别\"><a href=\"#fork，vfork，clone的区别\" class=\"headerlink\" title=\"fork，vfork，clone的区别\"></a>fork，vfork，clone的区别</h1><ol>\n<li><p>fork出来的子进程是父进程的一个拷贝，即，子进程从父进程得到了数据段和堆栈段的拷贝，这些需要分配新的内存；而对于只读的代码段，通常使用共享内存的方式访问；而vfork则是子进程与父进程共享内存空间, 子进程对虚拟地址空间任何数据的修改同样为父进程所见；clone则由用户通过参clone_flags 的设置来决定哪些资源共享，哪些资源拷贝。 </p>\n</li>\n<li><p>fork不对父子进程的执行次序进行任何限制，fork返回后，子进程和父进程都从调用fork函数的下一条语句开始行，但父子进程运行顺序是不定的，它取决于内核的调度算法；而在vfork调用中，子进程先运行，父进程挂起，直到子进程调用了exec或exit之后，父子进程的执行次序才不再有限制；clone中由标志CLONE_VFORK来决定子进程在执行时父进程是阻塞还是运行，若没有设置该标志，则父子进程同时运行，设置了该标志，则父进程挂起，直到子进程结束为止。<br>他们成功执行时，父进程中返回子进程的进程号，在子进程中返回0。</p>\n</li>\n</ol>\n<h1 id=\"进程的调度\"><a href=\"#进程的调度\" class=\"headerlink\" title=\"进程的调度\"></a>进程的调度</h1><p>主要结构就是运行队列(双向循环链表)。为什么会有运行队列的存在呢?<br>当Linux内核要寻找一个新的进程在CPU上运行时，必须只考虑处于可运行状态的进程，（即在TASK_RUNNING状态的进程），因为扫描整个进程链表是相当低效的，所以引入了可运行状态进程的双向循环链表，也叫运行队列（runqueue）。运行队列容纳了系统中所有可以运行的进程，它是一个双向循环队列。</p>\n<p>也就是说，为了实现进程的调度，内核维护了一个叫做运行队列的数据结构。在这个数据结构中，active，expired，arrays是主要的三个结构。目前，咱们几个了解这三个就足够了。arrays也就是一个拥有两个成员的数组，每个数组有140个双向链表（也就是说，所有的就绪进程，按照时间片是否用完分成两个部分），对应了0~139 的140个优先级。active和expired分别指向arrays的两个成员。进程调度时，从active指针选择下一个要运行的程序。active中时间片用完的进程会被移动到expired队列，并且时间片会被重新计算，若active队列再无成员，则两个指针指向互换。</p>\n<p>linux进程主要分为 实时进程（例如键盘中输入字母或者鼠标点击之类的） 和 交互式进程与批处理进程（例如word程序，你总是写一会停一会）。内核不会动态调整前者的优先级，如需调整，则需要调用特殊的系统调用。而且，前者的优先级别最高。只有没有实时进程的时候，交互式或者批处理才会被调度执行。而后者的优先级会被内核动态调整。</p>\n<h1 id=\"进程有哪些调度策略？\"><a href=\"#进程有哪些调度策略？\" class=\"headerlink\" title=\"进程有哪些调度策略？\"></a>进程有哪些调度策略？</h1><p>这时候你分开说。对于实时进程，一般采用的是FIFO或者RR（轮询）机制。而对于交互式或者批处理进程，则采用动态调整优先级加运行队列机制来执行调度。这里有个大原则，如果有实时进程，那么交互式或者批处理则不会被执行。这个从进程优先级就可以看出来：实时（0~99），交互式批处理（100~139）。这时，你还可以举个例子。比如，你正在复制100文件，文件是一个一个被复制的，当复制到第50个的时候，你点了一下停止符号，它不会说是继续第51个文件的复制，而是直接停止。说明你鼠标的点击被插入到第51个文件之前了。所以实时进程永远比后者优先级高。</p>\n<h1 id=\"进程会在什么时候被调度\"><a href=\"#进程会在什么时候被调度\" class=\"headerlink\" title=\"进程会在什么时候被调度?\"></a>进程会在什么时候被调度?</h1><p>调度一般在进程退出内核态时，因为这时进程已经释放了可能导致内核死锁的资源。除了时间片用完触发调度，内核线程会在执行一些比较费时的任务时，自己调用调度函数，使其他进程有机会执行。</p>\n<p>首先进程调度不应该产生内核死锁之类的问题。如果进程在内核态，则它可能会占有产生死锁的资源（比如，进程想要操纵硬件必须使用系统调用。想想这样一种情况：用户想要使用打印机这种独占资源，内核线程，也就是代表用户进程在内核状态执行的那个线程，它一定改变了代表打印机的结构的某个标志位，或者持有打印机结构体内的自旋锁，互斥锁之类的资源，标志着打印机正在被使用，本来打算在返回用户态时释放这种互斥锁资源，但调度函数来了，我不管，我就要让你现在退出。然后该进程带着互斥锁退出。当下一个进程进来，也要使用打印机，这时，该进程向内核申请打印机，而内核却发现打印机正在被使用，所以内核等待打印机退出，而持有互斥锁的进程已经被内核踢出cpu了，谈何释放？所以这时，所有的进程都在等，被调度进来进程陷入内核出不来了,整条逻辑陷入了无限循环，如果是单核，那么死锁便产生了）。</p>\n<h1 id=\"关于僵尸进程\"><a href=\"#关于僵尸进程\" class=\"headerlink\" title=\"关于僵尸进程\"></a>关于僵尸进程</h1><p>僵尸进程指的是那些虽然已经终止的进程，但仍然保留一些信息，等待其父进程为其收尸。</p>\n<ol>\n<li><p>生的原因：<br>父进程调用fork创建子进程后，子进程运行直至其终止，它立即从内存中移除，但进程描述符仍然保留在内存中（进程描述符占有极少的内存空间）。子进程的状态变成EXIT_ZOMBIE，并且向父进程发送SIGCHLD 信号，父进程此时应该调用 wait() 系 统调用来获取子进程的退出状态以及其它的信息。在 wait 调用之后，僵尸进程就完全从内存中移除。因此一个僵尸存在于其终止到父进程调用 wait 等函数这个时间的间隙，一般很快就消失，但如果编程不合理，父进程从不调用 wait 等系统调用来收集僵尸进程，那么这些进程会一直存在内存中。比如父进程死了，或者父进程忽略了SIGCHLD信号，或者父进程对SIGCHLD信号定义的信号处理函数有误。</p>\n</li>\n<li><p>如何避免：不能使用 kill 后接 SIGKILL 信号这样的命令像杀死普通进程一样杀死僵尸进程，因为僵尸进程是已经死掉的进程，它不能再接收任何信号。事实上，如果系统中僵尸进程并不多的话，我们也无需去消除它们，少数的僵尸进程并不会对系统的性能有什么影响。</p>\n</li>\n</ol>\n<p>那么在编程时，如果能避免系统中大量产生僵尸进程呢？根据上面描述的，子进程在终止时会向父进程发 SIGCHLD 信号，Linux 默认是忽略该信号的，我们可以显示安装该信号，在信号处理函数中调用 wait 等函数来为其收尸，这样就能避免僵尸进程长期存在于系统中了。<br>以上都是复制下面这个链接的，</p>\n<blockquote>\n<p><a href=\"http://www.cnblogs.com/hazir/p/zombie_process.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/hazir/p/zombie_process.html</a></p>\n</blockquote>\n<ol>\n<li><p>危害：</p>\n<ul>\n<li>僵尸进程的pid不会释放，意味着如果有海量的僵尸进程，则会占满进程表项，是的后续进程无法执行fork（）</li>\n<li>内核栈无法释放，这个资源是很珍贵的。根本原因在于，task_stauct结构体没有释放。</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是进程？\"><a href=\"#什么是进程？\" class=\"headerlink\" title=\"什么是进程？\"></a>什么是进程？</h1><ol>\n<li>进程是资源分配和和独立运行的单位；</li>\n<li>进程是操作系统中可执行程序的一次执行，换句话说进程就是拥有资源（cpu,内存，磁盘，进程ID，文件描述符，虚拟地址空间，端口号等）的程序；它是动态的；</li>\n<li>一个进程是由程序控制块（pcb也就是task_struct结构体）,代码和数据组成；其中进程控制块是描述进程的资源和运行状态等；它有内核来管理；</li>\n<li>在linux中可以通过ps，pstree来查看当前系统中的进程；</li>\n</ol>\n<h1 id=\"什么是线程？\"><a href=\"#什么是线程？\" class=\"headerlink\" title=\"什么是线程？\"></a>什么是线程？</h1><ol>\n<li>线程属于轻量级进程，一个进程可以拥有多个线程；linux下线程就是轻量级进程，所以线程的概念和进程是大同小异的。只不过是共享了大部分资源的进程罢了。</li>\n<li>线程是进程的一个执行流，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程是进程中的最小调度单位；</li>\n<li>用户线程指的是完全建立在用户空间的线程库，用户线程的建立，同步，销毁，调度完全在用户空间完成，不需要内核的帮助。因此这种线程的操作是极其快速的且低消耗的。</li>\n<li>用户态线程和内核态线程；主要的区分就是“谁来管理”线程，用户态是用户管理，内核态是内核管理（但肯定要提供一些API，例如创建）。</li>\n<li>线程的模型有哪些<ul>\n<li>n : 1 多个线程对应一个核心线程(进程); 线程的创建和销毁以及管理全部在用户层的线程库中实现，在内核层完全不知情，内核层看到的只是一个个进程。所以内核会以进程为单位调度任务运行。</li>\n<li>1：1    一个线程对应核心线程(进程); 在1:1模式下，线程的创建，调度，销毁全由内核完成，而其他操作则由线程库完成。</li>\n<li>m ：n ： 结合上面两种方式，如某些进程一一对应核内线程，其他线程完全在用户态实现。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"linux是如何管理进程的？\"><a href=\"#linux是如何管理进程的？\" class=\"headerlink\" title=\"linux是如何管理进程的？\"></a>linux是如何管理进程的？</h1><ol>\n<li>每个进程在linux内核拥有一个task_struct结构体（进程控制块的具体定义），里面包含了进程几乎所有的信息。在linux下，所谓的进程管理，就是反复操纵task_struct结构体的过程一点也不为过。</li>\n<li>操作系统对进程的所有管理都是围绕task_struct结构体为中心构建的。</li>\n</ol>\n<blockquote>\n<p>例如，给某个进程发送kill信息，操作系统就会根据task_struct结构体中的信息释放进程所占用的内存，信号量，打开文件相关的资源等等，然后当进程被切换出去时释放task_struct结构体，至此，系统再没有保存该进程的任意一点信息，标志着进程的死亡。</p>\n<p>再例如，进程的调度，由于每个进程都有其自己的上下文环境，或者说是当前系统状态的总和。被切换出去进程的这种系统状态需要保存到task_struct结构体中，以便下次恢复。而被切换进来的进程的上下文环境从哪里来呢？显而易见，在这个被调度进来的进程在真正运行之前，调度程序会从该进程的task_struct结构体中找到之前保存的上下文环境，然后将系统恢复到之前保存的状态，被调度进来的程序才真正开始运行。</p>\n</blockquote>\n<h1 id=\"进程的创建过程：\"><a href=\"#进程的创建过程：\" class=\"headerlink\" title=\"进程的创建过程：\"></a>进程的创建过程：</h1><ol>\n<li>操作系统给新进程分配一个全局唯一的pid号;</li>\n<li>并在内核空间中创建和分配诸如task_struct结构体，kernel堆栈等必要的数据结构和物理资源。</li>\n<li>然后复制父进程的与信号有关，与文件系统有关的运行环境。最后还会给task_struct结构体某些变量赋值，将来使用这些变量来将新进程运行的某些环境（如kernel栈的起始地址，EAX的初值等）设置为子进程自己独有的运行环境。并加入运行队列中，之后就是调度程序的事了。</li>\n<li>这个过程中涉及到了写时拷贝技术。在Linux程序中，fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</li>\n</ol>\n<h1 id=\"写时拷贝技术\"><a href=\"#写时拷贝技术\" class=\"headerlink\" title=\"写时拷贝技术:\"></a>写时拷贝技术:</h1><blockquote>\n<p><a href=\"http://blog.sina.cn/dpool/blog/s/blog_96757e4b01011b1n.html?vt=4\" target=\"_blank\" rel=\"external\">http://blog.sina.cn/dpool/blog/s/blog_96757e4b01011b1n.html?vt=4</a> </p>\n</blockquote>\n<p>在Linux程序中，fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。当子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。</p>\n<p>这就是分配内存的拖延战术，直到不得不做。操作系统中与此类似思想的还有页高速缓存器（page cache）。也就是，当有程序试图将数据写入文件的时候，linux操作系统并不会马上将数据写入disk中，而是将它们临时放在memory的一块区域。这块区域就叫做page cache。只有在关闭文件或者关机时，才有内核线程将page cache中的数据刷到磁盘中。这也就是非正常退出时，数据会损坏的原因。</p>\n<h1 id=\"在Linux中主要提供了fork、vfork、clone三个进程创建方法。\"><a href=\"#在Linux中主要提供了fork、vfork、clone三个进程创建方法。\" class=\"headerlink\" title=\"在Linux中主要提供了fork、vfork、clone三个进程创建方法。\"></a>在Linux中主要提供了fork、vfork、clone三个进程创建方法。</h1><blockquote>\n<p>以下总结来源:<a href=\"http://www.360doc.com/content/14/1231/11/14530056_437075775.shtml\" target=\"_blank\" rel=\"external\">http://www.360doc.com/content/14/1231/11/14530056_437075775.shtml</a> </p>\n</blockquote>\n<p>在linux源码中这三个调用的执行过程是执行fork(),vfork(),clone()时，通过一个系统调用表映射到sys_fork(),sys_vfork(),sys_clone(),再在这三个函数中去调用do_fork()去做具体的创建进程工作。</p>\n<ol>\n<li>fork创建一个进程时，子进程只是完全复制父进程的资源，复制出来的子进程有自己的task_struct结构和pid,但却复制父进程其它所有的资源。这样看来，fork是一个开销十分大的系统调用，这些开销并不是所有的情况下都是必须的，比如某进程fork出一个子进程后，其子进程仅仅是为了调用exec执行另一个可执行文件，那么在fork过程中对于虚存空间的复制将是一个多余的过程。但由于现在Linux中是采取了copy-on-write(COW写时复制)技术，为了降低开销，fork最初并不会真的产生两个不同的拷贝，因为在那个时候，大量的数据其实完全是一样的。写时复制是在推迟真正的数据拷贝。所以有了写时复制后呢，vfork其实现意义就不大了。</li>\n<li>vfork系统调用不同于fork，用vfork创建的子进程与父进程共享地址空间，也就是说子进程完全运行在父进程的地址空间上，如果这时子进程修改了某个变量，这将影响到父进程。但此处有一点要注意的是用vfork()创建的子进程必须显示调用exit()来结束，否则子进程将不能结束，而fork()则不存在这个情况。用 vfork创建子进程后，父进程会被阻塞直到子进程调用exec(exec，将一个新的可执行文件载入到地址空间并执行之。)或exit。vfork的好处是在子进程被创建后往往仅仅是为了调用exec执行另一个程序，因为它就不会对父进程的地址空间有任何引用，所以对地址空间的复制是多余的 ，因此通过vfork共享内存可以减少不必要的开销。</li>\n<li>clone :系统调用fork()和vfork()是无参数的，而clone()则带有参数。fork()是全部复制，vfork()是共享内存，而clone() 是则可以将父进程资源有选择地复制给子进程，而没有复制的数据结构则通过指针的复制让子进程共享，具体要复制哪些资源给子进程，由参数列表中的 clone_flags来决定。另外，clone()返回的是子进程的pid。<br>所以，这个就和上面说的轻量级进程联系起来，也可以这样说，linux通过clone调用生成线程。</li>\n</ol>\n<h1 id=\"fork，vfork，clone的区别\"><a href=\"#fork，vfork，clone的区别\" class=\"headerlink\" title=\"fork，vfork，clone的区别\"></a>fork，vfork，clone的区别</h1><ol>\n<li><p>fork出来的子进程是父进程的一个拷贝，即，子进程从父进程得到了数据段和堆栈段的拷贝，这些需要分配新的内存；而对于只读的代码段，通常使用共享内存的方式访问；而vfork则是子进程与父进程共享内存空间, 子进程对虚拟地址空间任何数据的修改同样为父进程所见；clone则由用户通过参clone_flags 的设置来决定哪些资源共享，哪些资源拷贝。 </p>\n</li>\n<li><p>fork不对父子进程的执行次序进行任何限制，fork返回后，子进程和父进程都从调用fork函数的下一条语句开始行，但父子进程运行顺序是不定的，它取决于内核的调度算法；而在vfork调用中，子进程先运行，父进程挂起，直到子进程调用了exec或exit之后，父子进程的执行次序才不再有限制；clone中由标志CLONE_VFORK来决定子进程在执行时父进程是阻塞还是运行，若没有设置该标志，则父子进程同时运行，设置了该标志，则父进程挂起，直到子进程结束为止。<br>他们成功执行时，父进程中返回子进程的进程号，在子进程中返回0。</p>\n</li>\n</ol>\n<h1 id=\"进程的调度\"><a href=\"#进程的调度\" class=\"headerlink\" title=\"进程的调度\"></a>进程的调度</h1><p>主要结构就是运行队列(双向循环链表)。为什么会有运行队列的存在呢?<br>当Linux内核要寻找一个新的进程在CPU上运行时，必须只考虑处于可运行状态的进程，（即在TASK_RUNNING状态的进程），因为扫描整个进程链表是相当低效的，所以引入了可运行状态进程的双向循环链表，也叫运行队列（runqueue）。运行队列容纳了系统中所有可以运行的进程，它是一个双向循环队列。</p>\n<p>也就是说，为了实现进程的调度，内核维护了一个叫做运行队列的数据结构。在这个数据结构中，active，expired，arrays是主要的三个结构。目前，咱们几个了解这三个就足够了。arrays也就是一个拥有两个成员的数组，每个数组有140个双向链表（也就是说，所有的就绪进程，按照时间片是否用完分成两个部分），对应了0~139 的140个优先级。active和expired分别指向arrays的两个成员。进程调度时，从active指针选择下一个要运行的程序。active中时间片用完的进程会被移动到expired队列，并且时间片会被重新计算，若active队列再无成员，则两个指针指向互换。</p>\n<p>linux进程主要分为 实时进程（例如键盘中输入字母或者鼠标点击之类的） 和 交互式进程与批处理进程（例如word程序，你总是写一会停一会）。内核不会动态调整前者的优先级，如需调整，则需要调用特殊的系统调用。而且，前者的优先级别最高。只有没有实时进程的时候，交互式或者批处理才会被调度执行。而后者的优先级会被内核动态调整。</p>\n<h1 id=\"进程有哪些调度策略？\"><a href=\"#进程有哪些调度策略？\" class=\"headerlink\" title=\"进程有哪些调度策略？\"></a>进程有哪些调度策略？</h1><p>这时候你分开说。对于实时进程，一般采用的是FIFO或者RR（轮询）机制。而对于交互式或者批处理进程，则采用动态调整优先级加运行队列机制来执行调度。这里有个大原则，如果有实时进程，那么交互式或者批处理则不会被执行。这个从进程优先级就可以看出来：实时（0~99），交互式批处理（100~139）。这时，你还可以举个例子。比如，你正在复制100文件，文件是一个一个被复制的，当复制到第50个的时候，你点了一下停止符号，它不会说是继续第51个文件的复制，而是直接停止。说明你鼠标的点击被插入到第51个文件之前了。所以实时进程永远比后者优先级高。</p>\n<h1 id=\"进程会在什么时候被调度\"><a href=\"#进程会在什么时候被调度\" class=\"headerlink\" title=\"进程会在什么时候被调度?\"></a>进程会在什么时候被调度?</h1><p>调度一般在进程退出内核态时，因为这时进程已经释放了可能导致内核死锁的资源。除了时间片用完触发调度，内核线程会在执行一些比较费时的任务时，自己调用调度函数，使其他进程有机会执行。</p>\n<p>首先进程调度不应该产生内核死锁之类的问题。如果进程在内核态，则它可能会占有产生死锁的资源（比如，进程想要操纵硬件必须使用系统调用。想想这样一种情况：用户想要使用打印机这种独占资源，内核线程，也就是代表用户进程在内核状态执行的那个线程，它一定改变了代表打印机的结构的某个标志位，或者持有打印机结构体内的自旋锁，互斥锁之类的资源，标志着打印机正在被使用，本来打算在返回用户态时释放这种互斥锁资源，但调度函数来了，我不管，我就要让你现在退出。然后该进程带着互斥锁退出。当下一个进程进来，也要使用打印机，这时，该进程向内核申请打印机，而内核却发现打印机正在被使用，所以内核等待打印机退出，而持有互斥锁的进程已经被内核踢出cpu了，谈何释放？所以这时，所有的进程都在等，被调度进来进程陷入内核出不来了,整条逻辑陷入了无限循环，如果是单核，那么死锁便产生了）。</p>\n<h1 id=\"关于僵尸进程\"><a href=\"#关于僵尸进程\" class=\"headerlink\" title=\"关于僵尸进程\"></a>关于僵尸进程</h1><p>僵尸进程指的是那些虽然已经终止的进程，但仍然保留一些信息，等待其父进程为其收尸。</p>\n<ol>\n<li><p>生的原因：<br>父进程调用fork创建子进程后，子进程运行直至其终止，它立即从内存中移除，但进程描述符仍然保留在内存中（进程描述符占有极少的内存空间）。子进程的状态变成EXIT_ZOMBIE，并且向父进程发送SIGCHLD 信号，父进程此时应该调用 wait() 系 统调用来获取子进程的退出状态以及其它的信息。在 wait 调用之后，僵尸进程就完全从内存中移除。因此一个僵尸存在于其终止到父进程调用 wait 等函数这个时间的间隙，一般很快就消失，但如果编程不合理，父进程从不调用 wait 等系统调用来收集僵尸进程，那么这些进程会一直存在内存中。比如父进程死了，或者父进程忽略了SIGCHLD信号，或者父进程对SIGCHLD信号定义的信号处理函数有误。</p>\n</li>\n<li><p>如何避免：不能使用 kill 后接 SIGKILL 信号这样的命令像杀死普通进程一样杀死僵尸进程，因为僵尸进程是已经死掉的进程，它不能再接收任何信号。事实上，如果系统中僵尸进程并不多的话，我们也无需去消除它们，少数的僵尸进程并不会对系统的性能有什么影响。</p>\n</li>\n</ol>\n<p>那么在编程时，如果能避免系统中大量产生僵尸进程呢？根据上面描述的，子进程在终止时会向父进程发 SIGCHLD 信号，Linux 默认是忽略该信号的，我们可以显示安装该信号，在信号处理函数中调用 wait 等函数来为其收尸，这样就能避免僵尸进程长期存在于系统中了。<br>以上都是复制下面这个链接的，</p>\n<blockquote>\n<p><a href=\"http://www.cnblogs.com/hazir/p/zombie_process.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/hazir/p/zombie_process.html</a></p>\n</blockquote>\n<ol>\n<li><p>危害：</p>\n<ul>\n<li>僵尸进程的pid不会释放，意味着如果有海量的僵尸进程，则会占满进程表项，是的后续进程无法执行fork（）</li>\n<li>内核栈无法释放，这个资源是很珍贵的。根本原因在于，task_stauct结构体没有释放。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"代码规范与整洁之道","comments":1,"date":"2017-08-27T07:59:08.000Z","update":"2017-08-27T07:59:08.000Z","_content":"\n# 1. 别传递以及返回null值\n\n> 在方法中返回null值是很糟糕的的做法，但将null值传递给其他方法也就更糟糕了，除非API要求向他传递null，否则应尽量避免。\n\n原因如下：\n\n1. 当传参时，传入null值，我们就必须创建异常，或者使用断言，但这些都会导致运行时错误。所以，应尽量避免传入null值。\n2. 返回值为null时，处理者必须对其进行非空判断，增加自己的工作量。而且在python中，可以同时返回多个变量，返回null，会使接受返回值变得很麻烦。替代方案就是抛出异常，或者返回特例。\n\n\n# 2. 避免凌乱的错误处理代码\n\n> 1. 使用异常，而非返回码\n\n原因：它会搞乱调用者的代码，调用者必须在调用之后即即刻检查错误，这容易别遗忘，而且处理起来麻烦\n \n\n","source":"_posts/代码规范与整洁之道.md","raw":"---\ntitle: 代码规范与整洁之道\ncomments: true\ntags:\n  - JAVA\n  - 代码规范\ncategories:\n  - JAVA\ndate: 2017-08-27 15:59:08\nupdate: 2017-08-27 15:59:08\n\n---\n\n# 1. 别传递以及返回null值\n\n> 在方法中返回null值是很糟糕的的做法，但将null值传递给其他方法也就更糟糕了，除非API要求向他传递null，否则应尽量避免。\n\n原因如下：\n\n1. 当传参时，传入null值，我们就必须创建异常，或者使用断言，但这些都会导致运行时错误。所以，应尽量避免传入null值。\n2. 返回值为null时，处理者必须对其进行非空判断，增加自己的工作量。而且在python中，可以同时返回多个变量，返回null，会使接受返回值变得很麻烦。替代方案就是抛出异常，或者返回特例。\n\n\n# 2. 避免凌乱的错误处理代码\n\n> 1. 使用异常，而非返回码\n\n原因：它会搞乱调用者的代码，调用者必须在调用之后即即刻检查错误，这容易别遗忘，而且处理起来麻烦\n \n\n","slug":"代码规范与整洁之道","published":1,"updated":"2017-09-02T10:11:40.000Z","layout":"post","photos":[],"link":"","_id":"cjd4d1a0l001rryx4dd57j9zp","content":"<h1 id=\"1-别传递以及返回null值\"><a href=\"#1-别传递以及返回null值\" class=\"headerlink\" title=\"1. 别传递以及返回null值\"></a>1. 别传递以及返回null值</h1><blockquote>\n<p>在方法中返回null值是很糟糕的的做法，但将null值传递给其他方法也就更糟糕了，除非API要求向他传递null，否则应尽量避免。</p>\n</blockquote>\n<p>原因如下：</p>\n<ol>\n<li>当传参时，传入null值，我们就必须创建异常，或者使用断言，但这些都会导致运行时错误。所以，应尽量避免传入null值。</li>\n<li>返回值为null时，处理者必须对其进行非空判断，增加自己的工作量。而且在python中，可以同时返回多个变量，返回null，会使接受返回值变得很麻烦。替代方案就是抛出异常，或者返回特例。</li>\n</ol>\n<h1 id=\"2-避免凌乱的错误处理代码\"><a href=\"#2-避免凌乱的错误处理代码\" class=\"headerlink\" title=\"2. 避免凌乱的错误处理代码\"></a>2. 避免凌乱的错误处理代码</h1><blockquote>\n<ol>\n<li>使用异常，而非返回码</li>\n</ol>\n</blockquote>\n<p>原因：它会搞乱调用者的代码，调用者必须在调用之后即即刻检查错误，这容易别遗忘，而且处理起来麻烦</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-别传递以及返回null值\"><a href=\"#1-别传递以及返回null值\" class=\"headerlink\" title=\"1. 别传递以及返回null值\"></a>1. 别传递以及返回null值</h1><blockquote>\n<p>在方法中返回null值是很糟糕的的做法，但将null值传递给其他方法也就更糟糕了，除非API要求向他传递null，否则应尽量避免。</p>\n</blockquote>\n<p>原因如下：</p>\n<ol>\n<li>当传参时，传入null值，我们就必须创建异常，或者使用断言，但这些都会导致运行时错误。所以，应尽量避免传入null值。</li>\n<li>返回值为null时，处理者必须对其进行非空判断，增加自己的工作量。而且在python中，可以同时返回多个变量，返回null，会使接受返回值变得很麻烦。替代方案就是抛出异常，或者返回特例。</li>\n</ol>\n<h1 id=\"2-避免凌乱的错误处理代码\"><a href=\"#2-避免凌乱的错误处理代码\" class=\"headerlink\" title=\"2. 避免凌乱的错误处理代码\"></a>2. 避免凌乱的错误处理代码</h1><blockquote>\n<ol>\n<li>使用异常，而非返回码</li>\n</ol>\n</blockquote>\n<p>原因：它会搞乱调用者的代码，调用者必须在调用之后即即刻检查错误，这容易别遗忘，而且处理起来麻烦</p>\n"},{"title":"代码覆盖率","comments":1,"date":"2017-08-13T10:06:59.000Z","update":"2017-08-13T10:06:59.000Z","_content":"\n\n## JaCoCo\n\n### JaCoCo简述\nJaCoCo是一个开源的覆盖率工具( 官网地址：http://www.eclemma.org/JaCoCo/ )，它针对的开发语言是java，其使用方法很灵活，可以嵌入到Ant、Maven中；可以作为Eclipse插件，可以使用其JavaAgent技术监控Java程序等等。\n很多第三方的工具提供了对JaCoCo的集成，如sonar、Jenkins等。\n\n### 使用姿势\n\n* 在Bulid 的 plungs中加入以下plugn\n\n```\n <plugin>\n    <groupId>org.jacoco</groupId>\n    <artifactId>jacoco-maven-plugin</artifactId>\n    <version>0.7.9</version>\n    <executions>\n        <execution>\n            <id>pre-unit-test</id>\n            <goals>\n                <goal>prepare-agent</goal>\n            </goals>\n            <configuration>\n                <destFile>${project.build.directory}/coverage-reports/jacoco.exec</destFile>\n                <propertyName>surefireArgLine</propertyName>\n            </configuration>\n        </execution>\n        <execution>\n            <id>post-unit-test</id>\n            <phase>test</phase>\n            <goals>\n                <goal>report</goal>\n            </goals>\n            <configuration>\n                <dataFile>${project.build.directory}/coverage-reports/jacoco.exec</dataFile>\n                <outputDirectory>${project.reporting.outputDirectory}/jacoco</outputDirectory>\n                <--包含要被测试的类-->\n                <includes>\n                    <include>me/ele/**</include>\n                  \n                </includes>\n                <--排除要被测试的类-->\n                <excludes>\n                    <exclude>**/*Mock*.class</exclude>\n                </excludes>\n            </configuration>\n        </execution>\n    </executions>\n</plugin>\n<plugin>\n    <groupId>org.apache.maven.plugins</groupId>\n    <artifactId>maven-surefire-plugin</artifactId>\n    <version>2.19.1</version>\n    <configuration>\n        <argLine>${surefireArgLine}</argLine>\n        <skipTests>false</skipTests>\n        <testFailureIgnore>true</testFailureIgnore>\n        <--包含测试的类-->\n        <includes>\n            <include>me/ele/**</include>\n            <include>com/**</include>\n        </includes>\n        <--排除测试的类-->\n        <excludes>\n            <exclude>**/Account*Test.java</exclude>\n        </excludes>\n    </configuration>\n</plugin>\n<plugin>\n    <groupId>me.ele.fin</groupId>\n    <artifactId>jacoco-console-report</artifactId>\n    <version>0.0.1-RELEASE</version>\n    <executions>\n        <execution>\n            <id>console</id>\n            <phase>prepare-package</phase>\n            <goals>\n                <goal>console</goal>\n            </goals>\n        </execution>\n    </executions>\n</plugin>\n\n```\n\n* 在pom下加入reporting\n\n```\n<reporting>\n    <plugins>\n        <plugin>\n            <groupId>org.jacoco</groupId>\n            <artifactId>jacoco-maven-plugin</artifactId>\n            <reportSets>\n                <reportSet>\n                    <reports>\n                        <!-- select non-aggregate reports -->\n                        <report>report</report>\n                    </reports>\n                </reportSet>\n            </reportSets>\n        </plugin>\n    </plugins>\n</reporting>\n\n```\n\n* mvn命令, 生成测试报告文档\n\n```\n mvn clean package -U -DfailIfNoTests=false -f om.xml -X \n\n```\n\n### JaCoCo遇到的问题以及解决方式：\n\n1. 项目运行时卡住不动了，解决方法，在每个模块下的pom都配置jacoco。\n2. 项目运行报错，类重复加载。\n产生的原因：test类加载配置文件不同统一，spring配置文件加载了两次造成。\n另一次是，redis与mysql更换导致运行，运行失败、速度过慢，覆盖率大幅度下降。\n3. [${surefireArgLine}标红解决方案](https://stackoverflow.com/questions/24115142/intellij-error-when-running-unit-test-could-not-find-or-load-main-class-suref)\n\n### JaCoCo参考文档\n\n[参考文档1:jacoco 原理篇](http://blog.csdn.net/gc_cg/article/details/53172053)\n\n[参考文档2: Jacoco覆盖率工具使用之maven篇](http://blog.csdn.net/wangmuming/article/details/28868833)\n\n\n## 单元测试\n### 单元测试的概述\n\n所谓单元测试，是指对软件设计的最小单位，进行正确性检验的测试工作。而检验的方法，一般来说是由开发人员编写一小段测试代码，根据被测目标代码的应用场景，设计拥有合理覆盖度的输入条件，调用执行目标代码，然后判断输出结果是否与预期一致。被测试目标代码一般应具体到类的方法层面上。\n\n总之，单元测试是一个方法层级上的测试，单元测试也是最细粒度的测试，用于测试一个类的每一个方法都已经满足了方法的功能需求。\n\n### 一个单元测试用例需要包含什么\n\n1. 每个测试有明确的预期结果\n2. 每个测试一个(必须要有)断言,没有断言的case是骗人的case\n3. 如果你发现一个case需要两个断言,那么它们应该是两个case\n4. 为了测试时隔离模块(如下游soa服务,数据库等),使用stubs、mock或fake等测试马甲程序\n5. 有必要的注释，描述unit test case的基本作用\n\n\n### 单元测试(unit test)对象\n1. 单元测试关注一个方法或一个类。它应该非常小，最多只有几行代码。\n2. 因为非常小一个单元测试用例应该在几毫秒内运行完成。\n3. 任何用到外部依赖（数据库、WebService、文件系统、I/O）的测试都不是单元测试，而是“集成测试（integration test）”、“综合测试（integrated test）”、验收测试、端到端测试等等\n\n\n\n\n## MOCK\n\n### Mockito简介\n\n什么是mock？\n在软件开发的世界之外, \"mock\"一词是指模仿或者效仿。 因此可以将“mock”理解为一个替身，替代者。在软件开发中提及\"mock\"，通常理解为模拟对象或者Fake。\n\n为什么需要Mock?\nMock是为了解决units之间由于耦合而难于被测试的问题。所以mock object是unit test的一部分。\n\n\n[参考链接1:Mockito浅谈](http://www.jianshu.com/p/77db26b4fb54)\n\n[参考链接2:手把手教你 Mockito 的使用](https://segmentfault.com/a/1190000006746409)\n\n### maven依赖\n\n```\n<dependency>\n    <groupId>org.mockito</groupId>\n    <artifactId>mockito-all</artifactId>\n    <version>2.0.2-beta</version>\n</dependency>\n\n```\n\n\n[个人demo参考](https://github.com/onaple/JunitAndMock)","source":"_posts/代码覆盖率.md","raw":"---\n\ntitle: 代码覆盖率\ncomments: true\ntags:\n  - 单元测试\n  - JACOCO\ncategories:\n  - JAVA\ndate: 2017-08-13 18:06:59\nupdate: 2017-08-13 18:06:59\n\n---\n\n\n## JaCoCo\n\n### JaCoCo简述\nJaCoCo是一个开源的覆盖率工具( 官网地址：http://www.eclemma.org/JaCoCo/ )，它针对的开发语言是java，其使用方法很灵活，可以嵌入到Ant、Maven中；可以作为Eclipse插件，可以使用其JavaAgent技术监控Java程序等等。\n很多第三方的工具提供了对JaCoCo的集成，如sonar、Jenkins等。\n\n### 使用姿势\n\n* 在Bulid 的 plungs中加入以下plugn\n\n```\n <plugin>\n    <groupId>org.jacoco</groupId>\n    <artifactId>jacoco-maven-plugin</artifactId>\n    <version>0.7.9</version>\n    <executions>\n        <execution>\n            <id>pre-unit-test</id>\n            <goals>\n                <goal>prepare-agent</goal>\n            </goals>\n            <configuration>\n                <destFile>${project.build.directory}/coverage-reports/jacoco.exec</destFile>\n                <propertyName>surefireArgLine</propertyName>\n            </configuration>\n        </execution>\n        <execution>\n            <id>post-unit-test</id>\n            <phase>test</phase>\n            <goals>\n                <goal>report</goal>\n            </goals>\n            <configuration>\n                <dataFile>${project.build.directory}/coverage-reports/jacoco.exec</dataFile>\n                <outputDirectory>${project.reporting.outputDirectory}/jacoco</outputDirectory>\n                <--包含要被测试的类-->\n                <includes>\n                    <include>me/ele/**</include>\n                  \n                </includes>\n                <--排除要被测试的类-->\n                <excludes>\n                    <exclude>**/*Mock*.class</exclude>\n                </excludes>\n            </configuration>\n        </execution>\n    </executions>\n</plugin>\n<plugin>\n    <groupId>org.apache.maven.plugins</groupId>\n    <artifactId>maven-surefire-plugin</artifactId>\n    <version>2.19.1</version>\n    <configuration>\n        <argLine>${surefireArgLine}</argLine>\n        <skipTests>false</skipTests>\n        <testFailureIgnore>true</testFailureIgnore>\n        <--包含测试的类-->\n        <includes>\n            <include>me/ele/**</include>\n            <include>com/**</include>\n        </includes>\n        <--排除测试的类-->\n        <excludes>\n            <exclude>**/Account*Test.java</exclude>\n        </excludes>\n    </configuration>\n</plugin>\n<plugin>\n    <groupId>me.ele.fin</groupId>\n    <artifactId>jacoco-console-report</artifactId>\n    <version>0.0.1-RELEASE</version>\n    <executions>\n        <execution>\n            <id>console</id>\n            <phase>prepare-package</phase>\n            <goals>\n                <goal>console</goal>\n            </goals>\n        </execution>\n    </executions>\n</plugin>\n\n```\n\n* 在pom下加入reporting\n\n```\n<reporting>\n    <plugins>\n        <plugin>\n            <groupId>org.jacoco</groupId>\n            <artifactId>jacoco-maven-plugin</artifactId>\n            <reportSets>\n                <reportSet>\n                    <reports>\n                        <!-- select non-aggregate reports -->\n                        <report>report</report>\n                    </reports>\n                </reportSet>\n            </reportSets>\n        </plugin>\n    </plugins>\n</reporting>\n\n```\n\n* mvn命令, 生成测试报告文档\n\n```\n mvn clean package -U -DfailIfNoTests=false -f om.xml -X \n\n```\n\n### JaCoCo遇到的问题以及解决方式：\n\n1. 项目运行时卡住不动了，解决方法，在每个模块下的pom都配置jacoco。\n2. 项目运行报错，类重复加载。\n产生的原因：test类加载配置文件不同统一，spring配置文件加载了两次造成。\n另一次是，redis与mysql更换导致运行，运行失败、速度过慢，覆盖率大幅度下降。\n3. [${surefireArgLine}标红解决方案](https://stackoverflow.com/questions/24115142/intellij-error-when-running-unit-test-could-not-find-or-load-main-class-suref)\n\n### JaCoCo参考文档\n\n[参考文档1:jacoco 原理篇](http://blog.csdn.net/gc_cg/article/details/53172053)\n\n[参考文档2: Jacoco覆盖率工具使用之maven篇](http://blog.csdn.net/wangmuming/article/details/28868833)\n\n\n## 单元测试\n### 单元测试的概述\n\n所谓单元测试，是指对软件设计的最小单位，进行正确性检验的测试工作。而检验的方法，一般来说是由开发人员编写一小段测试代码，根据被测目标代码的应用场景，设计拥有合理覆盖度的输入条件，调用执行目标代码，然后判断输出结果是否与预期一致。被测试目标代码一般应具体到类的方法层面上。\n\n总之，单元测试是一个方法层级上的测试，单元测试也是最细粒度的测试，用于测试一个类的每一个方法都已经满足了方法的功能需求。\n\n### 一个单元测试用例需要包含什么\n\n1. 每个测试有明确的预期结果\n2. 每个测试一个(必须要有)断言,没有断言的case是骗人的case\n3. 如果你发现一个case需要两个断言,那么它们应该是两个case\n4. 为了测试时隔离模块(如下游soa服务,数据库等),使用stubs、mock或fake等测试马甲程序\n5. 有必要的注释，描述unit test case的基本作用\n\n\n### 单元测试(unit test)对象\n1. 单元测试关注一个方法或一个类。它应该非常小，最多只有几行代码。\n2. 因为非常小一个单元测试用例应该在几毫秒内运行完成。\n3. 任何用到外部依赖（数据库、WebService、文件系统、I/O）的测试都不是单元测试，而是“集成测试（integration test）”、“综合测试（integrated test）”、验收测试、端到端测试等等\n\n\n\n\n## MOCK\n\n### Mockito简介\n\n什么是mock？\n在软件开发的世界之外, \"mock\"一词是指模仿或者效仿。 因此可以将“mock”理解为一个替身，替代者。在软件开发中提及\"mock\"，通常理解为模拟对象或者Fake。\n\n为什么需要Mock?\nMock是为了解决units之间由于耦合而难于被测试的问题。所以mock object是unit test的一部分。\n\n\n[参考链接1:Mockito浅谈](http://www.jianshu.com/p/77db26b4fb54)\n\n[参考链接2:手把手教你 Mockito 的使用](https://segmentfault.com/a/1190000006746409)\n\n### maven依赖\n\n```\n<dependency>\n    <groupId>org.mockito</groupId>\n    <artifactId>mockito-all</artifactId>\n    <version>2.0.2-beta</version>\n</dependency>\n\n```\n\n\n[个人demo参考](https://github.com/onaple/JunitAndMock)","slug":"代码覆盖率","published":1,"updated":"2017-08-13T10:22:32.000Z","layout":"post","photos":[],"link":"","_id":"cjd4d1a0m001vryx4f1l31ew9","content":"<h2 id=\"JaCoCo\"><a href=\"#JaCoCo\" class=\"headerlink\" title=\"JaCoCo\"></a>JaCoCo</h2><h3 id=\"JaCoCo简述\"><a href=\"#JaCoCo简述\" class=\"headerlink\" title=\"JaCoCo简述\"></a>JaCoCo简述</h3><p>JaCoCo是一个开源的覆盖率工具( 官网地址：<a href=\"http://www.eclemma.org/JaCoCo/\" target=\"_blank\" rel=\"external\">http://www.eclemma.org/JaCoCo/</a> )，它针对的开发语言是java，其使用方法很灵活，可以嵌入到Ant、Maven中；可以作为Eclipse插件，可以使用其JavaAgent技术监控Java程序等等。<br>很多第三方的工具提供了对JaCoCo的集成，如sonar、Jenkins等。</p>\n<h3 id=\"使用姿势\"><a href=\"#使用姿势\" class=\"headerlink\" title=\"使用姿势\"></a>使用姿势</h3><ul>\n<li>在Bulid 的 plungs中加入以下plugn</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div></pre></td><td class=\"code\"><pre><div class=\"line\"> &lt;plugin&gt;</div><div class=\"line\">    &lt;groupId&gt;org.jacoco&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt;</div><div class=\"line\">    &lt;version&gt;0.7.9&lt;/version&gt;</div><div class=\"line\">    &lt;executions&gt;</div><div class=\"line\">        &lt;execution&gt;</div><div class=\"line\">            &lt;id&gt;pre-unit-test&lt;/id&gt;</div><div class=\"line\">            &lt;goals&gt;</div><div class=\"line\">                &lt;goal&gt;prepare-agent&lt;/goal&gt;</div><div class=\"line\">            &lt;/goals&gt;</div><div class=\"line\">            &lt;configuration&gt;</div><div class=\"line\">                &lt;destFile&gt;$&#123;project.build.directory&#125;/coverage-reports/jacoco.exec&lt;/destFile&gt;</div><div class=\"line\">                &lt;propertyName&gt;surefireArgLine&lt;/propertyName&gt;</div><div class=\"line\">            &lt;/configuration&gt;</div><div class=\"line\">        &lt;/execution&gt;</div><div class=\"line\">        &lt;execution&gt;</div><div class=\"line\">            &lt;id&gt;post-unit-test&lt;/id&gt;</div><div class=\"line\">            &lt;phase&gt;test&lt;/phase&gt;</div><div class=\"line\">            &lt;goals&gt;</div><div class=\"line\">                &lt;goal&gt;report&lt;/goal&gt;</div><div class=\"line\">            &lt;/goals&gt;</div><div class=\"line\">            &lt;configuration&gt;</div><div class=\"line\">                &lt;dataFile&gt;$&#123;project.build.directory&#125;/coverage-reports/jacoco.exec&lt;/dataFile&gt;</div><div class=\"line\">                &lt;outputDirectory&gt;$&#123;project.reporting.outputDirectory&#125;/jacoco&lt;/outputDirectory&gt;</div><div class=\"line\">                &lt;--包含要被测试的类--&gt;</div><div class=\"line\">                &lt;includes&gt;</div><div class=\"line\">                    &lt;include&gt;me/ele/**&lt;/include&gt;</div><div class=\"line\">                  </div><div class=\"line\">                &lt;/includes&gt;</div><div class=\"line\">                &lt;--排除要被测试的类--&gt;</div><div class=\"line\">                &lt;excludes&gt;</div><div class=\"line\">                    &lt;exclude&gt;**/*Mock*.class&lt;/exclude&gt;</div><div class=\"line\">                &lt;/excludes&gt;</div><div class=\"line\">            &lt;/configuration&gt;</div><div class=\"line\">        &lt;/execution&gt;</div><div class=\"line\">    &lt;/executions&gt;</div><div class=\"line\">&lt;/plugin&gt;</div><div class=\"line\">&lt;plugin&gt;</div><div class=\"line\">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;</div><div class=\"line\">    &lt;version&gt;2.19.1&lt;/version&gt;</div><div class=\"line\">    &lt;configuration&gt;</div><div class=\"line\">        &lt;argLine&gt;$&#123;surefireArgLine&#125;&lt;/argLine&gt;</div><div class=\"line\">        &lt;skipTests&gt;false&lt;/skipTests&gt;</div><div class=\"line\">        &lt;testFailureIgnore&gt;true&lt;/testFailureIgnore&gt;</div><div class=\"line\">        &lt;--包含测试的类--&gt;</div><div class=\"line\">        &lt;includes&gt;</div><div class=\"line\">            &lt;include&gt;me/ele/**&lt;/include&gt;</div><div class=\"line\">            &lt;include&gt;com/**&lt;/include&gt;</div><div class=\"line\">        &lt;/includes&gt;</div><div class=\"line\">        &lt;--排除测试的类--&gt;</div><div class=\"line\">        &lt;excludes&gt;</div><div class=\"line\">            &lt;exclude&gt;**/Account*Test.java&lt;/exclude&gt;</div><div class=\"line\">        &lt;/excludes&gt;</div><div class=\"line\">    &lt;/configuration&gt;</div><div class=\"line\">&lt;/plugin&gt;</div><div class=\"line\">&lt;plugin&gt;</div><div class=\"line\">    &lt;groupId&gt;me.ele.fin&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;jacoco-console-report&lt;/artifactId&gt;</div><div class=\"line\">    &lt;version&gt;0.0.1-RELEASE&lt;/version&gt;</div><div class=\"line\">    &lt;executions&gt;</div><div class=\"line\">        &lt;execution&gt;</div><div class=\"line\">            &lt;id&gt;console&lt;/id&gt;</div><div class=\"line\">            &lt;phase&gt;prepare-package&lt;/phase&gt;</div><div class=\"line\">            &lt;goals&gt;</div><div class=\"line\">                &lt;goal&gt;console&lt;/goal&gt;</div><div class=\"line\">            &lt;/goals&gt;</div><div class=\"line\">        &lt;/execution&gt;</div><div class=\"line\">    &lt;/executions&gt;</div><div class=\"line\">&lt;/plugin&gt;</div></pre></td></tr></table></figure>\n<ul>\n<li>在pom下加入reporting</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;reporting&gt;</div><div class=\"line\">    &lt;plugins&gt;</div><div class=\"line\">        &lt;plugin&gt;</div><div class=\"line\">            &lt;groupId&gt;org.jacoco&lt;/groupId&gt;</div><div class=\"line\">            &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt;</div><div class=\"line\">            &lt;reportSets&gt;</div><div class=\"line\">                &lt;reportSet&gt;</div><div class=\"line\">                    &lt;reports&gt;</div><div class=\"line\">                        &lt;!-- select non-aggregate reports --&gt;</div><div class=\"line\">                        &lt;report&gt;report&lt;/report&gt;</div><div class=\"line\">                    &lt;/reports&gt;</div><div class=\"line\">                &lt;/reportSet&gt;</div><div class=\"line\">            &lt;/reportSets&gt;</div><div class=\"line\">        &lt;/plugin&gt;</div><div class=\"line\">    &lt;/plugins&gt;</div><div class=\"line\">&lt;/reporting&gt;</div></pre></td></tr></table></figure>\n<ul>\n<li>mvn命令, 生成测试报告文档</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mvn clean package -U -DfailIfNoTests=false -f om.xml -X</div></pre></td></tr></table></figure>\n<h3 id=\"JaCoCo遇到的问题以及解决方式：\"><a href=\"#JaCoCo遇到的问题以及解决方式：\" class=\"headerlink\" title=\"JaCoCo遇到的问题以及解决方式：\"></a>JaCoCo遇到的问题以及解决方式：</h3><ol>\n<li>项目运行时卡住不动了，解决方法，在每个模块下的pom都配置jacoco。</li>\n<li>项目运行报错，类重复加载。<br>产生的原因：test类加载配置文件不同统一，spring配置文件加载了两次造成。<br>另一次是，redis与mysql更换导致运行，运行失败、速度过慢，覆盖率大幅度下降。</li>\n<li><a href=\"https://stackoverflow.com/questions/24115142/intellij-error-when-running-unit-test-could-not-find-or-load-main-class-suref\" target=\"_blank\" rel=\"external\">${surefireArgLine}标红解决方案</a></li>\n</ol>\n<h3 id=\"JaCoCo参考文档\"><a href=\"#JaCoCo参考文档\" class=\"headerlink\" title=\"JaCoCo参考文档\"></a>JaCoCo参考文档</h3><p><a href=\"http://blog.csdn.net/gc_cg/article/details/53172053\" target=\"_blank\" rel=\"external\">参考文档1:jacoco 原理篇</a></p>\n<p><a href=\"http://blog.csdn.net/wangmuming/article/details/28868833\" target=\"_blank\" rel=\"external\">参考文档2: Jacoco覆盖率工具使用之maven篇</a></p>\n<h2 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h2><h3 id=\"单元测试的概述\"><a href=\"#单元测试的概述\" class=\"headerlink\" title=\"单元测试的概述\"></a>单元测试的概述</h3><p>所谓单元测试，是指对软件设计的最小单位，进行正确性检验的测试工作。而检验的方法，一般来说是由开发人员编写一小段测试代码，根据被测目标代码的应用场景，设计拥有合理覆盖度的输入条件，调用执行目标代码，然后判断输出结果是否与预期一致。被测试目标代码一般应具体到类的方法层面上。</p>\n<p>总之，单元测试是一个方法层级上的测试，单元测试也是最细粒度的测试，用于测试一个类的每一个方法都已经满足了方法的功能需求。</p>\n<h3 id=\"一个单元测试用例需要包含什么\"><a href=\"#一个单元测试用例需要包含什么\" class=\"headerlink\" title=\"一个单元测试用例需要包含什么\"></a>一个单元测试用例需要包含什么</h3><ol>\n<li>每个测试有明确的预期结果</li>\n<li>每个测试一个(必须要有)断言,没有断言的case是骗人的case</li>\n<li>如果你发现一个case需要两个断言,那么它们应该是两个case</li>\n<li>为了测试时隔离模块(如下游soa服务,数据库等),使用stubs、mock或fake等测试马甲程序</li>\n<li>有必要的注释，描述unit test case的基本作用</li>\n</ol>\n<h3 id=\"单元测试-unit-test-对象\"><a href=\"#单元测试-unit-test-对象\" class=\"headerlink\" title=\"单元测试(unit test)对象\"></a>单元测试(unit test)对象</h3><ol>\n<li>单元测试关注一个方法或一个类。它应该非常小，最多只有几行代码。</li>\n<li>因为非常小一个单元测试用例应该在几毫秒内运行完成。</li>\n<li>任何用到外部依赖（数据库、WebService、文件系统、I/O）的测试都不是单元测试，而是“集成测试（integration test）”、“综合测试（integrated test）”、验收测试、端到端测试等等</li>\n</ol>\n<h2 id=\"MOCK\"><a href=\"#MOCK\" class=\"headerlink\" title=\"MOCK\"></a>MOCK</h2><h3 id=\"Mockito简介\"><a href=\"#Mockito简介\" class=\"headerlink\" title=\"Mockito简介\"></a>Mockito简介</h3><p>什么是mock？<br>在软件开发的世界之外, “mock”一词是指模仿或者效仿。 因此可以将“mock”理解为一个替身，替代者。在软件开发中提及”mock”，通常理解为模拟对象或者Fake。</p>\n<p>为什么需要Mock?<br>Mock是为了解决units之间由于耦合而难于被测试的问题。所以mock object是unit test的一部分。</p>\n<p><a href=\"http://www.jianshu.com/p/77db26b4fb54\" target=\"_blank\" rel=\"external\">参考链接1:Mockito浅谈</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000006746409\" target=\"_blank\" rel=\"external\">参考链接2:手把手教你 Mockito 的使用</a></p>\n<h3 id=\"maven依赖\"><a href=\"#maven依赖\" class=\"headerlink\" title=\"maven依赖\"></a>maven依赖</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;dependency&gt;</div><div class=\"line\">    &lt;groupId&gt;org.mockito&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;mockito-all&lt;/artifactId&gt;</div><div class=\"line\">    &lt;version&gt;2.0.2-beta&lt;/version&gt;</div><div class=\"line\">&lt;/dependency&gt;</div></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/onaple/JunitAndMock\" target=\"_blank\" rel=\"external\">个人demo参考</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"JaCoCo\"><a href=\"#JaCoCo\" class=\"headerlink\" title=\"JaCoCo\"></a>JaCoCo</h2><h3 id=\"JaCoCo简述\"><a href=\"#JaCoCo简述\" class=\"headerlink\" title=\"JaCoCo简述\"></a>JaCoCo简述</h3><p>JaCoCo是一个开源的覆盖率工具( 官网地址：<a href=\"http://www.eclemma.org/JaCoCo/\" target=\"_blank\" rel=\"external\">http://www.eclemma.org/JaCoCo/</a> )，它针对的开发语言是java，其使用方法很灵活，可以嵌入到Ant、Maven中；可以作为Eclipse插件，可以使用其JavaAgent技术监控Java程序等等。<br>很多第三方的工具提供了对JaCoCo的集成，如sonar、Jenkins等。</p>\n<h3 id=\"使用姿势\"><a href=\"#使用姿势\" class=\"headerlink\" title=\"使用姿势\"></a>使用姿势</h3><ul>\n<li>在Bulid 的 plungs中加入以下plugn</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div></pre></td><td class=\"code\"><pre><div class=\"line\"> &lt;plugin&gt;</div><div class=\"line\">    &lt;groupId&gt;org.jacoco&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt;</div><div class=\"line\">    &lt;version&gt;0.7.9&lt;/version&gt;</div><div class=\"line\">    &lt;executions&gt;</div><div class=\"line\">        &lt;execution&gt;</div><div class=\"line\">            &lt;id&gt;pre-unit-test&lt;/id&gt;</div><div class=\"line\">            &lt;goals&gt;</div><div class=\"line\">                &lt;goal&gt;prepare-agent&lt;/goal&gt;</div><div class=\"line\">            &lt;/goals&gt;</div><div class=\"line\">            &lt;configuration&gt;</div><div class=\"line\">                &lt;destFile&gt;$&#123;project.build.directory&#125;/coverage-reports/jacoco.exec&lt;/destFile&gt;</div><div class=\"line\">                &lt;propertyName&gt;surefireArgLine&lt;/propertyName&gt;</div><div class=\"line\">            &lt;/configuration&gt;</div><div class=\"line\">        &lt;/execution&gt;</div><div class=\"line\">        &lt;execution&gt;</div><div class=\"line\">            &lt;id&gt;post-unit-test&lt;/id&gt;</div><div class=\"line\">            &lt;phase&gt;test&lt;/phase&gt;</div><div class=\"line\">            &lt;goals&gt;</div><div class=\"line\">                &lt;goal&gt;report&lt;/goal&gt;</div><div class=\"line\">            &lt;/goals&gt;</div><div class=\"line\">            &lt;configuration&gt;</div><div class=\"line\">                &lt;dataFile&gt;$&#123;project.build.directory&#125;/coverage-reports/jacoco.exec&lt;/dataFile&gt;</div><div class=\"line\">                &lt;outputDirectory&gt;$&#123;project.reporting.outputDirectory&#125;/jacoco&lt;/outputDirectory&gt;</div><div class=\"line\">                &lt;--包含要被测试的类--&gt;</div><div class=\"line\">                &lt;includes&gt;</div><div class=\"line\">                    &lt;include&gt;me/ele/**&lt;/include&gt;</div><div class=\"line\">                  </div><div class=\"line\">                &lt;/includes&gt;</div><div class=\"line\">                &lt;--排除要被测试的类--&gt;</div><div class=\"line\">                &lt;excludes&gt;</div><div class=\"line\">                    &lt;exclude&gt;**/*Mock*.class&lt;/exclude&gt;</div><div class=\"line\">                &lt;/excludes&gt;</div><div class=\"line\">            &lt;/configuration&gt;</div><div class=\"line\">        &lt;/execution&gt;</div><div class=\"line\">    &lt;/executions&gt;</div><div class=\"line\">&lt;/plugin&gt;</div><div class=\"line\">&lt;plugin&gt;</div><div class=\"line\">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;</div><div class=\"line\">    &lt;version&gt;2.19.1&lt;/version&gt;</div><div class=\"line\">    &lt;configuration&gt;</div><div class=\"line\">        &lt;argLine&gt;$&#123;surefireArgLine&#125;&lt;/argLine&gt;</div><div class=\"line\">        &lt;skipTests&gt;false&lt;/skipTests&gt;</div><div class=\"line\">        &lt;testFailureIgnore&gt;true&lt;/testFailureIgnore&gt;</div><div class=\"line\">        &lt;--包含测试的类--&gt;</div><div class=\"line\">        &lt;includes&gt;</div><div class=\"line\">            &lt;include&gt;me/ele/**&lt;/include&gt;</div><div class=\"line\">            &lt;include&gt;com/**&lt;/include&gt;</div><div class=\"line\">        &lt;/includes&gt;</div><div class=\"line\">        &lt;--排除测试的类--&gt;</div><div class=\"line\">        &lt;excludes&gt;</div><div class=\"line\">            &lt;exclude&gt;**/Account*Test.java&lt;/exclude&gt;</div><div class=\"line\">        &lt;/excludes&gt;</div><div class=\"line\">    &lt;/configuration&gt;</div><div class=\"line\">&lt;/plugin&gt;</div><div class=\"line\">&lt;plugin&gt;</div><div class=\"line\">    &lt;groupId&gt;me.ele.fin&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;jacoco-console-report&lt;/artifactId&gt;</div><div class=\"line\">    &lt;version&gt;0.0.1-RELEASE&lt;/version&gt;</div><div class=\"line\">    &lt;executions&gt;</div><div class=\"line\">        &lt;execution&gt;</div><div class=\"line\">            &lt;id&gt;console&lt;/id&gt;</div><div class=\"line\">            &lt;phase&gt;prepare-package&lt;/phase&gt;</div><div class=\"line\">            &lt;goals&gt;</div><div class=\"line\">                &lt;goal&gt;console&lt;/goal&gt;</div><div class=\"line\">            &lt;/goals&gt;</div><div class=\"line\">        &lt;/execution&gt;</div><div class=\"line\">    &lt;/executions&gt;</div><div class=\"line\">&lt;/plugin&gt;</div></pre></td></tr></table></figure>\n<ul>\n<li>在pom下加入reporting</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;reporting&gt;</div><div class=\"line\">    &lt;plugins&gt;</div><div class=\"line\">        &lt;plugin&gt;</div><div class=\"line\">            &lt;groupId&gt;org.jacoco&lt;/groupId&gt;</div><div class=\"line\">            &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt;</div><div class=\"line\">            &lt;reportSets&gt;</div><div class=\"line\">                &lt;reportSet&gt;</div><div class=\"line\">                    &lt;reports&gt;</div><div class=\"line\">                        &lt;!-- select non-aggregate reports --&gt;</div><div class=\"line\">                        &lt;report&gt;report&lt;/report&gt;</div><div class=\"line\">                    &lt;/reports&gt;</div><div class=\"line\">                &lt;/reportSet&gt;</div><div class=\"line\">            &lt;/reportSets&gt;</div><div class=\"line\">        &lt;/plugin&gt;</div><div class=\"line\">    &lt;/plugins&gt;</div><div class=\"line\">&lt;/reporting&gt;</div></pre></td></tr></table></figure>\n<ul>\n<li>mvn命令, 生成测试报告文档</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mvn clean package -U -DfailIfNoTests=false -f om.xml -X</div></pre></td></tr></table></figure>\n<h3 id=\"JaCoCo遇到的问题以及解决方式：\"><a href=\"#JaCoCo遇到的问题以及解决方式：\" class=\"headerlink\" title=\"JaCoCo遇到的问题以及解决方式：\"></a>JaCoCo遇到的问题以及解决方式：</h3><ol>\n<li>项目运行时卡住不动了，解决方法，在每个模块下的pom都配置jacoco。</li>\n<li>项目运行报错，类重复加载。<br>产生的原因：test类加载配置文件不同统一，spring配置文件加载了两次造成。<br>另一次是，redis与mysql更换导致运行，运行失败、速度过慢，覆盖率大幅度下降。</li>\n<li><a href=\"https://stackoverflow.com/questions/24115142/intellij-error-when-running-unit-test-could-not-find-or-load-main-class-suref\" target=\"_blank\" rel=\"external\">${surefireArgLine}标红解决方案</a></li>\n</ol>\n<h3 id=\"JaCoCo参考文档\"><a href=\"#JaCoCo参考文档\" class=\"headerlink\" title=\"JaCoCo参考文档\"></a>JaCoCo参考文档</h3><p><a href=\"http://blog.csdn.net/gc_cg/article/details/53172053\" target=\"_blank\" rel=\"external\">参考文档1:jacoco 原理篇</a></p>\n<p><a href=\"http://blog.csdn.net/wangmuming/article/details/28868833\" target=\"_blank\" rel=\"external\">参考文档2: Jacoco覆盖率工具使用之maven篇</a></p>\n<h2 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h2><h3 id=\"单元测试的概述\"><a href=\"#单元测试的概述\" class=\"headerlink\" title=\"单元测试的概述\"></a>单元测试的概述</h3><p>所谓单元测试，是指对软件设计的最小单位，进行正确性检验的测试工作。而检验的方法，一般来说是由开发人员编写一小段测试代码，根据被测目标代码的应用场景，设计拥有合理覆盖度的输入条件，调用执行目标代码，然后判断输出结果是否与预期一致。被测试目标代码一般应具体到类的方法层面上。</p>\n<p>总之，单元测试是一个方法层级上的测试，单元测试也是最细粒度的测试，用于测试一个类的每一个方法都已经满足了方法的功能需求。</p>\n<h3 id=\"一个单元测试用例需要包含什么\"><a href=\"#一个单元测试用例需要包含什么\" class=\"headerlink\" title=\"一个单元测试用例需要包含什么\"></a>一个单元测试用例需要包含什么</h3><ol>\n<li>每个测试有明确的预期结果</li>\n<li>每个测试一个(必须要有)断言,没有断言的case是骗人的case</li>\n<li>如果你发现一个case需要两个断言,那么它们应该是两个case</li>\n<li>为了测试时隔离模块(如下游soa服务,数据库等),使用stubs、mock或fake等测试马甲程序</li>\n<li>有必要的注释，描述unit test case的基本作用</li>\n</ol>\n<h3 id=\"单元测试-unit-test-对象\"><a href=\"#单元测试-unit-test-对象\" class=\"headerlink\" title=\"单元测试(unit test)对象\"></a>单元测试(unit test)对象</h3><ol>\n<li>单元测试关注一个方法或一个类。它应该非常小，最多只有几行代码。</li>\n<li>因为非常小一个单元测试用例应该在几毫秒内运行完成。</li>\n<li>任何用到外部依赖（数据库、WebService、文件系统、I/O）的测试都不是单元测试，而是“集成测试（integration test）”、“综合测试（integrated test）”、验收测试、端到端测试等等</li>\n</ol>\n<h2 id=\"MOCK\"><a href=\"#MOCK\" class=\"headerlink\" title=\"MOCK\"></a>MOCK</h2><h3 id=\"Mockito简介\"><a href=\"#Mockito简介\" class=\"headerlink\" title=\"Mockito简介\"></a>Mockito简介</h3><p>什么是mock？<br>在软件开发的世界之外, “mock”一词是指模仿或者效仿。 因此可以将“mock”理解为一个替身，替代者。在软件开发中提及”mock”，通常理解为模拟对象或者Fake。</p>\n<p>为什么需要Mock?<br>Mock是为了解决units之间由于耦合而难于被测试的问题。所以mock object是unit test的一部分。</p>\n<p><a href=\"http://www.jianshu.com/p/77db26b4fb54\" target=\"_blank\" rel=\"external\">参考链接1:Mockito浅谈</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000006746409\" target=\"_blank\" rel=\"external\">参考链接2:手把手教你 Mockito 的使用</a></p>\n<h3 id=\"maven依赖\"><a href=\"#maven依赖\" class=\"headerlink\" title=\"maven依赖\"></a>maven依赖</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;dependency&gt;</div><div class=\"line\">    &lt;groupId&gt;org.mockito&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;mockito-all&lt;/artifactId&gt;</div><div class=\"line\">    &lt;version&gt;2.0.2-beta&lt;/version&gt;</div><div class=\"line\">&lt;/dependency&gt;</div></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/onaple/JunitAndMock\" target=\"_blank\" rel=\"external\">个人demo参考</a></p>\n"},{"title":"x86系统编译原理","comments":1,"date":"2017-03-05T11:29:07.000Z","update":"2017-03-05T11:29:07.000Z","_content":"\n# 编译过程简述\n## 编译：\n\r### 预处理\n主要处理源文件中以“#”开头的预编译指令，例如#include，#define，#ifdef，#pragma等。\r### 编译\n通过词法分析（生成一系列记号），语法分析（根据一系列记号生成语法树），语义分析（对语法树每一部分做有效性检查），优化后生成汇编代码。\r### 汇编\n产生机器指令。\n\r### ELF文件（这里指.o文件）中包含什么？\n\n>1. 文件头\r2. 段表：包含了段的基本属性，例如每个段的段名，段的长度，在文件中的偏移，读写权限等。\r3. 重定位表：链接器在处理目标文件时，需要对文件的某些部分进行重定位。这些重定位信息就保存在重定位表里。\r4. 字符串表\r5. 符号表：每个目标文件中都会有一个符号表，记录了目标文件中用到的所有符号。每个符号有一个符号值，对于变量和函数而言，符号值就是它们的地址（我理解的是在文件中的相对偏移量，因为符号的虚拟地址是在链接后才重定位的，那么地址也只能是在文件中的地址。不知道对不对）。分别有全局符号，段名，局部符号。符号表往往是一个段，叫作.symtab。\r\r### 链接步骤（俗称两步链接）\r1. 空间与地址分配，扫描所有的输入目标文件，并确定它们各个段的长度，属性和位置，并将输入目标文件符号表中的所有符号定义和符号引用收集起来，统一放到一个全局符号表。链接器获得所有输入目标文件的段长度，并将它们合并，计算出文件中各个段合并后的长度与位置，并建立映射关系（也就是说，已经分配了虚拟地址空间）。\r2. 符号解析与重定位。因为每个符号相对于所在段的偏移是确定的。而且，每个段虚拟地址已经分配，所以，只需将段起始地址加偏移量就可以得到符号的虚拟地址。也就实现了重定位。\r\r###动态链接：解决的问题：\r1.空间浪费\r2.程序更新，部署，发布困难。\n\n# 编译器\n将程序语言的代码转化为其他形式的软件。这个转换过程叫做编译。Eg:c->(gcc)\r\t\nLinux可执行的文件通常指符合（ELF）Executable and Linking Format)这种特定形式的文件。ls 、cp 这些命令对应的实体文件都是可执行文件，使用file命令能查看文件是否符合ELF形式。ELF文件包含了程序以及如何运行程序的相关信息（元数据），机器语言是唯一一种cpu能够直接执行的语言，这里的程序或代码就是指机器语言的列表。\n\r## gcc\ngcc 是将C语言的程序转化为机器语言描述的程序，将机器语言的程序按照ELF这种特定文件格式注入 文件，得到的就是可执行文件。由hello.c这样单个文件来生成可执行文件的过程如下：预处理（.i）侠义的编译(.s)—>汇编(.o)->链接(.exe)。这个过程统称为build.\r\r1. 预处理：由编译器对#include和#define进行处理。具体 来说，读入头文件，将所有的宏展开。预处理的内容近似于sed命令和awk命令这样纯文本的操作。\r\r2. 狭义的编译：编译器对预处理器的输出进行编译，生成汇编语言（.s）。\r\r3. 汇编：汇编器将汇编语言的代码转换为机器语言。汇编器的输出文件为目标文件（.o）。linux下目标文件也是ELF文件；目标文件和可执行文件是通过ELF文件中用于提取文件种类的标志。File 命令来查看。\n\r4. 链接：目标文件本身还不能直接使用，无论是直接运行还是作为程序库文件使用都不可以。将目标文件转换为最终可以使用的形式的处理称为链接。使用程序库的情况下，在这个阶段处理程序的加载。通过链接生成的并不一定是可执行文件，也可以是程序库文件。\r\r\r# 程序运行的全过程：\n代码的build->ELF->运行加载链接->进程—>结束\n\r运行环境：链接的话题并非仅出现在build过程。如果使用了共享库，那么在开始运行程序时链接才会发生。动态加载就是一种将所有链接处理放到程序于运行时进行的。\n\r编程语言的运行方式:编译器会对程序进行编译，将其转换为可执行的文件（c/c++）；解释器不将程序转换为别的语言，而直接运行（python）；运行程序的方式不止一种，C语言也可以用解释器来运行，编程语言可以和运行方式自由搭配；编译器、解释器都统称为编程语言的处理器。 \t根据语言的特点：有静态类型检查，要求较高可靠性的情况下用编译方式；没有静态类型检查，对灵活性要求高于严密性的情况下，则使用解释方式。\t静态类检查是指在程序开始运行之前，对函数的返回值以及参数进行检查的功能；在程序运行过程中随时进行类型检查的为动态类型检查。 静态指不运行程序而进行的处理；动态指一边运行程序一边进行某些处理。\r\r狭义的编译过程:语法分析>语义分析>生成中间代码>代码生成。\n\r语法分析 :首先对代码进行解析，将其转化为计算机易于理解的形式，也就是语法树的形式。解析代码的程序模块称为解析器或者语法分析器\r\r语义分析：通过解析语法获得语法树后，接着就要解析语法树，除去多余的内容、添加必要的信息；生成抽象的语法树。\n\r语义分析包括：\n\r1.\t区分变量为局部变量还是全局变量\r2.\t解析变量的声明和引用。\r3.\t变量和表达式的类型检查\r4.\t检查引用变量之前是否进行了初始化。\r5.\t检查函数是否按照定义返回了结果\r\r语法分析只是对代码的表象进行分析；语义分析是对表象之外的部分级进行分析。语法分析生成的语法树只是将代码的构造照搬过来。而语义分析生成的抽象语法树还包含了语义信息。比如，在变量的引用和定义之间添加链接；适当的增加类型转换命令，是表达式的类型一致；另外语法树中的表达式外侧的括号行末的分号在抽象的语法树都将被省略。\r\r生成中间代码：将抽象语法树转化为只在编译器内部使用的中间代码；之所以特地的转化为中间代码，主要是为了支持多种编程语言或机器语言；\n\ngcc 使用一种名为RTL(Register Transfer Language)的中间代码。解析代码转化为中间代码为止称为编译器的前端。\r\t代码生成：吧中间代码转换为汇编语言，这个阶段为代码生成；负责代码生成的程序模块为代码生成器。\r\t优化：各个环节都可执行优化\r\r# 语法分析：\r## 词法分析\n\r1. 词法分析就是将代码分割为一个个的单词，也可以称为扫描。\r1.\t在该过程中，会将空白字符和注释这种对程序没有实际意义的部分剔除。\r1.\t正是因为预先有了词法分析，语法分析才可以只处理有意义的单词，进而实现简化处理。\r1.\t负责词法分析的模块称为词法分析器，又称为扫描器。\r1.\tToken：在编程语言系统中，将一个单词的字面和他的种类以及语义值统称为token。词法解析器的作用就是解析代码并生成token序列。\r\r1.\t编程语言的编译器中的解析器的主要作用是解析有扫描器生成的token序列，并生成代码所对应的树形结构，即语法树。\r1.\t语法树和语法是完全对应的，所以c语言的分号以及表达式的括号等都包含在真实的语法树中，但是，没有意义，因此，实际上大部分情况下会生成一开始就省略分号和括号的抽象语法树。也就是说解析器会跳过语法树，直接生成抽象语法树。\r\r理想情况是将词法分析、语法分析、语义分析这三个阶段做成3个独立的模块，这样的代码是最优美的。但实际上，这三个阶段并不能明确的分割开来。\r\r语法分析的两层含义：一、语法分析中词法分析以外的部分才称为语法分析。二、词法分析和语法分析合起来称为语法分析。\n\r## 语法分析\r定义的分析\r语句的分析\r表达式的分析\r项的分析\n\r##\t语义分析\r变量引用的消解\r类型名称的消解\r类型定义的检查\r表达式有效性的检查\r静态类型的检查 \r\r# 计算机内部结构\n\r计算机的中心是总线（bus）。总线是传送数据的通信干线，它连接了计算机中的各个设备，使之通信，就像人类的血管或者神经系统。\n\r1.\tCPU是负责运算的设备。\r - CPU内部有寄存器，寄存器大小有32位或64位，在cpu计算时，寄存器被用于临时存放数据。通常cpu先将数据从存储器读入寄存器，然后以寄存器为对象进行计算，再将结果写回存储器。\r将数据从存储器读入寄存器的操作称为加载\r将数据从寄存器写回存储器的操作称为写回\r\r2.\t存储器是存储二进制数据的设备。\r3.\t进程所使用的地址称为虚拟地址。\r - \t物理存储器的实际地址称为物理地址。\r - \t虚拟地址的整体范围称为程序的地址空间。\r - \t进程使用虚拟地址访问存储器，cpu内部称为MMU的设备会访问地址转换表进行地址转换。\r4.\tCPU\r -\t386是x86系列的第一款32位cpu.\r -\tPentinum 4是intel的x86系列第一款64位cpu。\r -\t满足1.具备n位宽的通用寄存器 2.具备n位以上的地址空间。 才真正被称为n位cpu。\r -\t32位的cpu的通用寄存器的大小为32位，和指针大小相同，地址空间为无符号的32位整数可以指向的范围。64位一样。\r -\tX86系列的CPU只要使用PAE(physical address extension)这样的机制，32位的CPU也可以操作36位范围的地址空间\r5.\t指令集\r不同的CPU都能够解释的机器语言体系称为指令集架构（ISA， instruction set architecture）,也可以简称指令集。\rIntel 将x86系列CPU之中的32位CPU的指令集架构称为IA—32.IA(iIntel Architecture).\r\r\r\r\r\f\r# ELF文件的结构\n\rLinux使用ELF作为目标文件的格式。ELF格式被用于描述目标文件、可执行文件以及共享库的所有信息。\r无论什么场合，使用ELF格式的目的只有一个，那就是把机器代码以及其对应的元数据以方便的链接器和加载器处理的形式保存起来。\r代码的元数据包含如下的信息：\n\r1.\t代码文件的大小以及转换前的源代码文件名。\r2.\t符号\r符号指的是变量或者函数的名称。简单的情况下直接使用原编程语言中的函数名或者变量名即可。有时候也会根据不同的编程语言进行特定的变换后得到的符号名称。这种变换称为名称重整。比如c++里的重载。\r3.\t重定位信息\r重定位信息用于表示在链接完成前无法确定内存地址的代码位置信息。比如，在共享库内的函数，那么在最终链接完成后才能确定的其内存地址。在这种情况下，目标文件中就会留有“代码中这个位置的内存引用尚未确定”这样的信息。\r这样的信息就是重定向信息。\r4.\t调试信息\r\r\r## ELF的节和段\rELF文件结构的二元结构。目的：为了兼顾链接器、汇编器等编译工具以及程序加载到内存中的加载器两者的易用性的需求。\r\r二元结构:如果以程序头信息来处理，则ELF文件可以解释为段集合。如果以节头信息来处理，则可以解释成节集合。\n\n|节|\n|---|\r| ELF头 |\r|程序头（描述段）|\r|.text节 |\r|.rodata节 |\r|.data节 |\r|.got节 |\r|.symtab节 |\r|.strtab节 |\r|节头（描述节）|\r\r节（section）：是汇编器、链接器等处理ELF文件内容的单位。ELF文件把不同目的的代码、数据等分割成节保存。比如，机器码统一保存到.text节中。全局变量的初始化数据则保存在.data节中。\n\r段（segment）：则是把程序加载到内存的加载器处理ELF文件时的单位。段由1个以上的字节构成。内存上不同范围有着“只读”、“可写”、“可执行”等不同的属性。因而需要根据属性进行分段。比如机器码如果不可执行就毫无意义，因此要统一到具有可执行属性段中。\r\r\r目标文件的主要节\n\r| 节名 | 内容 |\n|---|:---|\n|.text节 | 机器码。配置机器码的节，虽然叫text，但和文本文件没有关系。|\r|.rodata节 | 读专用的.data。配置的字符串字面量等不能更新的数据 |\r| .data节 | 全局变量等。在文件中无大小信息。配置的是拥有初始值的全局变量等，这个节的数据在加载后有可能发生变更。|\r| .bss | 通用符号等。在文件中无大小信息。配置的是没有初始值的全局变量，并且加载到内存后，会被分配所有字节都初始化为0的内存空间。BSS是（Block Started by Symbol）。|\r|.rel.text节 | .text段中的符号的重定位信息 |\r|.symtab节 | 文件中包含的符号表。实际的字面量在.strtab节中保存 |\r|.strtab节 | 符号等字符串列表 |\r|.shstrtab | 节名字符串列表 |\r|.line | 代码和原始代码行号对照 |\r|.debug | 调试用的符号信息 |\n|.fini | 进程结束前执行的代码 |\n|.fini_array | 进程结束前执行的函数的指针数组|\n|.init | 目标文件加载时执行的代码 |\r|.init_array | 目标文件加载时执行的函数的指针数组 |\r|.note | 用于保障兼容性等 |\r\r\r\rLinux下的 binutils包中包含readelf命令可以输出elf文件的结构。\n\n```\r1．\treadelf –S hello #输出hello的节头信息。\r2．\treadelf –l hello #查看hello的程序头。\r3．\treadelf –s hello #输出符号表。\r```\r\r\rgcc\r\tgcc – c main.c //在编译后中断build.\r\t-o 指定输出文件名。\r\t-v 详细输出其内部处理过程\r\rLinux下负责链接的程序是/usr/bin/ld，这个程序称为GNU ld,一般称为链接器。\r## 链接器可处理的文件：\r| 文件类型 | 格式 | 后缀名 | 生成器 |\n|---------|:----:|:----:|:----|\r| 可重定位文件 | ELF | .o | 汇编器|\r| 可执行文件 | ELF | 无 | 链接器 |\r| 共享库 | ELF | .so |  链接器 |\r| 静态库 |  UNIX ar | .a | ar命令|\n\r可重定位文件指汇编器生成的目标文件(.o)。GNU as 生成的可重定位文件没有程序头，因此不能直接运行，只有配合链接器与其他可重定位文件、库产生连接后才可执行。\n\r可执行文件指的是链接生成的用户可直接运行的目标文件。Linux下可执行文件没有后缀名\r\t\n共享库是链接生成的另一种形式的目标文件，其中集合了各个函数、变量等供用户调用，因此需要能够再次和其他目标文件链接使用。共享库不会直接运行。共享库也叫动态链接库。Linux下的共享库文件名一般以lib开头，以.so作为后缀，并加上版本号。\r\r静态库文件可以作为链接器的输入。和共享库文件一样，静态库文件也集合了各种函数、变量供其它用户使用。一般以lib开头，以.a作为后缀。静态库文件利用ar命令把多个可重定位文件打包成一个，因此链接静态库文件就相当于链接其中打包的所有可重定位文件。\r\r\r# 什么是链接\r\r链接指的是把多个目标文件关联为一个整体。而通过关联多个目标文件，就可生成同时使用多个目标文件定义的变量、函数的程序。\r\t\n具体步骤：\n\n1. 合并节\n2. 重定位 \n3. 符号相消\n\n此外，链接时还必须进行很多其他的处理。比如，在生成ELF文件时，需要为程序生成合适的程序头信息。不过归根到底，链接的主旨是关联目标文件，因此主要处理也就是上述三点。\r\t\r## 合并节：\n在链接多个目标文件时，需要从各个目标文件中抽取节，把相同种类的节合并到一起。\r\t\n## 重定位：\n指根据程序实际加载到内存时的地址，对目标文件中的代码和数据进行调整。\r在链接文件时，根据整体情况决定“真实的”内存地址，把所有用虚拟内存地址的地方替换成真实的内存地址。这个处理就是重定位。\r\t\n## 符号相消\n\n指为了可以使用其他目标文件和库文件中提供的变量和函数，把尚未和实体链接的符号与具体的变量和函数等实体链接起来的操作。例如：mian.c中有printf函数，汇编器会把“这个目标文件中使用的printf函数的函数体在其他文件中”这个信息保留下来。这个信息就是未定义的符号。接下来，再进行链接操作的时候，再检索未定义的符号，把相关的变量或者函数的内存地址链接进来。这个处理就是符号消解。\r\t\r符号相消和重定位联系紧密，比如上面的printf函数，编译mian.c时printf函数的地址是未知的，这时编译器为printf函数分配虚拟地址，并生成类似call printf的汇编指令，然后在链接时再把函数的内存地址修正为正确的地址。而这个“先设置虚拟地址，在链接时修正为正确的地址”的处理正是重定位操作，因此符号消解本身可以通过重定位来实现。\r总体来说，像上面这样解释目标文件代码的含义，把目标文件从物理上、逻辑上连接起来，从而生成可执行文件的处理就是“链接”。\r\r\r## 动态链接和静态链接\r静态库在build，也就是执行ld命令的时候就会进行目标文件的链接，\r 而共享库在build的时候不会进行目标文件的链接，而只是检查共享库和符号是否存在，在程序运行时才在内存上实际链接目标文件。\r\t其中，在build时链接目标文件的的链接操作称为静态链接。\r\t而在程序执行时链接目标文件的链接操作则称为动态链接。\r\t给链接器输入多个重定位文件时，这些文件被执行静态链接。\r\t动态链接有容易更新、节省磁盘空间、节省内存的优点。Linux下也主要使用共享库和动态链接。gcc也是如此，不加任何选项的话执行的动态链接，而静态库的静态链接只在个别情况下使用。缺点：性能稍差、链接具有不确定性。\r\r```\nEg:\r动态链接：\rgcc –c main.c\rgcc –c f.c\rgcc main.o f.o –lc –o prog\r-l选项可以为链接指定库\rLdd prog  //查看是否被动态链接。\r\r静态链接：\rgcc –static main.o f.o –lc –o prog\rfile prog\r\r生成库\r\r生成静态库\r用ar生成静态库，和tar命令差不多\reg：$ ar crs libmy.a f.o g.o h.o\r选项\r含义\rc\r如果存档不存在，则创建\rr\r向存档添加文件\rS\r生成加速链接的索引\r\rLinux下优化执行时共享库的检索速度，加载器会对共享库的信息建立缓存文件。这个缓存文件就是 /etc/ld.so.cache。安装新版本的共享库时，一定要更新这个缓存文件，更新缓存文件的需要以管理员的权限运行ldconfig命令。\n\rgcc –c –fPIC f.c\rgcc –c –fPIC g.c\rgcc –share –WL, -soname, libfg.so.1 f.o g.o –o libfg.so.1\rfile libfg.so.1\r\r```\r\r\f\r# 加载程序\r利用mmap系统调用进行文件映射，把程序加载到内存中。所谓的映射，意思是可以通过读取内存直接获得文件的内容，也可以通过写内存对文件的内容进行修改\r\r在linux下，通过使用Proc文件系统，就可以表示进程利用mmap系统调用把文件映射到内存的范围信息。例如，利用cat /proc/44337/maps就可以表示44437进程中文件映射的信息。通过readelf –l /tmp/showmap 可以输出程序头。里面有elf段和内存空间的对应关系。\rELF文件中拥有实体的段都是通过mmap系统调用来加载的。不过进程的内存空间中也存在不和ELF文件对应的部分，比如，和.bss等节对应的空间、机器栈、堆。\r\r\r## 动态链接的过程\r目标文件的种类不同，加载ELF文件的主体也不同。程序由系统内核加载，共享库由动态链接加载器加载。\n\r动态链接加载器是指加载并链接动态链接的程序本身及其链接的共享库，设置程序运行状态的程序。Linux下常用的动态链接加载器是/lib/ld-linux.so.2。动态链接加载器的统称为ld.so。使用ELF文件的系统中，程序ELF文件的INTERP段需要指定动态链接加载器的路径。系统内核在启动程序时读入此段的内容，从而加载，启动程序。换句话说，动态链接器和动态链接加载器的运作过程并无二致。\r从ld.so链接程序到程序的执行完毕过程。\r\r>1.\t加载程序\r2.\t启动ld.so\r3.\t读入共享库\r4.\t符号相消和重定位\r5.\t初始化\r6.\t跳转到程序入口\r7.\t程序终止处理\r\r首先系统内核加载程序和ld.so，准备好运行环境后交由ld.so处理。完成启动的ld.so根据系统内核传递的参数进行初始化。接着读取程序的DYNAMIC段，加载所有可执行文件链接的共享库。对已经加载的共享库也执行同样的处理，递归加载所有的共享库。一旦加载完所需要的库，马上消解所有程序和代码库中的符号，并重定位代码。这样就完成了启动程序的准备工作。在执行了各个文件的初始化代码后，跳转到程序的入口，这样就启动了程序。在C语言程序中，也就是执行了main函数的意思。程序执行完毕后，最后会对每个文件执行终止处理，这样整个执行过程最终完成。 \r\r反汇编指的是从机器码恢复到汇编代码的过程。Linux上使用binutils包的objdump命令就可以反汇编一个程序，eg: objdump –d hello\r\t\nC语言中设定程序是从main函数开始执行，但实际上程序最初是从_start函数开始执行的。_start函数由lib提供的/usr/lib/crtl.o文件定义，ctrl.o在这个文件在编译时是默认链接的。_start函数会初始化libc，之后调用mian函数。\r\r执行终止处理，接下来从main函数返回，接着ld.so会执行终止处理代码。用于初始化的有.init节和.init_array节，相应的，终止处理有.fini节和.fini_array节。.fini节保存进程终止时的代码，而.fini_array则保存进程终止时执行的函数指针列表。程序执行完后，ld.so会调用exit系统调用终止进程。Exit系统调用和平时使用的exit函数不同。C语言调用exit系统调用时，调用的是_exit函数。_exit函数执行libc的终止处理代码（.fini节和.fini_array节）后，执行exit系统调用结束进程。而exit系统调用会跳过终止处理，立即结束进程。这就是ld.so所有处理过程。\r\r\r\r动态加载指的是在程序运行时指定共享库名称进行加载的方法。动态加载经常被用于实现所谓的插件。Linux中使用dlopen()函数进行动态加载。动态链接的程序最初一定已经加载了ld.so。而程序启动后它依然保存在内存上。因此只需要调用内存中的ld.so的代码，就可以在程序开始执行之后也能进行动态链接处理。\r\r地址无关代码指的是无论加载到那个地址，都不需要重定位也能运行的代码。共享库的代码一定要是地址无关的代码，这一点很重要共享库一定要设置为地址无关代码，是为了实现库共享。要实现地址无关的代码，必须改变两点：一是全局变量的访问，二是 外部函数的调用。\r\r访问全局变量的代码一定要把绝对地址改为相对地址。可以使用全局偏移表（GOT）的结构。GOT是指向全局变量的指针数组，链接器为其申请内存空间，动态链接加载器初始化其内容。地址无关代码就是通过 从这个GOT中读取地址而做到地址无关的。\r\r外部函数如何调用地址无关的代码。Linux下为了使函数调用地址独立，使用了一种可以称之为GOT的函数版的方法—过程链接表（PLT）。不过PLT一般比GOT的入口数多，因此会采取延迟初始化。也就是说，外部函数第一次调用该函数时，该函数才会被链接。\r\r地址无关的可执行文件（PIE）。指的是使用地址无关代码的可执行文件。因为地址无关，所以可以被加载到任意地址。 \r","source":"_posts/x86系统编译原理.md","raw":"---\ntitle: x86系统编译原理\ncomments: true\ntags:\n  - X86\n  - LINUX\n  - 编译原理\ncategories:\n  - LINUX\ndate: 2017-03-05 19:29:07\nupdate: 2017-03-05 19:29:07\n---\n\n# 编译过程简述\n## 编译：\n\r### 预处理\n主要处理源文件中以“#”开头的预编译指令，例如#include，#define，#ifdef，#pragma等。\r### 编译\n通过词法分析（生成一系列记号），语法分析（根据一系列记号生成语法树），语义分析（对语法树每一部分做有效性检查），优化后生成汇编代码。\r### 汇编\n产生机器指令。\n\r### ELF文件（这里指.o文件）中包含什么？\n\n>1. 文件头\r2. 段表：包含了段的基本属性，例如每个段的段名，段的长度，在文件中的偏移，读写权限等。\r3. 重定位表：链接器在处理目标文件时，需要对文件的某些部分进行重定位。这些重定位信息就保存在重定位表里。\r4. 字符串表\r5. 符号表：每个目标文件中都会有一个符号表，记录了目标文件中用到的所有符号。每个符号有一个符号值，对于变量和函数而言，符号值就是它们的地址（我理解的是在文件中的相对偏移量，因为符号的虚拟地址是在链接后才重定位的，那么地址也只能是在文件中的地址。不知道对不对）。分别有全局符号，段名，局部符号。符号表往往是一个段，叫作.symtab。\r\r### 链接步骤（俗称两步链接）\r1. 空间与地址分配，扫描所有的输入目标文件，并确定它们各个段的长度，属性和位置，并将输入目标文件符号表中的所有符号定义和符号引用收集起来，统一放到一个全局符号表。链接器获得所有输入目标文件的段长度，并将它们合并，计算出文件中各个段合并后的长度与位置，并建立映射关系（也就是说，已经分配了虚拟地址空间）。\r2. 符号解析与重定位。因为每个符号相对于所在段的偏移是确定的。而且，每个段虚拟地址已经分配，所以，只需将段起始地址加偏移量就可以得到符号的虚拟地址。也就实现了重定位。\r\r###动态链接：解决的问题：\r1.空间浪费\r2.程序更新，部署，发布困难。\n\n# 编译器\n将程序语言的代码转化为其他形式的软件。这个转换过程叫做编译。Eg:c->(gcc)\r\t\nLinux可执行的文件通常指符合（ELF）Executable and Linking Format)这种特定形式的文件。ls 、cp 这些命令对应的实体文件都是可执行文件，使用file命令能查看文件是否符合ELF形式。ELF文件包含了程序以及如何运行程序的相关信息（元数据），机器语言是唯一一种cpu能够直接执行的语言，这里的程序或代码就是指机器语言的列表。\n\r## gcc\ngcc 是将C语言的程序转化为机器语言描述的程序，将机器语言的程序按照ELF这种特定文件格式注入 文件，得到的就是可执行文件。由hello.c这样单个文件来生成可执行文件的过程如下：预处理（.i）侠义的编译(.s)—>汇编(.o)->链接(.exe)。这个过程统称为build.\r\r1. 预处理：由编译器对#include和#define进行处理。具体 来说，读入头文件，将所有的宏展开。预处理的内容近似于sed命令和awk命令这样纯文本的操作。\r\r2. 狭义的编译：编译器对预处理器的输出进行编译，生成汇编语言（.s）。\r\r3. 汇编：汇编器将汇编语言的代码转换为机器语言。汇编器的输出文件为目标文件（.o）。linux下目标文件也是ELF文件；目标文件和可执行文件是通过ELF文件中用于提取文件种类的标志。File 命令来查看。\n\r4. 链接：目标文件本身还不能直接使用，无论是直接运行还是作为程序库文件使用都不可以。将目标文件转换为最终可以使用的形式的处理称为链接。使用程序库的情况下，在这个阶段处理程序的加载。通过链接生成的并不一定是可执行文件，也可以是程序库文件。\r\r\r# 程序运行的全过程：\n代码的build->ELF->运行加载链接->进程—>结束\n\r运行环境：链接的话题并非仅出现在build过程。如果使用了共享库，那么在开始运行程序时链接才会发生。动态加载就是一种将所有链接处理放到程序于运行时进行的。\n\r编程语言的运行方式:编译器会对程序进行编译，将其转换为可执行的文件（c/c++）；解释器不将程序转换为别的语言，而直接运行（python）；运行程序的方式不止一种，C语言也可以用解释器来运行，编程语言可以和运行方式自由搭配；编译器、解释器都统称为编程语言的处理器。 \t根据语言的特点：有静态类型检查，要求较高可靠性的情况下用编译方式；没有静态类型检查，对灵活性要求高于严密性的情况下，则使用解释方式。\t静态类检查是指在程序开始运行之前，对函数的返回值以及参数进行检查的功能；在程序运行过程中随时进行类型检查的为动态类型检查。 静态指不运行程序而进行的处理；动态指一边运行程序一边进行某些处理。\r\r狭义的编译过程:语法分析>语义分析>生成中间代码>代码生成。\n\r语法分析 :首先对代码进行解析，将其转化为计算机易于理解的形式，也就是语法树的形式。解析代码的程序模块称为解析器或者语法分析器\r\r语义分析：通过解析语法获得语法树后，接着就要解析语法树，除去多余的内容、添加必要的信息；生成抽象的语法树。\n\r语义分析包括：\n\r1.\t区分变量为局部变量还是全局变量\r2.\t解析变量的声明和引用。\r3.\t变量和表达式的类型检查\r4.\t检查引用变量之前是否进行了初始化。\r5.\t检查函数是否按照定义返回了结果\r\r语法分析只是对代码的表象进行分析；语义分析是对表象之外的部分级进行分析。语法分析生成的语法树只是将代码的构造照搬过来。而语义分析生成的抽象语法树还包含了语义信息。比如，在变量的引用和定义之间添加链接；适当的增加类型转换命令，是表达式的类型一致；另外语法树中的表达式外侧的括号行末的分号在抽象的语法树都将被省略。\r\r生成中间代码：将抽象语法树转化为只在编译器内部使用的中间代码；之所以特地的转化为中间代码，主要是为了支持多种编程语言或机器语言；\n\ngcc 使用一种名为RTL(Register Transfer Language)的中间代码。解析代码转化为中间代码为止称为编译器的前端。\r\t代码生成：吧中间代码转换为汇编语言，这个阶段为代码生成；负责代码生成的程序模块为代码生成器。\r\t优化：各个环节都可执行优化\r\r# 语法分析：\r## 词法分析\n\r1. 词法分析就是将代码分割为一个个的单词，也可以称为扫描。\r1.\t在该过程中，会将空白字符和注释这种对程序没有实际意义的部分剔除。\r1.\t正是因为预先有了词法分析，语法分析才可以只处理有意义的单词，进而实现简化处理。\r1.\t负责词法分析的模块称为词法分析器，又称为扫描器。\r1.\tToken：在编程语言系统中，将一个单词的字面和他的种类以及语义值统称为token。词法解析器的作用就是解析代码并生成token序列。\r\r1.\t编程语言的编译器中的解析器的主要作用是解析有扫描器生成的token序列，并生成代码所对应的树形结构，即语法树。\r1.\t语法树和语法是完全对应的，所以c语言的分号以及表达式的括号等都包含在真实的语法树中，但是，没有意义，因此，实际上大部分情况下会生成一开始就省略分号和括号的抽象语法树。也就是说解析器会跳过语法树，直接生成抽象语法树。\r\r理想情况是将词法分析、语法分析、语义分析这三个阶段做成3个独立的模块，这样的代码是最优美的。但实际上，这三个阶段并不能明确的分割开来。\r\r语法分析的两层含义：一、语法分析中词法分析以外的部分才称为语法分析。二、词法分析和语法分析合起来称为语法分析。\n\r## 语法分析\r定义的分析\r语句的分析\r表达式的分析\r项的分析\n\r##\t语义分析\r变量引用的消解\r类型名称的消解\r类型定义的检查\r表达式有效性的检查\r静态类型的检查 \r\r# 计算机内部结构\n\r计算机的中心是总线（bus）。总线是传送数据的通信干线，它连接了计算机中的各个设备，使之通信，就像人类的血管或者神经系统。\n\r1.\tCPU是负责运算的设备。\r - CPU内部有寄存器，寄存器大小有32位或64位，在cpu计算时，寄存器被用于临时存放数据。通常cpu先将数据从存储器读入寄存器，然后以寄存器为对象进行计算，再将结果写回存储器。\r将数据从存储器读入寄存器的操作称为加载\r将数据从寄存器写回存储器的操作称为写回\r\r2.\t存储器是存储二进制数据的设备。\r3.\t进程所使用的地址称为虚拟地址。\r - \t物理存储器的实际地址称为物理地址。\r - \t虚拟地址的整体范围称为程序的地址空间。\r - \t进程使用虚拟地址访问存储器，cpu内部称为MMU的设备会访问地址转换表进行地址转换。\r4.\tCPU\r -\t386是x86系列的第一款32位cpu.\r -\tPentinum 4是intel的x86系列第一款64位cpu。\r -\t满足1.具备n位宽的通用寄存器 2.具备n位以上的地址空间。 才真正被称为n位cpu。\r -\t32位的cpu的通用寄存器的大小为32位，和指针大小相同，地址空间为无符号的32位整数可以指向的范围。64位一样。\r -\tX86系列的CPU只要使用PAE(physical address extension)这样的机制，32位的CPU也可以操作36位范围的地址空间\r5.\t指令集\r不同的CPU都能够解释的机器语言体系称为指令集架构（ISA， instruction set architecture）,也可以简称指令集。\rIntel 将x86系列CPU之中的32位CPU的指令集架构称为IA—32.IA(iIntel Architecture).\r\r\r\r\r\f\r# ELF文件的结构\n\rLinux使用ELF作为目标文件的格式。ELF格式被用于描述目标文件、可执行文件以及共享库的所有信息。\r无论什么场合，使用ELF格式的目的只有一个，那就是把机器代码以及其对应的元数据以方便的链接器和加载器处理的形式保存起来。\r代码的元数据包含如下的信息：\n\r1.\t代码文件的大小以及转换前的源代码文件名。\r2.\t符号\r符号指的是变量或者函数的名称。简单的情况下直接使用原编程语言中的函数名或者变量名即可。有时候也会根据不同的编程语言进行特定的变换后得到的符号名称。这种变换称为名称重整。比如c++里的重载。\r3.\t重定位信息\r重定位信息用于表示在链接完成前无法确定内存地址的代码位置信息。比如，在共享库内的函数，那么在最终链接完成后才能确定的其内存地址。在这种情况下，目标文件中就会留有“代码中这个位置的内存引用尚未确定”这样的信息。\r这样的信息就是重定向信息。\r4.\t调试信息\r\r\r## ELF的节和段\rELF文件结构的二元结构。目的：为了兼顾链接器、汇编器等编译工具以及程序加载到内存中的加载器两者的易用性的需求。\r\r二元结构:如果以程序头信息来处理，则ELF文件可以解释为段集合。如果以节头信息来处理，则可以解释成节集合。\n\n|节|\n|---|\r| ELF头 |\r|程序头（描述段）|\r|.text节 |\r|.rodata节 |\r|.data节 |\r|.got节 |\r|.symtab节 |\r|.strtab节 |\r|节头（描述节）|\r\r节（section）：是汇编器、链接器等处理ELF文件内容的单位。ELF文件把不同目的的代码、数据等分割成节保存。比如，机器码统一保存到.text节中。全局变量的初始化数据则保存在.data节中。\n\r段（segment）：则是把程序加载到内存的加载器处理ELF文件时的单位。段由1个以上的字节构成。内存上不同范围有着“只读”、“可写”、“可执行”等不同的属性。因而需要根据属性进行分段。比如机器码如果不可执行就毫无意义，因此要统一到具有可执行属性段中。\r\r\r目标文件的主要节\n\r| 节名 | 内容 |\n|---|:---|\n|.text节 | 机器码。配置机器码的节，虽然叫text，但和文本文件没有关系。|\r|.rodata节 | 读专用的.data。配置的字符串字面量等不能更新的数据 |\r| .data节 | 全局变量等。在文件中无大小信息。配置的是拥有初始值的全局变量等，这个节的数据在加载后有可能发生变更。|\r| .bss | 通用符号等。在文件中无大小信息。配置的是没有初始值的全局变量，并且加载到内存后，会被分配所有字节都初始化为0的内存空间。BSS是（Block Started by Symbol）。|\r|.rel.text节 | .text段中的符号的重定位信息 |\r|.symtab节 | 文件中包含的符号表。实际的字面量在.strtab节中保存 |\r|.strtab节 | 符号等字符串列表 |\r|.shstrtab | 节名字符串列表 |\r|.line | 代码和原始代码行号对照 |\r|.debug | 调试用的符号信息 |\n|.fini | 进程结束前执行的代码 |\n|.fini_array | 进程结束前执行的函数的指针数组|\n|.init | 目标文件加载时执行的代码 |\r|.init_array | 目标文件加载时执行的函数的指针数组 |\r|.note | 用于保障兼容性等 |\r\r\r\rLinux下的 binutils包中包含readelf命令可以输出elf文件的结构。\n\n```\r1．\treadelf –S hello #输出hello的节头信息。\r2．\treadelf –l hello #查看hello的程序头。\r3．\treadelf –s hello #输出符号表。\r```\r\r\rgcc\r\tgcc – c main.c //在编译后中断build.\r\t-o 指定输出文件名。\r\t-v 详细输出其内部处理过程\r\rLinux下负责链接的程序是/usr/bin/ld，这个程序称为GNU ld,一般称为链接器。\r## 链接器可处理的文件：\r| 文件类型 | 格式 | 后缀名 | 生成器 |\n|---------|:----:|:----:|:----|\r| 可重定位文件 | ELF | .o | 汇编器|\r| 可执行文件 | ELF | 无 | 链接器 |\r| 共享库 | ELF | .so |  链接器 |\r| 静态库 |  UNIX ar | .a | ar命令|\n\r可重定位文件指汇编器生成的目标文件(.o)。GNU as 生成的可重定位文件没有程序头，因此不能直接运行，只有配合链接器与其他可重定位文件、库产生连接后才可执行。\n\r可执行文件指的是链接生成的用户可直接运行的目标文件。Linux下可执行文件没有后缀名\r\t\n共享库是链接生成的另一种形式的目标文件，其中集合了各个函数、变量等供用户调用，因此需要能够再次和其他目标文件链接使用。共享库不会直接运行。共享库也叫动态链接库。Linux下的共享库文件名一般以lib开头，以.so作为后缀，并加上版本号。\r\r静态库文件可以作为链接器的输入。和共享库文件一样，静态库文件也集合了各种函数、变量供其它用户使用。一般以lib开头，以.a作为后缀。静态库文件利用ar命令把多个可重定位文件打包成一个，因此链接静态库文件就相当于链接其中打包的所有可重定位文件。\r\r\r# 什么是链接\r\r链接指的是把多个目标文件关联为一个整体。而通过关联多个目标文件，就可生成同时使用多个目标文件定义的变量、函数的程序。\r\t\n具体步骤：\n\n1. 合并节\n2. 重定位 \n3. 符号相消\n\n此外，链接时还必须进行很多其他的处理。比如，在生成ELF文件时，需要为程序生成合适的程序头信息。不过归根到底，链接的主旨是关联目标文件，因此主要处理也就是上述三点。\r\t\r## 合并节：\n在链接多个目标文件时，需要从各个目标文件中抽取节，把相同种类的节合并到一起。\r\t\n## 重定位：\n指根据程序实际加载到内存时的地址，对目标文件中的代码和数据进行调整。\r在链接文件时，根据整体情况决定“真实的”内存地址，把所有用虚拟内存地址的地方替换成真实的内存地址。这个处理就是重定位。\r\t\n## 符号相消\n\n指为了可以使用其他目标文件和库文件中提供的变量和函数，把尚未和实体链接的符号与具体的变量和函数等实体链接起来的操作。例如：mian.c中有printf函数，汇编器会把“这个目标文件中使用的printf函数的函数体在其他文件中”这个信息保留下来。这个信息就是未定义的符号。接下来，再进行链接操作的时候，再检索未定义的符号，把相关的变量或者函数的内存地址链接进来。这个处理就是符号消解。\r\t\r符号相消和重定位联系紧密，比如上面的printf函数，编译mian.c时printf函数的地址是未知的，这时编译器为printf函数分配虚拟地址，并生成类似call printf的汇编指令，然后在链接时再把函数的内存地址修正为正确的地址。而这个“先设置虚拟地址，在链接时修正为正确的地址”的处理正是重定位操作，因此符号消解本身可以通过重定位来实现。\r总体来说，像上面这样解释目标文件代码的含义，把目标文件从物理上、逻辑上连接起来，从而生成可执行文件的处理就是“链接”。\r\r\r## 动态链接和静态链接\r静态库在build，也就是执行ld命令的时候就会进行目标文件的链接，\r 而共享库在build的时候不会进行目标文件的链接，而只是检查共享库和符号是否存在，在程序运行时才在内存上实际链接目标文件。\r\t其中，在build时链接目标文件的的链接操作称为静态链接。\r\t而在程序执行时链接目标文件的链接操作则称为动态链接。\r\t给链接器输入多个重定位文件时，这些文件被执行静态链接。\r\t动态链接有容易更新、节省磁盘空间、节省内存的优点。Linux下也主要使用共享库和动态链接。gcc也是如此，不加任何选项的话执行的动态链接，而静态库的静态链接只在个别情况下使用。缺点：性能稍差、链接具有不确定性。\r\r```\nEg:\r动态链接：\rgcc –c main.c\rgcc –c f.c\rgcc main.o f.o –lc –o prog\r-l选项可以为链接指定库\rLdd prog  //查看是否被动态链接。\r\r静态链接：\rgcc –static main.o f.o –lc –o prog\rfile prog\r\r生成库\r\r生成静态库\r用ar生成静态库，和tar命令差不多\reg：$ ar crs libmy.a f.o g.o h.o\r选项\r含义\rc\r如果存档不存在，则创建\rr\r向存档添加文件\rS\r生成加速链接的索引\r\rLinux下优化执行时共享库的检索速度，加载器会对共享库的信息建立缓存文件。这个缓存文件就是 /etc/ld.so.cache。安装新版本的共享库时，一定要更新这个缓存文件，更新缓存文件的需要以管理员的权限运行ldconfig命令。\n\rgcc –c –fPIC f.c\rgcc –c –fPIC g.c\rgcc –share –WL, -soname, libfg.so.1 f.o g.o –o libfg.so.1\rfile libfg.so.1\r\r```\r\r\f\r# 加载程序\r利用mmap系统调用进行文件映射，把程序加载到内存中。所谓的映射，意思是可以通过读取内存直接获得文件的内容，也可以通过写内存对文件的内容进行修改\r\r在linux下，通过使用Proc文件系统，就可以表示进程利用mmap系统调用把文件映射到内存的范围信息。例如，利用cat /proc/44337/maps就可以表示44437进程中文件映射的信息。通过readelf –l /tmp/showmap 可以输出程序头。里面有elf段和内存空间的对应关系。\rELF文件中拥有实体的段都是通过mmap系统调用来加载的。不过进程的内存空间中也存在不和ELF文件对应的部分，比如，和.bss等节对应的空间、机器栈、堆。\r\r\r## 动态链接的过程\r目标文件的种类不同，加载ELF文件的主体也不同。程序由系统内核加载，共享库由动态链接加载器加载。\n\r动态链接加载器是指加载并链接动态链接的程序本身及其链接的共享库，设置程序运行状态的程序。Linux下常用的动态链接加载器是/lib/ld-linux.so.2。动态链接加载器的统称为ld.so。使用ELF文件的系统中，程序ELF文件的INTERP段需要指定动态链接加载器的路径。系统内核在启动程序时读入此段的内容，从而加载，启动程序。换句话说，动态链接器和动态链接加载器的运作过程并无二致。\r从ld.so链接程序到程序的执行完毕过程。\r\r>1.\t加载程序\r2.\t启动ld.so\r3.\t读入共享库\r4.\t符号相消和重定位\r5.\t初始化\r6.\t跳转到程序入口\r7.\t程序终止处理\r\r首先系统内核加载程序和ld.so，准备好运行环境后交由ld.so处理。完成启动的ld.so根据系统内核传递的参数进行初始化。接着读取程序的DYNAMIC段，加载所有可执行文件链接的共享库。对已经加载的共享库也执行同样的处理，递归加载所有的共享库。一旦加载完所需要的库，马上消解所有程序和代码库中的符号，并重定位代码。这样就完成了启动程序的准备工作。在执行了各个文件的初始化代码后，跳转到程序的入口，这样就启动了程序。在C语言程序中，也就是执行了main函数的意思。程序执行完毕后，最后会对每个文件执行终止处理，这样整个执行过程最终完成。 \r\r反汇编指的是从机器码恢复到汇编代码的过程。Linux上使用binutils包的objdump命令就可以反汇编一个程序，eg: objdump –d hello\r\t\nC语言中设定程序是从main函数开始执行，但实际上程序最初是从_start函数开始执行的。_start函数由lib提供的/usr/lib/crtl.o文件定义，ctrl.o在这个文件在编译时是默认链接的。_start函数会初始化libc，之后调用mian函数。\r\r执行终止处理，接下来从main函数返回，接着ld.so会执行终止处理代码。用于初始化的有.init节和.init_array节，相应的，终止处理有.fini节和.fini_array节。.fini节保存进程终止时的代码，而.fini_array则保存进程终止时执行的函数指针列表。程序执行完后，ld.so会调用exit系统调用终止进程。Exit系统调用和平时使用的exit函数不同。C语言调用exit系统调用时，调用的是_exit函数。_exit函数执行libc的终止处理代码（.fini节和.fini_array节）后，执行exit系统调用结束进程。而exit系统调用会跳过终止处理，立即结束进程。这就是ld.so所有处理过程。\r\r\r\r动态加载指的是在程序运行时指定共享库名称进行加载的方法。动态加载经常被用于实现所谓的插件。Linux中使用dlopen()函数进行动态加载。动态链接的程序最初一定已经加载了ld.so。而程序启动后它依然保存在内存上。因此只需要调用内存中的ld.so的代码，就可以在程序开始执行之后也能进行动态链接处理。\r\r地址无关代码指的是无论加载到那个地址，都不需要重定位也能运行的代码。共享库的代码一定要是地址无关的代码，这一点很重要共享库一定要设置为地址无关代码，是为了实现库共享。要实现地址无关的代码，必须改变两点：一是全局变量的访问，二是 外部函数的调用。\r\r访问全局变量的代码一定要把绝对地址改为相对地址。可以使用全局偏移表（GOT）的结构。GOT是指向全局变量的指针数组，链接器为其申请内存空间，动态链接加载器初始化其内容。地址无关代码就是通过 从这个GOT中读取地址而做到地址无关的。\r\r外部函数如何调用地址无关的代码。Linux下为了使函数调用地址独立，使用了一种可以称之为GOT的函数版的方法—过程链接表（PLT）。不过PLT一般比GOT的入口数多，因此会采取延迟初始化。也就是说，外部函数第一次调用该函数时，该函数才会被链接。\r\r地址无关的可执行文件（PIE）。指的是使用地址无关代码的可执行文件。因为地址无关，所以可以被加载到任意地址。 \r","slug":"x86系统编译原理","published":1,"updated":"2017-09-02T10:13:38.000Z","layout":"post","photos":[],"link":"","_id":"cjd4d1a0o001yryx4i4fl4c9j","content":"<h1 id=\"编译过程简述\"><a href=\"#编译过程简述\" class=\"headerlink\" title=\"编译过程简述\"></a>编译过程简述</h1><h2 id=\"编译：\"><a href=\"#编译：\" class=\"headerlink\" title=\"编译：\"></a>编译：</h2><h3 id=\"预处理\"><a href=\"#预处理\" class=\"headerlink\" title=\"预处理\"></a>预处理</h3><p>主要处理源文件中以“#”开头的预编译指令，例如#include，#define，#ifdef，#pragma等。</p>\n<h3 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h3><p>通过词法分析（生成一系列记号），语法分析（根据一系列记号生成语法树），语义分析（对语法树每一部分做有效性检查），优化后生成汇编代码。</p>\n<h3 id=\"汇编\"><a href=\"#汇编\" class=\"headerlink\" title=\"汇编\"></a>汇编</h3><p>产生机器指令。</p>\n<h3 id=\"ELF文件（这里指-o文件）中包含什么？\"><a href=\"#ELF文件（这里指-o文件）中包含什么？\" class=\"headerlink\" title=\"ELF文件（这里指.o文件）中包含什么？\"></a>ELF文件（这里指.o文件）中包含什么？</h3><blockquote>\n<ol>\n<li>文件头</li>\n<li>段表：包含了段的基本属性，例如每个段的段名，段的长度，在文件中的偏移，读写权限等。</li>\n<li>重定位表：链接器在处理目标文件时，需要对文件的某些部分进行重定位。这些重定位信息就保存在重定位表里。</li>\n<li>字符串表</li>\n<li>符号表：每个目标文件中都会有一个符号表，记录了目标文件中用到的所有符号。每个符号有一个符号值，对于变量和函数而言，符号值就是它们的地址（我理解的是在文件中的相对偏移量，因为符号的虚拟地址是在链接后才重定位的，那么地址也只能是在文件中的地址。不知道对不对）。分别有全局符号，段名，局部符号。符号表往往是一个段，叫作.symtab。</li>\n</ol>\n</blockquote>\n<h3 id=\"链接步骤（俗称两步链接）\"><a href=\"#链接步骤（俗称两步链接）\" class=\"headerlink\" title=\"链接步骤（俗称两步链接）\"></a>链接步骤（俗称两步链接）</h3><ol>\n<li>空间与地址分配，扫描所有的输入目标文件，并确定它们各个段的长度，属性和位置，并将输入目标文件符号表中的所有符号定义和符号引用收集起来，统一放到一个全局符号表。链接器获得所有输入目标文件的段长度，并将它们合并，计算出文件中各个段合并后的长度与位置，并建立映射关系（也就是说，已经分配了虚拟地址空间）。</li>\n<li>符号解析与重定位。因为每个符号相对于所在段的偏移是确定的。而且，每个段虚拟地址已经分配，所以，只需将段起始地址加偏移量就可以得到符号的虚拟地址。也就实现了重定位。</li>\n</ol>\n<p>###动态链接：解决的问题：<br>1.空间浪费<br>2.程序更新，部署，发布困难。</p>\n<h1 id=\"编译器\"><a href=\"#编译器\" class=\"headerlink\" title=\"编译器\"></a>编译器</h1><p>将程序语言的代码转化为其他形式的软件。这个转换过程叫做编译。Eg:c-&gt;(gcc)</p>\n<p>Linux可执行的文件通常指符合（ELF）Executable and Linking Format)这种特定形式的文件。ls 、cp 这些命令对应的实体文件都是可执行文件，使用file命令能查看文件是否符合ELF形式。ELF文件包含了程序以及如何运行程序的相关信息（元数据），机器语言是唯一一种cpu能够直接执行的语言，这里的程序或代码就是指机器语言的列表。</p>\n<h2 id=\"gcc\"><a href=\"#gcc\" class=\"headerlink\" title=\"gcc\"></a>gcc</h2><p>gcc 是将C语言的程序转化为机器语言描述的程序，将机器语言的程序按照ELF这种特定文件格式注入 文件，得到的就是可执行文件。由hello.c这样单个文件来生成可执行文件的过程如下：预处理（.i）侠义的编译(.s)—&gt;汇编(.o)-&gt;链接(.exe)。这个过程统称为build.</p>\n<ol>\n<li><p>预处理：由编译器对#include和#define进行处理。具体 来说，读入头文件，将所有的宏展开。预处理的内容近似于sed命令和awk命令这样纯文本的操作。</p>\n</li>\n<li><p>狭义的编译：编译器对预处理器的输出进行编译，生成汇编语言（.s）。</p>\n</li>\n<li><p>汇编：汇编器将汇编语言的代码转换为机器语言。汇编器的输出文件为目标文件（.o）。linux下目标文件也是ELF文件；目标文件和可执行文件是通过ELF文件中用于提取文件种类的标志。File 命令来查看。</p>\n</li>\n<li><p>链接：目标文件本身还不能直接使用，无论是直接运行还是作为程序库文件使用都不可以。将目标文件转换为最终可以使用的形式的处理称为链接。使用程序库的情况下，在这个阶段处理程序的加载。通过链接生成的并不一定是可执行文件，也可以是程序库文件。</p>\n</li>\n</ol>\n<h1 id=\"程序运行的全过程：\"><a href=\"#程序运行的全过程：\" class=\"headerlink\" title=\"程序运行的全过程：\"></a>程序运行的全过程：</h1><p>代码的build-&gt;ELF-&gt;运行加载链接-&gt;进程—&gt;结束</p>\n<p>运行环境：链接的话题并非仅出现在build过程。如果使用了共享库，那么在开始运行程序时链接才会发生。动态加载就是一种将所有链接处理放到程序于运行时进行的。</p>\n<p>编程语言的运行方式:编译器会对程序进行编译，将其转换为可执行的文件（c/c++）；解释器不将程序转换为别的语言，而直接运行（python）；运行程序的方式不止一种，C语言也可以用解释器来运行，编程语言可以和运行方式自由搭配；编译器、解释器都统称为编程语言的处理器。     根据语言的特点：有静态类型检查，要求较高可靠性的情况下用编译方式；没有静态类型检查，对灵活性要求高于严密性的情况下，则使用解释方式。    静态类检查是指在程序开始运行之前，对函数的返回值以及参数进行检查的功能；在程序运行过程中随时进行类型检查的为动态类型检查。 静态指不运行程序而进行的处理；动态指一边运行程序一边进行某些处理。</p>\n<p>狭义的编译过程:语法分析&gt;语义分析&gt;生成中间代码&gt;代码生成。</p>\n<p>语法分析 :首先对代码进行解析，将其转化为计算机易于理解的形式，也就是语法树的形式。解析代码的程序模块称为解析器或者语法分析器</p>\n<p>语义分析：通过解析语法获得语法树后，接着就要解析语法树，除去多余的内容、添加必要的信息；生成抽象的语法树。</p>\n<p>语义分析包括：</p>\n<ol>\n<li>区分变量为局部变量还是全局变量</li>\n<li>解析变量的声明和引用。</li>\n<li>变量和表达式的类型检查</li>\n<li>检查引用变量之前是否进行了初始化。</li>\n<li>检查函数是否按照定义返回了结果</li>\n</ol>\n<p>语法分析只是对代码的表象进行分析；语义分析是对表象之外的部分级进行分析。语法分析生成的语法树只是将代码的构造照搬过来。而语义分析生成的抽象语法树还包含了语义信息。比如，在变量的引用和定义之间添加链接；适当的增加类型转换命令，是表达式的类型一致；另外语法树中的表达式外侧的括号行末的分号在抽象的语法树都将被省略。</p>\n<p>生成中间代码：将抽象语法树转化为只在编译器内部使用的中间代码；之所以特地的转化为中间代码，主要是为了支持多种编程语言或机器语言；</p>\n<p>gcc 使用一种名为RTL(Register Transfer Language)的中间代码。解析代码转化为中间代码为止称为编译器的前端。<br>    代码生成：吧中间代码转换为汇编语言，这个阶段为代码生成；负责代码生成的程序模块为代码生成器。<br>    优化：各个环节都可执行优化</p>\n<h1 id=\"语法分析：\"><a href=\"#语法分析：\" class=\"headerlink\" title=\"语法分析：\"></a>语法分析：</h1><h2 id=\"词法分析\"><a href=\"#词法分析\" class=\"headerlink\" title=\"词法分析\"></a>词法分析</h2><ol>\n<li>词法分析就是将代码分割为一个个的单词，也可以称为扫描。</li>\n<li>在该过程中，会将空白字符和注释这种对程序没有实际意义的部分剔除。</li>\n<li>正是因为预先有了词法分析，语法分析才可以只处理有意义的单词，进而实现简化处理。</li>\n<li>负责词法分析的模块称为词法分析器，又称为扫描器。</li>\n<li><p>Token：在编程语言系统中，将一个单词的字面和他的种类以及语义值统称为token。词法解析器的作用就是解析代码并生成token序列。</p>\n</li>\n<li><p>编程语言的编译器中的解析器的主要作用是解析有扫描器生成的token序列，并生成代码所对应的树形结构，即语法树。</p>\n</li>\n<li>语法树和语法是完全对应的，所以c语言的分号以及表达式的括号等都包含在真实的语法树中，但是，没有意义，因此，实际上大部分情况下会生成一开始就省略分号和括号的抽象语法树。也就是说解析器会跳过语法树，直接生成抽象语法树。</li>\n</ol>\n<p>理想情况是将词法分析、语法分析、语义分析这三个阶段做成3个独立的模块，这样的代码是最优美的。但实际上，这三个阶段并不能明确的分割开来。</p>\n<p>语法分析的两层含义：一、语法分析中词法分析以外的部分才称为语法分析。二、词法分析和语法分析合起来称为语法分析。</p>\n<h2 id=\"语法分析\"><a href=\"#语法分析\" class=\"headerlink\" title=\"语法分析\"></a>语法分析</h2><p>定义的分析<br>语句的分析<br>表达式的分析<br>项的分析</p>\n<h2 id=\"语义分析\"><a href=\"#语义分析\" class=\"headerlink\" title=\"语义分析\"></a>语义分析</h2><p>变量引用的消解<br>类型名称的消解<br>类型定义的检查<br>表达式有效性的检查<br>静态类型的检查 </p>\n<h1 id=\"计算机内部结构\"><a href=\"#计算机内部结构\" class=\"headerlink\" title=\"计算机内部结构\"></a>计算机内部结构</h1><p>计算机的中心是总线（bus）。总线是传送数据的通信干线，它连接了计算机中的各个设备，使之通信，就像人类的血管或者神经系统。</p>\n<ol>\n<li><p>CPU是负责运算的设备。</p>\n<ul>\n<li>CPU内部有寄存器，寄存器大小有32位或64位，在cpu计算时，寄存器被用于临时存放数据。通常cpu先将数据从存储器读入寄存器，然后以寄存器为对象进行计算，再将结果写回存储器。<br>将数据从存储器读入寄存器的操作称为加载<br>将数据从寄存器写回存储器的操作称为写回</li>\n</ul>\n</li>\n<li><p>存储器是存储二进制数据的设备。</p>\n</li>\n<li>进程所使用的地址称为虚拟地址。<ul>\n<li>物理存储器的实际地址称为物理地址。</li>\n<li>虚拟地址的整体范围称为程序的地址空间。</li>\n<li>进程使用虚拟地址访问存储器，cpu内部称为MMU的设备会访问地址转换表进行地址转换。</li>\n</ul>\n</li>\n<li>CPU<ul>\n<li>386是x86系列的第一款32位cpu.</li>\n<li>Pentinum 4是intel的x86系列第一款64位cpu。</li>\n<li>满足1.具备n位宽的通用寄存器 2.具备n位以上的地址空间。 才真正被称为n位cpu。</li>\n<li>32位的cpu的通用寄存器的大小为32位，和指针大小相同，地址空间为无符号的32位整数可以指向的范围。64位一样。</li>\n<li>X86系列的CPU只要使用PAE(physical address extension)这样的机制，32位的CPU也可以操作36位范围的地址空间</li>\n</ul>\n</li>\n<li>指令集<br>不同的CPU都能够解释的机器语言体系称为指令集架构（ISA， instruction set architecture）,也可以简称指令集。<br>Intel 将x86系列CPU之中的32位CPU的指令集架构称为IA—32.IA(iIntel Architecture).</li>\n</ol>\n<p>\f</p>\n<h1 id=\"ELF文件的结构\"><a href=\"#ELF文件的结构\" class=\"headerlink\" title=\"ELF文件的结构\"></a>ELF文件的结构</h1><p>Linux使用ELF作为目标文件的格式。ELF格式被用于描述目标文件、可执行文件以及共享库的所有信息。<br>无论什么场合，使用ELF格式的目的只有一个，那就是把机器代码以及其对应的元数据以方便的链接器和加载器处理的形式保存起来。<br>代码的元数据包含如下的信息：</p>\n<ol>\n<li>代码文件的大小以及转换前的源代码文件名。</li>\n<li>符号<br>符号指的是变量或者函数的名称。简单的情况下直接使用原编程语言中的函数名或者变量名即可。有时候也会根据不同的编程语言进行特定的变换后得到的符号名称。这种变换称为名称重整。比如c++里的重载。</li>\n<li>重定位信息<br>重定位信息用于表示在链接完成前无法确定内存地址的代码位置信息。比如，在共享库内的函数，那么在最终链接完成后才能确定的其内存地址。在这种情况下，目标文件中就会留有“代码中这个位置的内存引用尚未确定”这样的信息。<br>这样的信息就是重定向信息。</li>\n<li>调试信息</li>\n</ol>\n<h2 id=\"ELF的节和段\"><a href=\"#ELF的节和段\" class=\"headerlink\" title=\"ELF的节和段\"></a>ELF的节和段</h2><p>ELF文件结构的二元结构。目的：为了兼顾链接器、汇编器等编译工具以及程序加载到内存中的加载器两者的易用性的需求。</p>\n<p>二元结构:如果以程序头信息来处理，则ELF文件可以解释为段集合。如果以节头信息来处理，则可以解释成节集合。</p>\n<table>\n<thead>\n<tr>\n<th>节</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ELF头</td>\n</tr>\n<tr>\n<td>程序头（描述段）</td>\n</tr>\n<tr>\n<td>.text节</td>\n</tr>\n<tr>\n<td>.rodata节</td>\n</tr>\n<tr>\n<td>.data节</td>\n</tr>\n<tr>\n<td>.got节</td>\n</tr>\n<tr>\n<td>.symtab节</td>\n</tr>\n<tr>\n<td>.strtab节</td>\n</tr>\n<tr>\n<td>节头（描述节）</td>\n</tr>\n</tbody>\n</table>\n<p>节（section）：是汇编器、链接器等处理ELF文件内容的单位。ELF文件把不同目的的代码、数据等分割成节保存。比如，机器码统一保存到.text节中。全局变量的初始化数据则保存在.data节中。</p>\n<p>段（segment）：则是把程序加载到内存的加载器处理ELF文件时的单位。段由1个以上的字节构成。内存上不同范围有着“只读”、“可写”、“可执行”等不同的属性。因而需要根据属性进行分段。比如机器码如果不可执行就毫无意义，因此要统一到具有可执行属性段中。</p>\n<p>目标文件的主要节</p>\n<table>\n<thead>\n<tr>\n<th>节名</th>\n<th style=\"text-align:left\">内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>.text节</td>\n<td style=\"text-align:left\">机器码。配置机器码的节，虽然叫text，但和文本文件没有关系。</td>\n</tr>\n<tr>\n<td>.rodata节</td>\n<td style=\"text-align:left\">读专用的.data。配置的字符串字面量等不能更新的数据</td>\n</tr>\n<tr>\n<td>.data节</td>\n<td style=\"text-align:left\">全局变量等。在文件中无大小信息。配置的是拥有初始值的全局变量等，这个节的数据在加载后有可能发生变更。</td>\n</tr>\n<tr>\n<td>.bss</td>\n<td style=\"text-align:left\">通用符号等。在文件中无大小信息。配置的是没有初始值的全局变量，并且加载到内存后，会被分配所有字节都初始化为0的内存空间。BSS是（Block Started by Symbol）。</td>\n</tr>\n<tr>\n<td>.rel.text节</td>\n<td style=\"text-align:left\">.text段中的符号的重定位信息</td>\n</tr>\n<tr>\n<td>.symtab节</td>\n<td style=\"text-align:left\">文件中包含的符号表。实际的字面量在.strtab节中保存</td>\n</tr>\n<tr>\n<td>.strtab节</td>\n<td style=\"text-align:left\">符号等字符串列表</td>\n</tr>\n<tr>\n<td>.shstrtab</td>\n<td style=\"text-align:left\">节名字符串列表</td>\n</tr>\n<tr>\n<td>.line</td>\n<td style=\"text-align:left\">代码和原始代码行号对照</td>\n</tr>\n<tr>\n<td>.debug</td>\n<td style=\"text-align:left\">调试用的符号信息</td>\n</tr>\n<tr>\n<td>.fini</td>\n<td style=\"text-align:left\">进程结束前执行的代码</td>\n</tr>\n<tr>\n<td>.fini_array</td>\n<td style=\"text-align:left\">进程结束前执行的函数的指针数组</td>\n</tr>\n<tr>\n<td>.init</td>\n<td style=\"text-align:left\">目标文件加载时执行的代码</td>\n</tr>\n<tr>\n<td>.init_array</td>\n<td style=\"text-align:left\">目标文件加载时执行的函数的指针数组</td>\n</tr>\n<tr>\n<td>.note</td>\n<td style=\"text-align:left\">用于保障兼容性等</td>\n</tr>\n</tbody>\n</table>\n<p>Linux下的 binutils包中包含readelf命令可以输出elf文件的结构。</p>\n<pre><code>1．    readelf –S hello #输出hello的节头信息。\n2．    readelf –l hello #查看hello的程序头。\n3．    readelf –s hello #输出符号表。\n</code></pre><p>gcc<br>    gcc – c main.c //在编译后中断build.<br>    -o 指定输出文件名。<br>    -v 详细输出其内部处理过程</p>\n<p>Linux下负责链接的程序是/usr/bin/ld，这个程序称为GNU ld,一般称为链接器。</p>\n<h2 id=\"链接器可处理的文件：\"><a href=\"#链接器可处理的文件：\" class=\"headerlink\" title=\"链接器可处理的文件：\"></a>链接器可处理的文件：</h2><table>\n<thead>\n<tr>\n<th>文件类型</th>\n<th style=\"text-align:center\">格式</th>\n<th style=\"text-align:center\">后缀名</th>\n<th style=\"text-align:left\">生成器</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>可重定位文件</td>\n<td style=\"text-align:center\">ELF</td>\n<td style=\"text-align:center\">.o</td>\n<td style=\"text-align:left\">汇编器</td>\n</tr>\n<tr>\n<td>可执行文件</td>\n<td style=\"text-align:center\">ELF</td>\n<td style=\"text-align:center\">无</td>\n<td style=\"text-align:left\">链接器</td>\n</tr>\n<tr>\n<td>共享库</td>\n<td style=\"text-align:center\">ELF</td>\n<td style=\"text-align:center\">.so</td>\n<td style=\"text-align:left\">链接器</td>\n</tr>\n<tr>\n<td>静态库</td>\n<td style=\"text-align:center\">UNIX ar</td>\n<td style=\"text-align:center\">.a</td>\n<td style=\"text-align:left\">ar命令</td>\n</tr>\n</tbody>\n</table>\n<p>可重定位文件指汇编器生成的目标文件(.o)。GNU as 生成的可重定位文件没有程序头，因此不能直接运行，只有配合链接器与其他可重定位文件、库产生连接后才可执行。</p>\n<p>可执行文件指的是链接生成的用户可直接运行的目标文件。Linux下可执行文件没有后缀名</p>\n<p>共享库是链接生成的另一种形式的目标文件，其中集合了各个函数、变量等供用户调用，因此需要能够再次和其他目标文件链接使用。共享库不会直接运行。共享库也叫动态链接库。Linux下的共享库文件名一般以lib开头，以.so作为后缀，并加上版本号。</p>\n<p>静态库文件可以作为链接器的输入。和共享库文件一样，静态库文件也集合了各种函数、变量供其它用户使用。一般以lib开头，以.a作为后缀。静态库文件利用ar命令把多个可重定位文件打包成一个，因此链接静态库文件就相当于链接其中打包的所有可重定位文件。</p>\n<h1 id=\"什么是链接\"><a href=\"#什么是链接\" class=\"headerlink\" title=\"什么是链接\"></a>什么是链接</h1><p>链接指的是把多个目标文件关联为一个整体。而通过关联多个目标文件，就可生成同时使用多个目标文件定义的变量、函数的程序。</p>\n<p>具体步骤：</p>\n<ol>\n<li>合并节</li>\n<li>重定位 </li>\n<li>符号相消</li>\n</ol>\n<p>此外，链接时还必须进行很多其他的处理。比如，在生成ELF文件时，需要为程序生成合适的程序头信息。不过归根到底，链接的主旨是关联目标文件，因此主要处理也就是上述三点。</p>\n<h2 id=\"合并节：\"><a href=\"#合并节：\" class=\"headerlink\" title=\"合并节：\"></a>合并节：</h2><p>在链接多个目标文件时，需要从各个目标文件中抽取节，把相同种类的节合并到一起。</p>\n<h2 id=\"重定位：\"><a href=\"#重定位：\" class=\"headerlink\" title=\"重定位：\"></a>重定位：</h2><p>指根据程序实际加载到内存时的地址，对目标文件中的代码和数据进行调整。<br>在链接文件时，根据整体情况决定“真实的”内存地址，把所有用虚拟内存地址的地方替换成真实的内存地址。这个处理就是重定位。</p>\n<h2 id=\"符号相消\"><a href=\"#符号相消\" class=\"headerlink\" title=\"符号相消\"></a>符号相消</h2><p>指为了可以使用其他目标文件和库文件中提供的变量和函数，把尚未和实体链接的符号与具体的变量和函数等实体链接起来的操作。例如：mian.c中有printf函数，汇编器会把“这个目标文件中使用的printf函数的函数体在其他文件中”这个信息保留下来。这个信息就是未定义的符号。接下来，再进行链接操作的时候，再检索未定义的符号，把相关的变量或者函数的内存地址链接进来。这个处理就是符号消解。</p>\n<p>符号相消和重定位联系紧密，比如上面的printf函数，编译mian.c时printf函数的地址是未知的，这时编译器为printf函数分配虚拟地址，并生成类似call printf的汇编指令，然后在链接时再把函数的内存地址修正为正确的地址。而这个“先设置虚拟地址，在链接时修正为正确的地址”的处理正是重定位操作，因此符号消解本身可以通过重定位来实现。<br>总体来说，像上面这样解释目标文件代码的含义，把目标文件从物理上、逻辑上连接起来，从而生成可执行文件的处理就是“链接”。</p>\n<h2 id=\"动态链接和静态链接\"><a href=\"#动态链接和静态链接\" class=\"headerlink\" title=\"动态链接和静态链接\"></a>动态链接和静态链接</h2><p>静态库在build，也就是执行ld命令的时候就会进行目标文件的链接，<br> 而共享库在build的时候不会进行目标文件的链接，而只是检查共享库和符号是否存在，在程序运行时才在内存上实际链接目标文件。<br>    其中，在build时链接目标文件的的链接操作称为静态链接。<br>    而在程序执行时链接目标文件的链接操作则称为动态链接。<br>    给链接器输入多个重定位文件时，这些文件被执行静态链接。<br>    动态链接有容易更新、节省磁盘空间、节省内存的优点。Linux下也主要使用共享库和动态链接。gcc也是如此，不加任何选项的话执行的动态链接，而静态库的静态链接只在个别情况下使用。缺点：性能稍差、链接具有不确定性。</p>\n<pre><code>Eg:\n动态链接：\ngcc –c main.c\ngcc –c f.c\ngcc main.o f.o –lc –o prog\n-l选项可以为链接指定库\nLdd prog  //查看是否被动态链接。\n\n静态链接：\ngcc –static main.o f.o –lc –o prog\nfile prog\n\n生成库\n\n生成静态库\n用ar生成静态库，和tar命令差不多\neg：$ ar crs libmy.a f.o g.o h.o\n选项\n含义\nc\n如果存档不存在，则创建\nr\n向存档添加文件\nS\n生成加速链接的索引\n\nLinux下优化执行时共享库的检索速度，加载器会对共享库的信息建立缓存文件。这个缓存文件就是 /etc/ld.so.cache。安装新版本的共享库时，一定要更新这个缓存文件，更新缓存文件的需要以管理员的权限运行ldconfig命令。\n\ngcc –c –fPIC f.c\ngcc –c –fPIC g.c\ngcc –share –WL, -soname, libfg.so.1 f.o g.o –o libfg.so.1\nfile libfg.so.1\n</code></pre><p>\f</p>\n<h1 id=\"加载程序\"><a href=\"#加载程序\" class=\"headerlink\" title=\"加载程序\"></a>加载程序</h1><p>利用mmap系统调用进行文件映射，把程序加载到内存中。所谓的映射，意思是可以通过读取内存直接获得文件的内容，也可以通过写内存对文件的内容进行修改</p>\n<p>在linux下，通过使用Proc文件系统，就可以表示进程利用mmap系统调用把文件映射到内存的范围信息。例如，利用cat /proc/44337/maps就可以表示44437进程中文件映射的信息。通过readelf –l /tmp/showmap 可以输出程序头。里面有elf段和内存空间的对应关系。<br>ELF文件中拥有实体的段都是通过mmap系统调用来加载的。不过进程的内存空间中也存在不和ELF文件对应的部分，比如，和.bss等节对应的空间、机器栈、堆。</p>\n<h2 id=\"动态链接的过程\"><a href=\"#动态链接的过程\" class=\"headerlink\" title=\"动态链接的过程\"></a>动态链接的过程</h2><p>目标文件的种类不同，加载ELF文件的主体也不同。程序由系统内核加载，共享库由动态链接加载器加载。</p>\n<p>动态链接加载器是指加载并链接动态链接的程序本身及其链接的共享库，设置程序运行状态的程序。Linux下常用的动态链接加载器是/lib/ld-linux.so.2。动态链接加载器的统称为ld.so。使用ELF文件的系统中，程序ELF文件的INTERP段需要指定动态链接加载器的路径。系统内核在启动程序时读入此段的内容，从而加载，启动程序。换句话说，动态链接器和动态链接加载器的运作过程并无二致。<br>从ld.so链接程序到程序的执行完毕过程。</p>\n<blockquote>\n<ol>\n<li>加载程序</li>\n<li>启动ld.so</li>\n<li>读入共享库</li>\n<li>符号相消和重定位</li>\n<li>初始化</li>\n<li>跳转到程序入口</li>\n<li>程序终止处理</li>\n</ol>\n</blockquote>\n<p>首先系统内核加载程序和ld.so，准备好运行环境后交由ld.so处理。完成启动的ld.so根据系统内核传递的参数进行初始化。接着读取程序的DYNAMIC段，加载所有可执行文件链接的共享库。对已经加载的共享库也执行同样的处理，递归加载所有的共享库。一旦加载完所需要的库，马上消解所有程序和代码库中的符号，并重定位代码。这样就完成了启动程序的准备工作。在执行了各个文件的初始化代码后，跳转到程序的入口，这样就启动了程序。在C语言程序中，也就是执行了main函数的意思。程序执行完毕后，最后会对每个文件执行终止处理，这样整个执行过程最终完成。 </p>\n<p>反汇编指的是从机器码恢复到汇编代码的过程。Linux上使用binutils包的objdump命令就可以反汇编一个程序，eg: objdump –d hello</p>\n<p>C语言中设定程序是从main函数开始执行，但实际上程序最初是从_start函数开始执行的。_start函数由lib提供的/usr/lib/crtl.o文件定义，ctrl.o在这个文件在编译时是默认链接的。_start函数会初始化libc，之后调用mian函数。</p>\n<p>执行终止处理，接下来从main函数返回，接着ld.so会执行终止处理代码。用于初始化的有.init节和.init_array节，相应的，终止处理有.fini节和.fini_array节。.fini节保存进程终止时的代码，而.fini_array则保存进程终止时执行的函数指针列表。程序执行完后，ld.so会调用exit系统调用终止进程。Exit系统调用和平时使用的exit函数不同。C语言调用exit系统调用时，调用的是_exit函数。_exit函数执行libc的终止处理代码（.fini节和.fini_array节）后，执行exit系统调用结束进程。而exit系统调用会跳过终止处理，立即结束进程。这就是ld.so所有处理过程。</p>\n<p>动态加载指的是在程序运行时指定共享库名称进行加载的方法。动态加载经常被用于实现所谓的插件。Linux中使用dlopen()函数进行动态加载。动态链接的程序最初一定已经加载了ld.so。而程序启动后它依然保存在内存上。因此只需要调用内存中的ld.so的代码，就可以在程序开始执行之后也能进行动态链接处理。</p>\n<p>地址无关代码指的是无论加载到那个地址，都不需要重定位也能运行的代码。共享库的代码一定要是地址无关的代码，这一点很重要共享库一定要设置为地址无关代码，是为了实现库共享。要实现地址无关的代码，必须改变两点：一是全局变量的访问，二是 外部函数的调用。</p>\n<p>访问全局变量的代码一定要把绝对地址改为相对地址。可以使用全局偏移表（GOT）的结构。GOT是指向全局变量的指针数组，链接器为其申请内存空间，动态链接加载器初始化其内容。地址无关代码就是通过 从这个GOT中读取地址而做到地址无关的。</p>\n<p>外部函数如何调用地址无关的代码。Linux下为了使函数调用地址独立，使用了一种可以称之为GOT的函数版的方法—过程链接表（PLT）。不过PLT一般比GOT的入口数多，因此会采取延迟初始化。也就是说，外部函数第一次调用该函数时，该函数才会被链接。</p>\n<p>地址无关的可执行文件（PIE）。指的是使用地址无关代码的可执行文件。因为地址无关，所以可以被加载到任意地址。 </p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"编译过程简述\"><a href=\"#编译过程简述\" class=\"headerlink\" title=\"编译过程简述\"></a>编译过程简述</h1><h2 id=\"编译：\"><a href=\"#编译：\" class=\"headerlink\" title=\"编译：\"></a>编译：</h2><h3 id=\"预处理\"><a href=\"#预处理\" class=\"headerlink\" title=\"预处理\"></a>预处理</h3><p>主要处理源文件中以“#”开头的预编译指令，例如#include，#define，#ifdef，#pragma等。</p>\n<h3 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h3><p>通过词法分析（生成一系列记号），语法分析（根据一系列记号生成语法树），语义分析（对语法树每一部分做有效性检查），优化后生成汇编代码。</p>\n<h3 id=\"汇编\"><a href=\"#汇编\" class=\"headerlink\" title=\"汇编\"></a>汇编</h3><p>产生机器指令。</p>\n<h3 id=\"ELF文件（这里指-o文件）中包含什么？\"><a href=\"#ELF文件（这里指-o文件）中包含什么？\" class=\"headerlink\" title=\"ELF文件（这里指.o文件）中包含什么？\"></a>ELF文件（这里指.o文件）中包含什么？</h3><blockquote>\n<ol>\n<li>文件头</li>\n<li>段表：包含了段的基本属性，例如每个段的段名，段的长度，在文件中的偏移，读写权限等。</li>\n<li>重定位表：链接器在处理目标文件时，需要对文件的某些部分进行重定位。这些重定位信息就保存在重定位表里。</li>\n<li>字符串表</li>\n<li>符号表：每个目标文件中都会有一个符号表，记录了目标文件中用到的所有符号。每个符号有一个符号值，对于变量和函数而言，符号值就是它们的地址（我理解的是在文件中的相对偏移量，因为符号的虚拟地址是在链接后才重定位的，那么地址也只能是在文件中的地址。不知道对不对）。分别有全局符号，段名，局部符号。符号表往往是一个段，叫作.symtab。</li>\n</ol>\n</blockquote>\n<h3 id=\"链接步骤（俗称两步链接）\"><a href=\"#链接步骤（俗称两步链接）\" class=\"headerlink\" title=\"链接步骤（俗称两步链接）\"></a>链接步骤（俗称两步链接）</h3><ol>\n<li>空间与地址分配，扫描所有的输入目标文件，并确定它们各个段的长度，属性和位置，并将输入目标文件符号表中的所有符号定义和符号引用收集起来，统一放到一个全局符号表。链接器获得所有输入目标文件的段长度，并将它们合并，计算出文件中各个段合并后的长度与位置，并建立映射关系（也就是说，已经分配了虚拟地址空间）。</li>\n<li>符号解析与重定位。因为每个符号相对于所在段的偏移是确定的。而且，每个段虚拟地址已经分配，所以，只需将段起始地址加偏移量就可以得到符号的虚拟地址。也就实现了重定位。</li>\n</ol>\n<p>###动态链接：解决的问题：<br>1.空间浪费<br>2.程序更新，部署，发布困难。</p>\n<h1 id=\"编译器\"><a href=\"#编译器\" class=\"headerlink\" title=\"编译器\"></a>编译器</h1><p>将程序语言的代码转化为其他形式的软件。这个转换过程叫做编译。Eg:c-&gt;(gcc)</p>\n<p>Linux可执行的文件通常指符合（ELF）Executable and Linking Format)这种特定形式的文件。ls 、cp 这些命令对应的实体文件都是可执行文件，使用file命令能查看文件是否符合ELF形式。ELF文件包含了程序以及如何运行程序的相关信息（元数据），机器语言是唯一一种cpu能够直接执行的语言，这里的程序或代码就是指机器语言的列表。</p>\n<h2 id=\"gcc\"><a href=\"#gcc\" class=\"headerlink\" title=\"gcc\"></a>gcc</h2><p>gcc 是将C语言的程序转化为机器语言描述的程序，将机器语言的程序按照ELF这种特定文件格式注入 文件，得到的就是可执行文件。由hello.c这样单个文件来生成可执行文件的过程如下：预处理（.i）侠义的编译(.s)—&gt;汇编(.o)-&gt;链接(.exe)。这个过程统称为build.</p>\n<ol>\n<li><p>预处理：由编译器对#include和#define进行处理。具体 来说，读入头文件，将所有的宏展开。预处理的内容近似于sed命令和awk命令这样纯文本的操作。</p>\n</li>\n<li><p>狭义的编译：编译器对预处理器的输出进行编译，生成汇编语言（.s）。</p>\n</li>\n<li><p>汇编：汇编器将汇编语言的代码转换为机器语言。汇编器的输出文件为目标文件（.o）。linux下目标文件也是ELF文件；目标文件和可执行文件是通过ELF文件中用于提取文件种类的标志。File 命令来查看。</p>\n</li>\n<li><p>链接：目标文件本身还不能直接使用，无论是直接运行还是作为程序库文件使用都不可以。将目标文件转换为最终可以使用的形式的处理称为链接。使用程序库的情况下，在这个阶段处理程序的加载。通过链接生成的并不一定是可执行文件，也可以是程序库文件。</p>\n</li>\n</ol>\n<h1 id=\"程序运行的全过程：\"><a href=\"#程序运行的全过程：\" class=\"headerlink\" title=\"程序运行的全过程：\"></a>程序运行的全过程：</h1><p>代码的build-&gt;ELF-&gt;运行加载链接-&gt;进程—&gt;结束</p>\n<p>运行环境：链接的话题并非仅出现在build过程。如果使用了共享库，那么在开始运行程序时链接才会发生。动态加载就是一种将所有链接处理放到程序于运行时进行的。</p>\n<p>编程语言的运行方式:编译器会对程序进行编译，将其转换为可执行的文件（c/c++）；解释器不将程序转换为别的语言，而直接运行（python）；运行程序的方式不止一种，C语言也可以用解释器来运行，编程语言可以和运行方式自由搭配；编译器、解释器都统称为编程语言的处理器。     根据语言的特点：有静态类型检查，要求较高可靠性的情况下用编译方式；没有静态类型检查，对灵活性要求高于严密性的情况下，则使用解释方式。    静态类检查是指在程序开始运行之前，对函数的返回值以及参数进行检查的功能；在程序运行过程中随时进行类型检查的为动态类型检查。 静态指不运行程序而进行的处理；动态指一边运行程序一边进行某些处理。</p>\n<p>狭义的编译过程:语法分析&gt;语义分析&gt;生成中间代码&gt;代码生成。</p>\n<p>语法分析 :首先对代码进行解析，将其转化为计算机易于理解的形式，也就是语法树的形式。解析代码的程序模块称为解析器或者语法分析器</p>\n<p>语义分析：通过解析语法获得语法树后，接着就要解析语法树，除去多余的内容、添加必要的信息；生成抽象的语法树。</p>\n<p>语义分析包括：</p>\n<ol>\n<li>区分变量为局部变量还是全局变量</li>\n<li>解析变量的声明和引用。</li>\n<li>变量和表达式的类型检查</li>\n<li>检查引用变量之前是否进行了初始化。</li>\n<li>检查函数是否按照定义返回了结果</li>\n</ol>\n<p>语法分析只是对代码的表象进行分析；语义分析是对表象之外的部分级进行分析。语法分析生成的语法树只是将代码的构造照搬过来。而语义分析生成的抽象语法树还包含了语义信息。比如，在变量的引用和定义之间添加链接；适当的增加类型转换命令，是表达式的类型一致；另外语法树中的表达式外侧的括号行末的分号在抽象的语法树都将被省略。</p>\n<p>生成中间代码：将抽象语法树转化为只在编译器内部使用的中间代码；之所以特地的转化为中间代码，主要是为了支持多种编程语言或机器语言；</p>\n<p>gcc 使用一种名为RTL(Register Transfer Language)的中间代码。解析代码转化为中间代码为止称为编译器的前端。<br>    代码生成：吧中间代码转换为汇编语言，这个阶段为代码生成；负责代码生成的程序模块为代码生成器。<br>    优化：各个环节都可执行优化</p>\n<h1 id=\"语法分析：\"><a href=\"#语法分析：\" class=\"headerlink\" title=\"语法分析：\"></a>语法分析：</h1><h2 id=\"词法分析\"><a href=\"#词法分析\" class=\"headerlink\" title=\"词法分析\"></a>词法分析</h2><ol>\n<li>词法分析就是将代码分割为一个个的单词，也可以称为扫描。</li>\n<li>在该过程中，会将空白字符和注释这种对程序没有实际意义的部分剔除。</li>\n<li>正是因为预先有了词法分析，语法分析才可以只处理有意义的单词，进而实现简化处理。</li>\n<li>负责词法分析的模块称为词法分析器，又称为扫描器。</li>\n<li><p>Token：在编程语言系统中，将一个单词的字面和他的种类以及语义值统称为token。词法解析器的作用就是解析代码并生成token序列。</p>\n</li>\n<li><p>编程语言的编译器中的解析器的主要作用是解析有扫描器生成的token序列，并生成代码所对应的树形结构，即语法树。</p>\n</li>\n<li>语法树和语法是完全对应的，所以c语言的分号以及表达式的括号等都包含在真实的语法树中，但是，没有意义，因此，实际上大部分情况下会生成一开始就省略分号和括号的抽象语法树。也就是说解析器会跳过语法树，直接生成抽象语法树。</li>\n</ol>\n<p>理想情况是将词法分析、语法分析、语义分析这三个阶段做成3个独立的模块，这样的代码是最优美的。但实际上，这三个阶段并不能明确的分割开来。</p>\n<p>语法分析的两层含义：一、语法分析中词法分析以外的部分才称为语法分析。二、词法分析和语法分析合起来称为语法分析。</p>\n<h2 id=\"语法分析\"><a href=\"#语法分析\" class=\"headerlink\" title=\"语法分析\"></a>语法分析</h2><p>定义的分析<br>语句的分析<br>表达式的分析<br>项的分析</p>\n<h2 id=\"语义分析\"><a href=\"#语义分析\" class=\"headerlink\" title=\"语义分析\"></a>语义分析</h2><p>变量引用的消解<br>类型名称的消解<br>类型定义的检查<br>表达式有效性的检查<br>静态类型的检查 </p>\n<h1 id=\"计算机内部结构\"><a href=\"#计算机内部结构\" class=\"headerlink\" title=\"计算机内部结构\"></a>计算机内部结构</h1><p>计算机的中心是总线（bus）。总线是传送数据的通信干线，它连接了计算机中的各个设备，使之通信，就像人类的血管或者神经系统。</p>\n<ol>\n<li><p>CPU是负责运算的设备。</p>\n<ul>\n<li>CPU内部有寄存器，寄存器大小有32位或64位，在cpu计算时，寄存器被用于临时存放数据。通常cpu先将数据从存储器读入寄存器，然后以寄存器为对象进行计算，再将结果写回存储器。<br>将数据从存储器读入寄存器的操作称为加载<br>将数据从寄存器写回存储器的操作称为写回</li>\n</ul>\n</li>\n<li><p>存储器是存储二进制数据的设备。</p>\n</li>\n<li>进程所使用的地址称为虚拟地址。<ul>\n<li>物理存储器的实际地址称为物理地址。</li>\n<li>虚拟地址的整体范围称为程序的地址空间。</li>\n<li>进程使用虚拟地址访问存储器，cpu内部称为MMU的设备会访问地址转换表进行地址转换。</li>\n</ul>\n</li>\n<li>CPU<ul>\n<li>386是x86系列的第一款32位cpu.</li>\n<li>Pentinum 4是intel的x86系列第一款64位cpu。</li>\n<li>满足1.具备n位宽的通用寄存器 2.具备n位以上的地址空间。 才真正被称为n位cpu。</li>\n<li>32位的cpu的通用寄存器的大小为32位，和指针大小相同，地址空间为无符号的32位整数可以指向的范围。64位一样。</li>\n<li>X86系列的CPU只要使用PAE(physical address extension)这样的机制，32位的CPU也可以操作36位范围的地址空间</li>\n</ul>\n</li>\n<li>指令集<br>不同的CPU都能够解释的机器语言体系称为指令集架构（ISA， instruction set architecture）,也可以简称指令集。<br>Intel 将x86系列CPU之中的32位CPU的指令集架构称为IA—32.IA(iIntel Architecture).</li>\n</ol>\n<p>\f</p>\n<h1 id=\"ELF文件的结构\"><a href=\"#ELF文件的结构\" class=\"headerlink\" title=\"ELF文件的结构\"></a>ELF文件的结构</h1><p>Linux使用ELF作为目标文件的格式。ELF格式被用于描述目标文件、可执行文件以及共享库的所有信息。<br>无论什么场合，使用ELF格式的目的只有一个，那就是把机器代码以及其对应的元数据以方便的链接器和加载器处理的形式保存起来。<br>代码的元数据包含如下的信息：</p>\n<ol>\n<li>代码文件的大小以及转换前的源代码文件名。</li>\n<li>符号<br>符号指的是变量或者函数的名称。简单的情况下直接使用原编程语言中的函数名或者变量名即可。有时候也会根据不同的编程语言进行特定的变换后得到的符号名称。这种变换称为名称重整。比如c++里的重载。</li>\n<li>重定位信息<br>重定位信息用于表示在链接完成前无法确定内存地址的代码位置信息。比如，在共享库内的函数，那么在最终链接完成后才能确定的其内存地址。在这种情况下，目标文件中就会留有“代码中这个位置的内存引用尚未确定”这样的信息。<br>这样的信息就是重定向信息。</li>\n<li>调试信息</li>\n</ol>\n<h2 id=\"ELF的节和段\"><a href=\"#ELF的节和段\" class=\"headerlink\" title=\"ELF的节和段\"></a>ELF的节和段</h2><p>ELF文件结构的二元结构。目的：为了兼顾链接器、汇编器等编译工具以及程序加载到内存中的加载器两者的易用性的需求。</p>\n<p>二元结构:如果以程序头信息来处理，则ELF文件可以解释为段集合。如果以节头信息来处理，则可以解释成节集合。</p>\n<table>\n<thead>\n<tr>\n<th>节</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ELF头</td>\n</tr>\n<tr>\n<td>程序头（描述段）</td>\n</tr>\n<tr>\n<td>.text节</td>\n</tr>\n<tr>\n<td>.rodata节</td>\n</tr>\n<tr>\n<td>.data节</td>\n</tr>\n<tr>\n<td>.got节</td>\n</tr>\n<tr>\n<td>.symtab节</td>\n</tr>\n<tr>\n<td>.strtab节</td>\n</tr>\n<tr>\n<td>节头（描述节）</td>\n</tr>\n</tbody>\n</table>\n<p>节（section）：是汇编器、链接器等处理ELF文件内容的单位。ELF文件把不同目的的代码、数据等分割成节保存。比如，机器码统一保存到.text节中。全局变量的初始化数据则保存在.data节中。</p>\n<p>段（segment）：则是把程序加载到内存的加载器处理ELF文件时的单位。段由1个以上的字节构成。内存上不同范围有着“只读”、“可写”、“可执行”等不同的属性。因而需要根据属性进行分段。比如机器码如果不可执行就毫无意义，因此要统一到具有可执行属性段中。</p>\n<p>目标文件的主要节</p>\n<table>\n<thead>\n<tr>\n<th>节名</th>\n<th style=\"text-align:left\">内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>.text节</td>\n<td style=\"text-align:left\">机器码。配置机器码的节，虽然叫text，但和文本文件没有关系。</td>\n</tr>\n<tr>\n<td>.rodata节</td>\n<td style=\"text-align:left\">读专用的.data。配置的字符串字面量等不能更新的数据</td>\n</tr>\n<tr>\n<td>.data节</td>\n<td style=\"text-align:left\">全局变量等。在文件中无大小信息。配置的是拥有初始值的全局变量等，这个节的数据在加载后有可能发生变更。</td>\n</tr>\n<tr>\n<td>.bss</td>\n<td style=\"text-align:left\">通用符号等。在文件中无大小信息。配置的是没有初始值的全局变量，并且加载到内存后，会被分配所有字节都初始化为0的内存空间。BSS是（Block Started by Symbol）。</td>\n</tr>\n<tr>\n<td>.rel.text节</td>\n<td style=\"text-align:left\">.text段中的符号的重定位信息</td>\n</tr>\n<tr>\n<td>.symtab节</td>\n<td style=\"text-align:left\">文件中包含的符号表。实际的字面量在.strtab节中保存</td>\n</tr>\n<tr>\n<td>.strtab节</td>\n<td style=\"text-align:left\">符号等字符串列表</td>\n</tr>\n<tr>\n<td>.shstrtab</td>\n<td style=\"text-align:left\">节名字符串列表</td>\n</tr>\n<tr>\n<td>.line</td>\n<td style=\"text-align:left\">代码和原始代码行号对照</td>\n</tr>\n<tr>\n<td>.debug</td>\n<td style=\"text-align:left\">调试用的符号信息</td>\n</tr>\n<tr>\n<td>.fini</td>\n<td style=\"text-align:left\">进程结束前执行的代码</td>\n</tr>\n<tr>\n<td>.fini_array</td>\n<td style=\"text-align:left\">进程结束前执行的函数的指针数组</td>\n</tr>\n<tr>\n<td>.init</td>\n<td style=\"text-align:left\">目标文件加载时执行的代码</td>\n</tr>\n<tr>\n<td>.init_array</td>\n<td style=\"text-align:left\">目标文件加载时执行的函数的指针数组</td>\n</tr>\n<tr>\n<td>.note</td>\n<td style=\"text-align:left\">用于保障兼容性等</td>\n</tr>\n</tbody>\n</table>\n<p>Linux下的 binutils包中包含readelf命令可以输出elf文件的结构。</p>\n<pre><code>1．    readelf –S hello #输出hello的节头信息。\n2．    readelf –l hello #查看hello的程序头。\n3．    readelf –s hello #输出符号表。\n</code></pre><p>gcc<br>    gcc – c main.c //在编译后中断build.<br>    -o 指定输出文件名。<br>    -v 详细输出其内部处理过程</p>\n<p>Linux下负责链接的程序是/usr/bin/ld，这个程序称为GNU ld,一般称为链接器。</p>\n<h2 id=\"链接器可处理的文件：\"><a href=\"#链接器可处理的文件：\" class=\"headerlink\" title=\"链接器可处理的文件：\"></a>链接器可处理的文件：</h2><table>\n<thead>\n<tr>\n<th>文件类型</th>\n<th style=\"text-align:center\">格式</th>\n<th style=\"text-align:center\">后缀名</th>\n<th style=\"text-align:left\">生成器</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>可重定位文件</td>\n<td style=\"text-align:center\">ELF</td>\n<td style=\"text-align:center\">.o</td>\n<td style=\"text-align:left\">汇编器</td>\n</tr>\n<tr>\n<td>可执行文件</td>\n<td style=\"text-align:center\">ELF</td>\n<td style=\"text-align:center\">无</td>\n<td style=\"text-align:left\">链接器</td>\n</tr>\n<tr>\n<td>共享库</td>\n<td style=\"text-align:center\">ELF</td>\n<td style=\"text-align:center\">.so</td>\n<td style=\"text-align:left\">链接器</td>\n</tr>\n<tr>\n<td>静态库</td>\n<td style=\"text-align:center\">UNIX ar</td>\n<td style=\"text-align:center\">.a</td>\n<td style=\"text-align:left\">ar命令</td>\n</tr>\n</tbody>\n</table>\n<p>可重定位文件指汇编器生成的目标文件(.o)。GNU as 生成的可重定位文件没有程序头，因此不能直接运行，只有配合链接器与其他可重定位文件、库产生连接后才可执行。</p>\n<p>可执行文件指的是链接生成的用户可直接运行的目标文件。Linux下可执行文件没有后缀名</p>\n<p>共享库是链接生成的另一种形式的目标文件，其中集合了各个函数、变量等供用户调用，因此需要能够再次和其他目标文件链接使用。共享库不会直接运行。共享库也叫动态链接库。Linux下的共享库文件名一般以lib开头，以.so作为后缀，并加上版本号。</p>\n<p>静态库文件可以作为链接器的输入。和共享库文件一样，静态库文件也集合了各种函数、变量供其它用户使用。一般以lib开头，以.a作为后缀。静态库文件利用ar命令把多个可重定位文件打包成一个，因此链接静态库文件就相当于链接其中打包的所有可重定位文件。</p>\n<h1 id=\"什么是链接\"><a href=\"#什么是链接\" class=\"headerlink\" title=\"什么是链接\"></a>什么是链接</h1><p>链接指的是把多个目标文件关联为一个整体。而通过关联多个目标文件，就可生成同时使用多个目标文件定义的变量、函数的程序。</p>\n<p>具体步骤：</p>\n<ol>\n<li>合并节</li>\n<li>重定位 </li>\n<li>符号相消</li>\n</ol>\n<p>此外，链接时还必须进行很多其他的处理。比如，在生成ELF文件时，需要为程序生成合适的程序头信息。不过归根到底，链接的主旨是关联目标文件，因此主要处理也就是上述三点。</p>\n<h2 id=\"合并节：\"><a href=\"#合并节：\" class=\"headerlink\" title=\"合并节：\"></a>合并节：</h2><p>在链接多个目标文件时，需要从各个目标文件中抽取节，把相同种类的节合并到一起。</p>\n<h2 id=\"重定位：\"><a href=\"#重定位：\" class=\"headerlink\" title=\"重定位：\"></a>重定位：</h2><p>指根据程序实际加载到内存时的地址，对目标文件中的代码和数据进行调整。<br>在链接文件时，根据整体情况决定“真实的”内存地址，把所有用虚拟内存地址的地方替换成真实的内存地址。这个处理就是重定位。</p>\n<h2 id=\"符号相消\"><a href=\"#符号相消\" class=\"headerlink\" title=\"符号相消\"></a>符号相消</h2><p>指为了可以使用其他目标文件和库文件中提供的变量和函数，把尚未和实体链接的符号与具体的变量和函数等实体链接起来的操作。例如：mian.c中有printf函数，汇编器会把“这个目标文件中使用的printf函数的函数体在其他文件中”这个信息保留下来。这个信息就是未定义的符号。接下来，再进行链接操作的时候，再检索未定义的符号，把相关的变量或者函数的内存地址链接进来。这个处理就是符号消解。</p>\n<p>符号相消和重定位联系紧密，比如上面的printf函数，编译mian.c时printf函数的地址是未知的，这时编译器为printf函数分配虚拟地址，并生成类似call printf的汇编指令，然后在链接时再把函数的内存地址修正为正确的地址。而这个“先设置虚拟地址，在链接时修正为正确的地址”的处理正是重定位操作，因此符号消解本身可以通过重定位来实现。<br>总体来说，像上面这样解释目标文件代码的含义，把目标文件从物理上、逻辑上连接起来，从而生成可执行文件的处理就是“链接”。</p>\n<h2 id=\"动态链接和静态链接\"><a href=\"#动态链接和静态链接\" class=\"headerlink\" title=\"动态链接和静态链接\"></a>动态链接和静态链接</h2><p>静态库在build，也就是执行ld命令的时候就会进行目标文件的链接，<br> 而共享库在build的时候不会进行目标文件的链接，而只是检查共享库和符号是否存在，在程序运行时才在内存上实际链接目标文件。<br>    其中，在build时链接目标文件的的链接操作称为静态链接。<br>    而在程序执行时链接目标文件的链接操作则称为动态链接。<br>    给链接器输入多个重定位文件时，这些文件被执行静态链接。<br>    动态链接有容易更新、节省磁盘空间、节省内存的优点。Linux下也主要使用共享库和动态链接。gcc也是如此，不加任何选项的话执行的动态链接，而静态库的静态链接只在个别情况下使用。缺点：性能稍差、链接具有不确定性。</p>\n<pre><code>Eg:\n动态链接：\ngcc –c main.c\ngcc –c f.c\ngcc main.o f.o –lc –o prog\n-l选项可以为链接指定库\nLdd prog  //查看是否被动态链接。\n\n静态链接：\ngcc –static main.o f.o –lc –o prog\nfile prog\n\n生成库\n\n生成静态库\n用ar生成静态库，和tar命令差不多\neg：$ ar crs libmy.a f.o g.o h.o\n选项\n含义\nc\n如果存档不存在，则创建\nr\n向存档添加文件\nS\n生成加速链接的索引\n\nLinux下优化执行时共享库的检索速度，加载器会对共享库的信息建立缓存文件。这个缓存文件就是 /etc/ld.so.cache。安装新版本的共享库时，一定要更新这个缓存文件，更新缓存文件的需要以管理员的权限运行ldconfig命令。\n\ngcc –c –fPIC f.c\ngcc –c –fPIC g.c\ngcc –share –WL, -soname, libfg.so.1 f.o g.o –o libfg.so.1\nfile libfg.so.1\n</code></pre><p>\f</p>\n<h1 id=\"加载程序\"><a href=\"#加载程序\" class=\"headerlink\" title=\"加载程序\"></a>加载程序</h1><p>利用mmap系统调用进行文件映射，把程序加载到内存中。所谓的映射，意思是可以通过读取内存直接获得文件的内容，也可以通过写内存对文件的内容进行修改</p>\n<p>在linux下，通过使用Proc文件系统，就可以表示进程利用mmap系统调用把文件映射到内存的范围信息。例如，利用cat /proc/44337/maps就可以表示44437进程中文件映射的信息。通过readelf –l /tmp/showmap 可以输出程序头。里面有elf段和内存空间的对应关系。<br>ELF文件中拥有实体的段都是通过mmap系统调用来加载的。不过进程的内存空间中也存在不和ELF文件对应的部分，比如，和.bss等节对应的空间、机器栈、堆。</p>\n<h2 id=\"动态链接的过程\"><a href=\"#动态链接的过程\" class=\"headerlink\" title=\"动态链接的过程\"></a>动态链接的过程</h2><p>目标文件的种类不同，加载ELF文件的主体也不同。程序由系统内核加载，共享库由动态链接加载器加载。</p>\n<p>动态链接加载器是指加载并链接动态链接的程序本身及其链接的共享库，设置程序运行状态的程序。Linux下常用的动态链接加载器是/lib/ld-linux.so.2。动态链接加载器的统称为ld.so。使用ELF文件的系统中，程序ELF文件的INTERP段需要指定动态链接加载器的路径。系统内核在启动程序时读入此段的内容，从而加载，启动程序。换句话说，动态链接器和动态链接加载器的运作过程并无二致。<br>从ld.so链接程序到程序的执行完毕过程。</p>\n<blockquote>\n<ol>\n<li>加载程序</li>\n<li>启动ld.so</li>\n<li>读入共享库</li>\n<li>符号相消和重定位</li>\n<li>初始化</li>\n<li>跳转到程序入口</li>\n<li>程序终止处理</li>\n</ol>\n</blockquote>\n<p>首先系统内核加载程序和ld.so，准备好运行环境后交由ld.so处理。完成启动的ld.so根据系统内核传递的参数进行初始化。接着读取程序的DYNAMIC段，加载所有可执行文件链接的共享库。对已经加载的共享库也执行同样的处理，递归加载所有的共享库。一旦加载完所需要的库，马上消解所有程序和代码库中的符号，并重定位代码。这样就完成了启动程序的准备工作。在执行了各个文件的初始化代码后，跳转到程序的入口，这样就启动了程序。在C语言程序中，也就是执行了main函数的意思。程序执行完毕后，最后会对每个文件执行终止处理，这样整个执行过程最终完成。 </p>\n<p>反汇编指的是从机器码恢复到汇编代码的过程。Linux上使用binutils包的objdump命令就可以反汇编一个程序，eg: objdump –d hello</p>\n<p>C语言中设定程序是从main函数开始执行，但实际上程序最初是从_start函数开始执行的。_start函数由lib提供的/usr/lib/crtl.o文件定义，ctrl.o在这个文件在编译时是默认链接的。_start函数会初始化libc，之后调用mian函数。</p>\n<p>执行终止处理，接下来从main函数返回，接着ld.so会执行终止处理代码。用于初始化的有.init节和.init_array节，相应的，终止处理有.fini节和.fini_array节。.fini节保存进程终止时的代码，而.fini_array则保存进程终止时执行的函数指针列表。程序执行完后，ld.so会调用exit系统调用终止进程。Exit系统调用和平时使用的exit函数不同。C语言调用exit系统调用时，调用的是_exit函数。_exit函数执行libc的终止处理代码（.fini节和.fini_array节）后，执行exit系统调用结束进程。而exit系统调用会跳过终止处理，立即结束进程。这就是ld.so所有处理过程。</p>\n<p>动态加载指的是在程序运行时指定共享库名称进行加载的方法。动态加载经常被用于实现所谓的插件。Linux中使用dlopen()函数进行动态加载。动态链接的程序最初一定已经加载了ld.so。而程序启动后它依然保存在内存上。因此只需要调用内存中的ld.so的代码，就可以在程序开始执行之后也能进行动态链接处理。</p>\n<p>地址无关代码指的是无论加载到那个地址，都不需要重定位也能运行的代码。共享库的代码一定要是地址无关的代码，这一点很重要共享库一定要设置为地址无关代码，是为了实现库共享。要实现地址无关的代码，必须改变两点：一是全局变量的访问，二是 外部函数的调用。</p>\n<p>访问全局变量的代码一定要把绝对地址改为相对地址。可以使用全局偏移表（GOT）的结构。GOT是指向全局变量的指针数组，链接器为其申请内存空间，动态链接加载器初始化其内容。地址无关代码就是通过 从这个GOT中读取地址而做到地址无关的。</p>\n<p>外部函数如何调用地址无关的代码。Linux下为了使函数调用地址独立，使用了一种可以称之为GOT的函数版的方法—过程链接表（PLT）。不过PLT一般比GOT的入口数多，因此会采取延迟初始化。也就是说，外部函数第一次调用该函数时，该函数才会被链接。</p>\n<p>地址无关的可执行文件（PIE）。指的是使用地址无关代码的可执行文件。因为地址无关，所以可以被加载到任意地址。 </p>\n"},{"title":"接口与抽象类","comments":1,"date":"2017-09-09T03:11:45.000Z","update":"2017-09-09T03:11:45.000Z","_content":"\n# 设计层面上的区别\n\n1. 接口是对动作的抽象，抽象类是对根源的抽象。抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。\n2. 抽象类主要用来抽象类别,接口主要用来抽象功能.当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。\n3. 抽象类是对事物的抽象（类的抽象），接口是对行为的抽象。**继承是一个 “是不是”的关系，而接口实现则是 “有没有”的关系**。\n\n\n抽象类是用来捕捉子类的通用特性的 。它不能被实例化，只能被用作子类的超类。抽象类是被用来创建继承层级里子类的模板。\n\n# 接口\n1. 接口是抽象方法的集合。如果一个类实现了某个接口，那么它就继承了这个接口的抽象方法。这就像**契约模式**，如果实现了这个接口，那么就必须确保使用这些方法。接口只是一种形式，接口自身不能做任何事情。\n2. 接口，在表面上是由几个没有主体代码的方法定义组成的集合体，有唯一的名称，可以被类或其他接口所实现。\n3. 接口是一组规则的集合，它规定了实现本接口的类或接口必须拥有的一组规则。体现了自然界“如果你是……则必须能……”的理念。\n4. 接口是在一定粒度视图上同类事物的抽象表示。注意这里我强调了在一定粒度视图上，因为“同类事物”这个概念是相对的，它因为粒度视图不同而不同。\n\n\n\n# 抽象类\n1. 抽象类里面的抽象方法必须全部被子类实现，如果子类不能全部实现，那么子类必须也是抽象类。接口里面的方法也必须全部被子类实现，如果子类不能实现那么子类必须是抽象类。\n抽象类中的方法都要被实现，所以抽象方法不能是静态的static，也不能是私有的private。\n2. 如果一个类里面有抽象方法，那么这个类一定是抽象类。抽象类里面可以没有抽象方法。\n\n\n\n\n## 抽象类中的修饰符\n抽象类中的抽象方法（其前有abstract修饰）不能用private、static、synchronized、native访问修饰符修饰。\n\n原因如下：\n\n1. 抽象方法没有方法体，是用来被继承的，所以不能用private修饰；\n2. static修饰的方法可以通过类名来访问该方法（即该方法的方法体），抽象方法用static修饰没有意义；\n3. 使用synchronized关键字是为该方法加一个锁。。而如果该关键字修饰的方法是static方法。则使用的锁就是class变量的锁。如果是修饰类方法。则用this变量锁。但是抽象类不能实例化对象，因为该方法不是在该抽象类中实现的。是在其子类实现的。所以。锁应该归其子类所有。所以。抽象方法也就不能用synchronized关键字修饰了；\n4. native，这个东西本身就和abstract冲突，他们都是方法的声明，只是一个吧方法实现移交给子类，另一个是移交给本地操作系统。如果同时出现，就相当于即把实现移交给子类，又把实现移交给本地操作系统，那到底谁来实现具体方法呢？\n\n\n## 接口修饰符：\n1. 接口中的变量会被隐式地指定为public static final变量（定义成其他类型，如private会报错），同时也意味着变量必须进行初始化。接口中的方法会被隐式地指定为public abstract方法（用其他关键字，比如private、protected、static、 final等会报错）\n2. 通俗的讲，你认为是要变化的东西，就放在你自己的实现中，不能放在接口中去，接口只是对一类事物的属性和行为更高层次的抽象。对修改关闭，对扩展（不同的实现 implements）开放，**接口是对开闭原则的一种体现**。\n3. 接口用于描述系统对外提供的所有服务,因此接口中的成员常量和方法都必须是公开(public)类型的,确保外部使用者能访问它们；\n4. 接口仅仅描述系统能做什么,但不指明如何去做,所以接口中的方法都是抽象(abstract)方法；\n接口不涉及和任何具体实例相关的细节,因此接口没有构造方法,不能被实例化,没有实例变量，只有静态（static）变量。\n5. 接口的中的变量是所有实现类共有的，既然共有，肯定是不变的东西，因为变化的东西也不能够算共有。所以变量是不可变(final)类型，也就是常量了。\n\n\n\n\n\n\n\n","source":"_posts/接口与抽象类.md","raw":"---\ntitle: 接口与抽象类\ncomments: true\ntags:\n  - 接口\n  - 抽象类\ncategories:\n  - JAVA\ndate: 2017-09-09 11:11:45\nupdate: 2017-09-09 11:11:45\n\n---\n\n# 设计层面上的区别\n\n1. 接口是对动作的抽象，抽象类是对根源的抽象。抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。\n2. 抽象类主要用来抽象类别,接口主要用来抽象功能.当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。\n3. 抽象类是对事物的抽象（类的抽象），接口是对行为的抽象。**继承是一个 “是不是”的关系，而接口实现则是 “有没有”的关系**。\n\n\n抽象类是用来捕捉子类的通用特性的 。它不能被实例化，只能被用作子类的超类。抽象类是被用来创建继承层级里子类的模板。\n\n# 接口\n1. 接口是抽象方法的集合。如果一个类实现了某个接口，那么它就继承了这个接口的抽象方法。这就像**契约模式**，如果实现了这个接口，那么就必须确保使用这些方法。接口只是一种形式，接口自身不能做任何事情。\n2. 接口，在表面上是由几个没有主体代码的方法定义组成的集合体，有唯一的名称，可以被类或其他接口所实现。\n3. 接口是一组规则的集合，它规定了实现本接口的类或接口必须拥有的一组规则。体现了自然界“如果你是……则必须能……”的理念。\n4. 接口是在一定粒度视图上同类事物的抽象表示。注意这里我强调了在一定粒度视图上，因为“同类事物”这个概念是相对的，它因为粒度视图不同而不同。\n\n\n\n# 抽象类\n1. 抽象类里面的抽象方法必须全部被子类实现，如果子类不能全部实现，那么子类必须也是抽象类。接口里面的方法也必须全部被子类实现，如果子类不能实现那么子类必须是抽象类。\n抽象类中的方法都要被实现，所以抽象方法不能是静态的static，也不能是私有的private。\n2. 如果一个类里面有抽象方法，那么这个类一定是抽象类。抽象类里面可以没有抽象方法。\n\n\n\n\n## 抽象类中的修饰符\n抽象类中的抽象方法（其前有abstract修饰）不能用private、static、synchronized、native访问修饰符修饰。\n\n原因如下：\n\n1. 抽象方法没有方法体，是用来被继承的，所以不能用private修饰；\n2. static修饰的方法可以通过类名来访问该方法（即该方法的方法体），抽象方法用static修饰没有意义；\n3. 使用synchronized关键字是为该方法加一个锁。。而如果该关键字修饰的方法是static方法。则使用的锁就是class变量的锁。如果是修饰类方法。则用this变量锁。但是抽象类不能实例化对象，因为该方法不是在该抽象类中实现的。是在其子类实现的。所以。锁应该归其子类所有。所以。抽象方法也就不能用synchronized关键字修饰了；\n4. native，这个东西本身就和abstract冲突，他们都是方法的声明，只是一个吧方法实现移交给子类，另一个是移交给本地操作系统。如果同时出现，就相当于即把实现移交给子类，又把实现移交给本地操作系统，那到底谁来实现具体方法呢？\n\n\n## 接口修饰符：\n1. 接口中的变量会被隐式地指定为public static final变量（定义成其他类型，如private会报错），同时也意味着变量必须进行初始化。接口中的方法会被隐式地指定为public abstract方法（用其他关键字，比如private、protected、static、 final等会报错）\n2. 通俗的讲，你认为是要变化的东西，就放在你自己的实现中，不能放在接口中去，接口只是对一类事物的属性和行为更高层次的抽象。对修改关闭，对扩展（不同的实现 implements）开放，**接口是对开闭原则的一种体现**。\n3. 接口用于描述系统对外提供的所有服务,因此接口中的成员常量和方法都必须是公开(public)类型的,确保外部使用者能访问它们；\n4. 接口仅仅描述系统能做什么,但不指明如何去做,所以接口中的方法都是抽象(abstract)方法；\n接口不涉及和任何具体实例相关的细节,因此接口没有构造方法,不能被实例化,没有实例变量，只有静态（static）变量。\n5. 接口的中的变量是所有实现类共有的，既然共有，肯定是不变的东西，因为变化的东西也不能够算共有。所以变量是不可变(final)类型，也就是常量了。\n\n\n\n\n\n\n\n","slug":"接口与抽象类","published":1,"updated":"2017-09-09T03:26:12.000Z","layout":"post","photos":[],"link":"","_id":"cjd4d1a0q0021ryx4mynxdnap","content":"<h1 id=\"设计层面上的区别\"><a href=\"#设计层面上的区别\" class=\"headerlink\" title=\"设计层面上的区别\"></a>设计层面上的区别</h1><ol>\n<li>接口是对动作的抽象，抽象类是对根源的抽象。抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。</li>\n<li>抽象类主要用来抽象类别,接口主要用来抽象功能.当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。</li>\n<li>抽象类是对事物的抽象（类的抽象），接口是对行为的抽象。<strong>继承是一个 “是不是”的关系，而接口实现则是 “有没有”的关系</strong>。</li>\n</ol>\n<p>抽象类是用来捕捉子类的通用特性的 。它不能被实例化，只能被用作子类的超类。抽象类是被用来创建继承层级里子类的模板。</p>\n<h1 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h1><ol>\n<li>接口是抽象方法的集合。如果一个类实现了某个接口，那么它就继承了这个接口的抽象方法。这就像<strong>契约模式</strong>，如果实现了这个接口，那么就必须确保使用这些方法。接口只是一种形式，接口自身不能做任何事情。</li>\n<li>接口，在表面上是由几个没有主体代码的方法定义组成的集合体，有唯一的名称，可以被类或其他接口所实现。</li>\n<li>接口是一组规则的集合，它规定了实现本接口的类或接口必须拥有的一组规则。体现了自然界“如果你是……则必须能……”的理念。</li>\n<li>接口是在一定粒度视图上同类事物的抽象表示。注意这里我强调了在一定粒度视图上，因为“同类事物”这个概念是相对的，它因为粒度视图不同而不同。</li>\n</ol>\n<h1 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h1><ol>\n<li>抽象类里面的抽象方法必须全部被子类实现，如果子类不能全部实现，那么子类必须也是抽象类。接口里面的方法也必须全部被子类实现，如果子类不能实现那么子类必须是抽象类。<br>抽象类中的方法都要被实现，所以抽象方法不能是静态的static，也不能是私有的private。</li>\n<li>如果一个类里面有抽象方法，那么这个类一定是抽象类。抽象类里面可以没有抽象方法。</li>\n</ol>\n<h2 id=\"抽象类中的修饰符\"><a href=\"#抽象类中的修饰符\" class=\"headerlink\" title=\"抽象类中的修饰符\"></a>抽象类中的修饰符</h2><p>抽象类中的抽象方法（其前有abstract修饰）不能用private、static、synchronized、native访问修饰符修饰。</p>\n<p>原因如下：</p>\n<ol>\n<li>抽象方法没有方法体，是用来被继承的，所以不能用private修饰；</li>\n<li>static修饰的方法可以通过类名来访问该方法（即该方法的方法体），抽象方法用static修饰没有意义；</li>\n<li>使用synchronized关键字是为该方法加一个锁。。而如果该关键字修饰的方法是static方法。则使用的锁就是class变量的锁。如果是修饰类方法。则用this变量锁。但是抽象类不能实例化对象，因为该方法不是在该抽象类中实现的。是在其子类实现的。所以。锁应该归其子类所有。所以。抽象方法也就不能用synchronized关键字修饰了；</li>\n<li>native，这个东西本身就和abstract冲突，他们都是方法的声明，只是一个吧方法实现移交给子类，另一个是移交给本地操作系统。如果同时出现，就相当于即把实现移交给子类，又把实现移交给本地操作系统，那到底谁来实现具体方法呢？</li>\n</ol>\n<h2 id=\"接口修饰符：\"><a href=\"#接口修饰符：\" class=\"headerlink\" title=\"接口修饰符：\"></a>接口修饰符：</h2><ol>\n<li>接口中的变量会被隐式地指定为public static final变量（定义成其他类型，如private会报错），同时也意味着变量必须进行初始化。接口中的方法会被隐式地指定为public abstract方法（用其他关键字，比如private、protected、static、 final等会报错）</li>\n<li>通俗的讲，你认为是要变化的东西，就放在你自己的实现中，不能放在接口中去，接口只是对一类事物的属性和行为更高层次的抽象。对修改关闭，对扩展（不同的实现 implements）开放，<strong>接口是对开闭原则的一种体现</strong>。</li>\n<li>接口用于描述系统对外提供的所有服务,因此接口中的成员常量和方法都必须是公开(public)类型的,确保外部使用者能访问它们；</li>\n<li>接口仅仅描述系统能做什么,但不指明如何去做,所以接口中的方法都是抽象(abstract)方法；<br>接口不涉及和任何具体实例相关的细节,因此接口没有构造方法,不能被实例化,没有实例变量，只有静态（static）变量。</li>\n<li>接口的中的变量是所有实现类共有的，既然共有，肯定是不变的东西，因为变化的东西也不能够算共有。所以变量是不可变(final)类型，也就是常量了。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"设计层面上的区别\"><a href=\"#设计层面上的区别\" class=\"headerlink\" title=\"设计层面上的区别\"></a>设计层面上的区别</h1><ol>\n<li>接口是对动作的抽象，抽象类是对根源的抽象。抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。</li>\n<li>抽象类主要用来抽象类别,接口主要用来抽象功能.当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。</li>\n<li>抽象类是对事物的抽象（类的抽象），接口是对行为的抽象。<strong>继承是一个 “是不是”的关系，而接口实现则是 “有没有”的关系</strong>。</li>\n</ol>\n<p>抽象类是用来捕捉子类的通用特性的 。它不能被实例化，只能被用作子类的超类。抽象类是被用来创建继承层级里子类的模板。</p>\n<h1 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h1><ol>\n<li>接口是抽象方法的集合。如果一个类实现了某个接口，那么它就继承了这个接口的抽象方法。这就像<strong>契约模式</strong>，如果实现了这个接口，那么就必须确保使用这些方法。接口只是一种形式，接口自身不能做任何事情。</li>\n<li>接口，在表面上是由几个没有主体代码的方法定义组成的集合体，有唯一的名称，可以被类或其他接口所实现。</li>\n<li>接口是一组规则的集合，它规定了实现本接口的类或接口必须拥有的一组规则。体现了自然界“如果你是……则必须能……”的理念。</li>\n<li>接口是在一定粒度视图上同类事物的抽象表示。注意这里我强调了在一定粒度视图上，因为“同类事物”这个概念是相对的，它因为粒度视图不同而不同。</li>\n</ol>\n<h1 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h1><ol>\n<li>抽象类里面的抽象方法必须全部被子类实现，如果子类不能全部实现，那么子类必须也是抽象类。接口里面的方法也必须全部被子类实现，如果子类不能实现那么子类必须是抽象类。<br>抽象类中的方法都要被实现，所以抽象方法不能是静态的static，也不能是私有的private。</li>\n<li>如果一个类里面有抽象方法，那么这个类一定是抽象类。抽象类里面可以没有抽象方法。</li>\n</ol>\n<h2 id=\"抽象类中的修饰符\"><a href=\"#抽象类中的修饰符\" class=\"headerlink\" title=\"抽象类中的修饰符\"></a>抽象类中的修饰符</h2><p>抽象类中的抽象方法（其前有abstract修饰）不能用private、static、synchronized、native访问修饰符修饰。</p>\n<p>原因如下：</p>\n<ol>\n<li>抽象方法没有方法体，是用来被继承的，所以不能用private修饰；</li>\n<li>static修饰的方法可以通过类名来访问该方法（即该方法的方法体），抽象方法用static修饰没有意义；</li>\n<li>使用synchronized关键字是为该方法加一个锁。。而如果该关键字修饰的方法是static方法。则使用的锁就是class变量的锁。如果是修饰类方法。则用this变量锁。但是抽象类不能实例化对象，因为该方法不是在该抽象类中实现的。是在其子类实现的。所以。锁应该归其子类所有。所以。抽象方法也就不能用synchronized关键字修饰了；</li>\n<li>native，这个东西本身就和abstract冲突，他们都是方法的声明，只是一个吧方法实现移交给子类，另一个是移交给本地操作系统。如果同时出现，就相当于即把实现移交给子类，又把实现移交给本地操作系统，那到底谁来实现具体方法呢？</li>\n</ol>\n<h2 id=\"接口修饰符：\"><a href=\"#接口修饰符：\" class=\"headerlink\" title=\"接口修饰符：\"></a>接口修饰符：</h2><ol>\n<li>接口中的变量会被隐式地指定为public static final变量（定义成其他类型，如private会报错），同时也意味着变量必须进行初始化。接口中的方法会被隐式地指定为public abstract方法（用其他关键字，比如private、protected、static、 final等会报错）</li>\n<li>通俗的讲，你认为是要变化的东西，就放在你自己的实现中，不能放在接口中去，接口只是对一类事物的属性和行为更高层次的抽象。对修改关闭，对扩展（不同的实现 implements）开放，<strong>接口是对开闭原则的一种体现</strong>。</li>\n<li>接口用于描述系统对外提供的所有服务,因此接口中的成员常量和方法都必须是公开(public)类型的,确保外部使用者能访问它们；</li>\n<li>接口仅仅描述系统能做什么,但不指明如何去做,所以接口中的方法都是抽象(abstract)方法；<br>接口不涉及和任何具体实例相关的细节,因此接口没有构造方法,不能被实例化,没有实例变量，只有静态（static）变量。</li>\n<li>接口的中的变量是所有实现类共有的，既然共有，肯定是不变的东西，因为变化的东西也不能够算共有。所以变量是不可变(final)类型，也就是常量了。</li>\n</ol>\n"},{"title":"设计原则与设计模式","comments":1,"date":"2017-09-09T03:27:08.000Z","update":"2017-09-09T03:27:08.000Z","_content":"\n# 六大设计原则\n## 一.单一职责原则\n单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。\n\n## 二.开闭原则\n开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。\n\n## 三.里氏替换原则\n里氏代换原则(Liskov Substitution Principle, LSP)：所有引用基类（父类）的地方必须能透明地使用其子类的对象。\n\n## 四.依赖倒置原则\n依赖倒转原则(Dependency Inversion  Principle, DIP)：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。\n\n## 五.接口隔离原则\n接口隔离原则(Interface  Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。\n\n## 六.迪米特法则\n迪米特法则(Law of  Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用。\n\n\n\n\n\n# 23种设计模式\n\n\n## 设计模式的分类\n\n总体来说设计模式分为三大类：\n\n1. 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。\n2. 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。\n3. 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。\n\n\n\n","source":"_posts/设计原则与设计模式.md","raw":"---\ntitle: 设计原则与设计模式\ncomments: true\ntags:\n  - 设计模式\ncategories:\n  - 设计模式\ndate: 2017-09-09 11:27:08\nupdate: 2017-09-09 11:27:08\n\n---\n\n# 六大设计原则\n## 一.单一职责原则\n单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。\n\n## 二.开闭原则\n开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。\n\n## 三.里氏替换原则\n里氏代换原则(Liskov Substitution Principle, LSP)：所有引用基类（父类）的地方必须能透明地使用其子类的对象。\n\n## 四.依赖倒置原则\n依赖倒转原则(Dependency Inversion  Principle, DIP)：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。\n\n## 五.接口隔离原则\n接口隔离原则(Interface  Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。\n\n## 六.迪米特法则\n迪米特法则(Law of  Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用。\n\n\n\n\n\n# 23种设计模式\n\n\n## 设计模式的分类\n\n总体来说设计模式分为三大类：\n\n1. 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。\n2. 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。\n3. 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。\n\n\n\n","slug":"设计原则与设计模式","published":1,"updated":"2017-09-09T03:30:15.000Z","layout":"post","photos":[],"link":"","_id":"cjd4d1a0s0025ryx4tlc50cx8","content":"<h1 id=\"六大设计原则\"><a href=\"#六大设计原则\" class=\"headerlink\" title=\"六大设计原则\"></a>六大设计原则</h1><h2 id=\"一-单一职责原则\"><a href=\"#一-单一职责原则\" class=\"headerlink\" title=\"一.单一职责原则\"></a>一.单一职责原则</h2><p>单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</p>\n<h2 id=\"二-开闭原则\"><a href=\"#二-开闭原则\" class=\"headerlink\" title=\"二.开闭原则\"></a>二.开闭原则</h2><p>开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</p>\n<h2 id=\"三-里氏替换原则\"><a href=\"#三-里氏替换原则\" class=\"headerlink\" title=\"三.里氏替换原则\"></a>三.里氏替换原则</h2><p>里氏代换原则(Liskov Substitution Principle, LSP)：所有引用基类（父类）的地方必须能透明地使用其子类的对象。</p>\n<h2 id=\"四-依赖倒置原则\"><a href=\"#四-依赖倒置原则\" class=\"headerlink\" title=\"四.依赖倒置原则\"></a>四.依赖倒置原则</h2><p>依赖倒转原则(Dependency Inversion  Principle, DIP)：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。</p>\n<h2 id=\"五-接口隔离原则\"><a href=\"#五-接口隔离原则\" class=\"headerlink\" title=\"五.接口隔离原则\"></a>五.接口隔离原则</h2><p>接口隔离原则(Interface  Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p>\n<h2 id=\"六-迪米特法则\"><a href=\"#六-迪米特法则\" class=\"headerlink\" title=\"六.迪米特法则\"></a>六.迪米特法则</h2><p>迪米特法则(Law of  Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用。</p>\n<h1 id=\"23种设计模式\"><a href=\"#23种设计模式\" class=\"headerlink\" title=\"23种设计模式\"></a>23种设计模式</h1><h2 id=\"设计模式的分类\"><a href=\"#设计模式的分类\" class=\"headerlink\" title=\"设计模式的分类\"></a>设计模式的分类</h2><p>总体来说设计模式分为三大类：</p>\n<ol>\n<li>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li>\n<li>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li>\n<li>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"六大设计原则\"><a href=\"#六大设计原则\" class=\"headerlink\" title=\"六大设计原则\"></a>六大设计原则</h1><h2 id=\"一-单一职责原则\"><a href=\"#一-单一职责原则\" class=\"headerlink\" title=\"一.单一职责原则\"></a>一.单一职责原则</h2><p>单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</p>\n<h2 id=\"二-开闭原则\"><a href=\"#二-开闭原则\" class=\"headerlink\" title=\"二.开闭原则\"></a>二.开闭原则</h2><p>开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</p>\n<h2 id=\"三-里氏替换原则\"><a href=\"#三-里氏替换原则\" class=\"headerlink\" title=\"三.里氏替换原则\"></a>三.里氏替换原则</h2><p>里氏代换原则(Liskov Substitution Principle, LSP)：所有引用基类（父类）的地方必须能透明地使用其子类的对象。</p>\n<h2 id=\"四-依赖倒置原则\"><a href=\"#四-依赖倒置原则\" class=\"headerlink\" title=\"四.依赖倒置原则\"></a>四.依赖倒置原则</h2><p>依赖倒转原则(Dependency Inversion  Principle, DIP)：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。</p>\n<h2 id=\"五-接口隔离原则\"><a href=\"#五-接口隔离原则\" class=\"headerlink\" title=\"五.接口隔离原则\"></a>五.接口隔离原则</h2><p>接口隔离原则(Interface  Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p>\n<h2 id=\"六-迪米特法则\"><a href=\"#六-迪米特法则\" class=\"headerlink\" title=\"六.迪米特法则\"></a>六.迪米特法则</h2><p>迪米特法则(Law of  Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用。</p>\n<h1 id=\"23种设计模式\"><a href=\"#23种设计模式\" class=\"headerlink\" title=\"23种设计模式\"></a>23种设计模式</h1><h2 id=\"设计模式的分类\"><a href=\"#设计模式的分类\" class=\"headerlink\" title=\"设计模式的分类\"></a>设计模式的分类</h2><p>总体来说设计模式分为三大类：</p>\n<ol>\n<li>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li>\n<li>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li>\n<li>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li>\n</ol>\n"},{"title":"程序员自我修养简记","comments":1,"date":"2017-03-05T11:08:29.000Z","update":"2017-03-05T11:08:29.000Z","_content":"\n# 计算机基础\n\n1. 对于系统程序开发者来说，计算机三个部件最为关键：CPU、内存、I/O控制芯片。\n2. 高速的北桥芯片：为了协调CPU、内存和高速的图形设备。此时慢速的I/O总线已经无法满足需求。\r3. 低速设备的南桥芯片：由于北桥芯片运行速度非常高，于是人们有设计了低速设备的南桥芯片，磁盘、usb、键盘、鼠标等设备都连接在南桥芯片上，由南桥芯片将他们汇总后链接到北桥上。\r4. SMP(对称多处理器)多CPU的计算机；简单的来讲就是每个CPU在系统中所处的地位和发挥的功能是一样的，是相互对称的。使用场景：大型数据库、网络服务器上，他们要求同时处理大量的请求，而这些请求时相互独立的，所以多处理器就可以最大效能的发挥作用。多处理器最多的应用场合时这些商用的服务器和需要处理大量计算的环境。（CPU频率碰到了天花板4GHZ,才出现了SMP）.\r5. 多核处理器：实际上就是SMP的简化版。这是由于多处理器成本高，所以厂商将多个处理器“合并在一起打包出售”，这些被打包的处理器之间共享比较昂贵的缓存部件，只保留多个核心；并且以一个处理器的外包装进行出售，价格比单核处理器只贵一点。当然他们在缓存共享方面有细微的差别，但是从程序员的角度来看，他们的区别很小，逻辑上看他们是完全相同的。\r6. 系统软件：传统意义上一般将用于管理计算机本身的软件称为系统软件，以区别普通的应用程序。系统软件可以分为两块；一块是平台性的，比如，操作系统内核、驱动程序、运行库和数以千记得系统工具；另一块是用于程序开发的，比如，编译器、链接器、汇编器等开发工具和开发库。\n7. 计算机系统软件体系结构采用一种层的结构：计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。\r8. 接口：每个层次之间都必须要相互通信，则需要一个通信协议，我们一般将其称为接口。接口下面那层是提供者，上层是使用者。除了硬件和应用程序，其他层都是中间层，每个中间层都是对它下面的那层的包装与扩展。正是由于这些中间层的存在，使得应用程序和硬件之间保持相对独立。\r\r9. 在软件体系结构中：位于最高层的是应用程序。从整个层次结构上来看，开发工具与应用程序属于同一层，因为他们都使用同一接口，那就是操作系统应用程序编程接口。应用程序接口的提供者是运行库。\r运行库使用操作系统提供的系统调用接口，系统调用接口往往以软中断的方式提供；比如，linux使用0x80号中断作为系统调用接口。\r硬件规格: 操作系统内核层对于硬件层来说是硬件接口的使用者，而硬件是接口的定义者，硬件的接口的定义决定了操作系统的内核，具体来讲就是驱动程序如何操作硬件，如何与硬件通讯，这种接口被叫做硬件规格。\r\r10. 操作系统：一个功能是提供抽象的接口，另外一个主要功能就是管理硬件资源。\r11. 多道程序的设计：编写一个监控程序，当某个程序暂时无需使用CPU时，监控程序就把另外的正在等待CPU资源的程序启动起来，使得CPU能够充分利用起来，这种被称为多到程序。\r12. 分时系统：每个程序运行一段时间后都主动让出CPU给其他的程序，使得一段时间内每个程序都有机会运行一小段时间。\r13. 多任务系统：操作系统接管了所有的硬件资源，并且本身运行在一个受硬件保护的级别，每个进程都有自己的独立空间，使得进程之间的地址相互隔离。CPU由操作系统同一分配，每个进程都会根据进程优先级的高低都有机会得到CPU.但是，如果运行超出了一定的时间，操作系统会暂停该进程，将CPU资源分配给其他的等待运行的进程，这种CPU分配方式为抢占式。\r14. 驱动程序可以看做事操作系统的一部分，它往往和系统内核一起运行在特权级别，但他与操作系统内核之间有一定的独立性，使得驱动程序有较好的灵活性。操作系统开发者为硬件生产商提供了一系列接口和框架，凡是按照这个接口和框架开发的驱动程序都可以在该操作系统上使用。\r15. 进程的总体目标是希望每个进程从逻辑上看都可以独占计算机的资源。操作系统的多任务功能使得CPU能够在多个进程之间共享；从进程的角度看好像是他独占了CPU而不用考虑与其他进程分享CPU的事。操作系统的I/O抽象模型也很好的实现I/O设备的共享和抽象。内存通过虚拟地址空间；分段分页来实现共享。\r\t\t\r# 为什么要虚拟内存：\n\n如果程序直接在物理内存上使用，直接访问物理地址将带来很多问题：\n\r 1.\t地址空间不隔离：所有程序都访问物理地址，程序所使用的内存空间不相互隔离，恶意的程序可以很容易改写其他程序的内存数据，以达到破坏的目的。有些非恶意、但有臭虫的程序可能不小心修改ill其他程序的数据，就会使其他程序崩溃。而使用虚拟地址空间可保证一个任务的失败不影响其他任务的执行。\r 2.\t内存使用效率低：由于没有有效的内存管理机制，通常需要一个程序执行时，监控程序就将整个程序装载进内存然后执行。内存不够时会发生大量的数据交换，效率低下。\r 3.\t程序运行的地址不稳定：因为程序每次需要装入运行时，我们都需要给他从内存中分配一块足够大的内存空间区域，这个区域位置不确定；这给程序的编写造成一定的麻烦，因为程序在编写时，它访问的数据和指令跳转时的目标地址很多都市固定的，这涉及到重定位问题。\r\r解决问题的思路就是增加中间层，即使用一种间接地址访问方法。我们把程序给出的地址看作是一种虚拟地址，然后通过某种映射，将虚拟地址转 换为物理地址。这样，只要我们能够妥善控制这个虚拟地址到物理地址的映射过程，就可以保证任意一个程序所能够访问的物理内存区域跟另一个程序相互不重叠，以达到地址空间隔离的效果。物理地址空间是真真实实存在的；虚拟地址空间是指虚拟的，而且每个进程只能访问自己的地址空间，这样就有效的做到了进程的隔离。\r\r## 分段：\n\n解决了第一个和第三个问题。首先，它做到了地址的隔离，如果程序访问越界，将会被硬件判断为非法访问，拒绝这个地址请求，并将这个请求报告给操作系统或者监控程序。再者，对于每个程序员来说，无论他们被分配到物理地址的那个区域，对于程序来说都是透明的。他们不需要关心物理地址的变化。\t但分段没有解决内存使用效率问题；分段对内存区域的映射还是按照程序为单位；如果内存不足，被换入换出到磁盘的都是整个程序，这样势必会造成大量的磁盘访问操作，从而严重影响速度。这种方法换是显得比较粗糙，粒度比较大。\t\r事实上，根据程序的局部性原理，当一个程序在运行时，在某个段内，它只是频繁的用到一小部分数据，也就是说，程序的很多数据其实在一段时间内都是不会被用到的。人们很自然的想到了更小粒度的内存分割和映射的方法，使得程序的局部性原理得到充分的利用，大大提高了内存使用率，这种方法就是分页。\r##\t 分页：\n提高了内存的使用率，减少了内存碎片的产生；保护也是页映射的目的之一。简单来说就是每个页可以设置权限属性，只有操作系统有权限修改这些属性。MMU都集成在CPU的内部了，不会以独立的部件存在。\r\r\r# 线程基础\n\r线程：有时被称为轻量级的进程（LWP）,是程序执行流的最小单位。一个标准的线程是由线程ID\\当前指令指针（PC）、寄存器集合和堆栈组成。通常意义上，一个进程由一到多个线程组成，各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）以及一些进程级的资源（打开的文件和信号）。\n\t\r使用多线程的原因：\r 1.\t某个操作可能会陷入长时间的等待，等待的线程会进入睡眠状态，无法继续执行，多线程执行可以有效的利用等待的时间。典型的例子是等待网络响应，这可能要花费数秒。\r 2.\t某个操作（计算）会消耗大量的时间，如果只有一个线程，程序和用户之间的交互会中断。多线程可以让一个线程负责交互，另一个线程负责计算。\r 3.\t程序本身就要求并发操作。、\r 4.\t多CPU或多核计算机，本身具备同时执行多个线程的能力，因此单个线程程序无法全面的发挥计算机的全部计算能力。\r 5.\t相对于多进程应用，多线程在数据共享方面效率要高得多。\r\r# 线程的访问权限\n\r线程的访问非常自由，它可以访问进程内存空间内的所有数据，甚至包括其他线程的堆栈（如果他知道其他线程的堆栈地址，这是很少见的情况），但实际运用中线程也拥有自己的私有存储空间：\n\t\r 1.\t栈：尽管并非完全无法被其他线程访问，但一般情况下仍然可以认为是私有数据。\r 2.\t线程局部存储，是某些操作系统为线程单独提供的私有空间，但通常只具有很有限的容量。\r 3.\t寄存器：寄存器是执行流的基本数据，因此为线程私有。\r\r# 从C程序员的角度看，数据在线程之间是否私有：\r\r私有：局部变量、函数参数、TLS线程局部存储数据\r\t\n线程之间共享进程所有：全局变量、堆上的数据、函数里的静态变量、程序代码，任何程序都有权读取并执行任何代码、打开的文件。\r\t\r线程调度：一个不断在处理器上切换不同线程的的行为。线程通常至少拥有三种状态：运行、就绪、等待。\r\t\nIO密集型线程：频繁等待的线程；CPU密集型线程：很少等待的线程；IO密集型的线程总比cpu密集型的线程容易得到优先级的提升。\r\t\r\r对于linux来说，线程并不是一个通用的概念；linux对多线程支持颇为贫乏；事实上，在linux内核中并不存在真正意义上的线程的概念。Linux将所有可执行的实体称为任务（TASK）,无论是进程换是线程。每一个任务概念上都类似于一个单进程的线程，具有内存空间、执行实体、文件资源。不过，linux下不同任务之间可以选择共享内存空间，因而在实际意义上，共享同一个内存空间的多个任务构成了一个进程，这些任务也就成为了这个进程里的线程。在linux下，用以下方法可以创建一个新的任务。\n\r| 系统调用 | 作用 |  效果 |\n|---|:--|:--|\r| fork | 复制当前进程 | 新的任务启动并和本任务一起从fork返回，本任务返回的是新任务的pid,新任务返回0。Fork速度非常快，因为采用了写时复制。Fork只能产生本任务的镜像。| \r| exec | 使用新的可执行映像覆盖当前可执行映像 | Fork+exec启动别的新任务。|\r| Clone | 创建子进程并从指定位置开始执行 |  产生新的线程使用clone。从指定的位置开始执行，并且（可选）共享当前的内存空间和文件等。如此就可以在实际效果上产生一个线程。|\r\r# 线程安全\n\r同步：为了避免多个线程同时读写同一个数据而产生不可预料的结果，我们需要将各个线程对同一个数据的访问同步。所谓的同步，既是指在一个线程访问数据未结束的时候，其他线程不得对同一个数据进行访问。如此，对数据的访问被原子化了。\r同步的方式：\n\r1.\t锁、\r2.\t二元信号量、（多元）信号量（对于允许多个线程并发访问的资源，它是一个很好的选择；一个初始值为n的信号量允许N个线程并发访问。）\r3.\t互斥量：和二元信号量很类似，资源进同时只能被一个线程访问。不同的是，信号量在整个系统可以被任意线程获取并释放。而互斥量则要求那个线程获取了互斥量，那个线程就要负责释放这个锁。\r4.\t临界区：是比互斥量更加严格的同步手段。把临界区的锁获取称为进入临界区，释放称为离开临界区。临界区和互斥量与信号量的区别在于，互斥量和信号量在系统的任何进程里都是可见的，也就是说，一个进程创建了一个互斥量或者信号量，另一个进程试图获取该锁是合法的。然而，临界区的作用范围仅限于本进程，其他进程无法获取该锁。除此之外，临界区胡互斥量具有相同的性质。\r5.\t读写锁：适用于读频繁写少的情况。对于一段数据，多个线程同时读取总是没有问题的，写时必须上锁。\r6.\t条件变量：作用类似一个栅栏。线程有两种操作，等待与唤醒。使用条件变量可以让许多线程一起等待某个事件的发生，当时间发生时，条件变量被唤醒，所有的线程可以一起恢复执行。\r\r# 可重入与线程安全\n\r一个函数要被重入只有两种情况：一是多个线程同时执行这个函数；二是函数自身调用自身。一个函数被重入表示这个函数没有被执行完成，由于外部因素或者内部调用，又一次进入函数执行。一个函数可重入，表明函数重入后不会产生任何不良的后果。一个函数要成为可重入的，必须具有\n\n如下几个特点：\n\t\r1.\t不使用任何（局部）静态或全局的非const变量。\r2.\t不返回任何（局部）静态或者全局的非const变量的指针。\r3.\t仅依赖于调用方提供的参数。\r4.\t不依赖任何单个资源的锁。\r5.\t不调用任何可重入的函数。\n\r可重入是并发的强力保障，一个可重入的函数可以在多线程环境下放心使用。\r\r## 过度优化\n\rVolatile关键字:一是阻止编译器为了提高速度将一个变量缓存到寄存器中而不写回；二是阻止编译器调整volatile变量的指令顺序。\rBarrier：因为即使volatile可以阻止编译器调整顺序，也无法阻止CPU动态调度换序。现在并不存在可移植的阻止换序的方法。通常情况下是通过调用CPU提供的一条指令，这条指令被称为barrier。它可以阻止cpu将该指令之前的指令交换到它之后，反之亦然。Barrier指令的作用类似于一个拦水坝，阻止换序穿透这个大坝。\r\r# 三种线程模型\n\rWindows和linux，都是在内核里提供线程的支持。内核线程，这里的内核线程和linux内核里的kernel_thread并不是一回事，它和我们之前讨论的一样，由多个处理器或调度器来实现并发。然而用户实际使用的的线程不是内核线程，而是存在于用户态的用户线程。用户线程并不一定在操作系统内核内对应着同样数量的内核线程。\r用户态多线程库的实现\n\r1. 一对一模型：用户线程具有和内核线程一致的优点，线程之间的并发，是真正的并发。一个线程阻塞，其他线程不会受到影响。一对一模型可以让多线程程序在多处理器的系统上有跟好的体现。一般直接使用API或系统调用创建的线程均为一对一的线程。\n\n>缺点：一是由于许多操作系统限制了内核线程的数量，因此一对一线程会让用户的线程数量受到限制。二是许多操作系统内核线程调度时，上下文切换开销大，导致用户线程的执行效率下降。\n\r2. 多对一模型：线程间的切换由用户态的代码来进行，线程切换的速度要快许多，但是一个用户线程阻塞，那么所有线程都将无法执行，因此此时内核里的线程也随之阻塞了。多对一模型的好处就是高效的上下文切换和几乎无限制的线程数量。\r3. 多对多模型：一个用户线程阻塞并不会使得所有用户线程阻塞，因为此时还有别的线程可以被调度来执行。另外，多对多模型对用户线程的数量没有什么限制，在多处理器上，线程也能得到一定性能的提升。\r","source":"_posts/程序员自我修养简记.md","raw":"---\ntitle: 程序员自我修养简记\ncomments: true\ntags:\n  - LINUX\n  - 程序员自我修养\ncategories:\n  - LINUX\ndate: 2017-03-05 19:08:29\nupdate: 2017-03-05 19:08:29\n---\n\n# 计算机基础\n\n1. 对于系统程序开发者来说，计算机三个部件最为关键：CPU、内存、I/O控制芯片。\n2. 高速的北桥芯片：为了协调CPU、内存和高速的图形设备。此时慢速的I/O总线已经无法满足需求。\r3. 低速设备的南桥芯片：由于北桥芯片运行速度非常高，于是人们有设计了低速设备的南桥芯片，磁盘、usb、键盘、鼠标等设备都连接在南桥芯片上，由南桥芯片将他们汇总后链接到北桥上。\r4. SMP(对称多处理器)多CPU的计算机；简单的来讲就是每个CPU在系统中所处的地位和发挥的功能是一样的，是相互对称的。使用场景：大型数据库、网络服务器上，他们要求同时处理大量的请求，而这些请求时相互独立的，所以多处理器就可以最大效能的发挥作用。多处理器最多的应用场合时这些商用的服务器和需要处理大量计算的环境。（CPU频率碰到了天花板4GHZ,才出现了SMP）.\r5. 多核处理器：实际上就是SMP的简化版。这是由于多处理器成本高，所以厂商将多个处理器“合并在一起打包出售”，这些被打包的处理器之间共享比较昂贵的缓存部件，只保留多个核心；并且以一个处理器的外包装进行出售，价格比单核处理器只贵一点。当然他们在缓存共享方面有细微的差别，但是从程序员的角度来看，他们的区别很小，逻辑上看他们是完全相同的。\r6. 系统软件：传统意义上一般将用于管理计算机本身的软件称为系统软件，以区别普通的应用程序。系统软件可以分为两块；一块是平台性的，比如，操作系统内核、驱动程序、运行库和数以千记得系统工具；另一块是用于程序开发的，比如，编译器、链接器、汇编器等开发工具和开发库。\n7. 计算机系统软件体系结构采用一种层的结构：计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。\r8. 接口：每个层次之间都必须要相互通信，则需要一个通信协议，我们一般将其称为接口。接口下面那层是提供者，上层是使用者。除了硬件和应用程序，其他层都是中间层，每个中间层都是对它下面的那层的包装与扩展。正是由于这些中间层的存在，使得应用程序和硬件之间保持相对独立。\r\r9. 在软件体系结构中：位于最高层的是应用程序。从整个层次结构上来看，开发工具与应用程序属于同一层，因为他们都使用同一接口，那就是操作系统应用程序编程接口。应用程序接口的提供者是运行库。\r运行库使用操作系统提供的系统调用接口，系统调用接口往往以软中断的方式提供；比如，linux使用0x80号中断作为系统调用接口。\r硬件规格: 操作系统内核层对于硬件层来说是硬件接口的使用者，而硬件是接口的定义者，硬件的接口的定义决定了操作系统的内核，具体来讲就是驱动程序如何操作硬件，如何与硬件通讯，这种接口被叫做硬件规格。\r\r10. 操作系统：一个功能是提供抽象的接口，另外一个主要功能就是管理硬件资源。\r11. 多道程序的设计：编写一个监控程序，当某个程序暂时无需使用CPU时，监控程序就把另外的正在等待CPU资源的程序启动起来，使得CPU能够充分利用起来，这种被称为多到程序。\r12. 分时系统：每个程序运行一段时间后都主动让出CPU给其他的程序，使得一段时间内每个程序都有机会运行一小段时间。\r13. 多任务系统：操作系统接管了所有的硬件资源，并且本身运行在一个受硬件保护的级别，每个进程都有自己的独立空间，使得进程之间的地址相互隔离。CPU由操作系统同一分配，每个进程都会根据进程优先级的高低都有机会得到CPU.但是，如果运行超出了一定的时间，操作系统会暂停该进程，将CPU资源分配给其他的等待运行的进程，这种CPU分配方式为抢占式。\r14. 驱动程序可以看做事操作系统的一部分，它往往和系统内核一起运行在特权级别，但他与操作系统内核之间有一定的独立性，使得驱动程序有较好的灵活性。操作系统开发者为硬件生产商提供了一系列接口和框架，凡是按照这个接口和框架开发的驱动程序都可以在该操作系统上使用。\r15. 进程的总体目标是希望每个进程从逻辑上看都可以独占计算机的资源。操作系统的多任务功能使得CPU能够在多个进程之间共享；从进程的角度看好像是他独占了CPU而不用考虑与其他进程分享CPU的事。操作系统的I/O抽象模型也很好的实现I/O设备的共享和抽象。内存通过虚拟地址空间；分段分页来实现共享。\r\t\t\r# 为什么要虚拟内存：\n\n如果程序直接在物理内存上使用，直接访问物理地址将带来很多问题：\n\r 1.\t地址空间不隔离：所有程序都访问物理地址，程序所使用的内存空间不相互隔离，恶意的程序可以很容易改写其他程序的内存数据，以达到破坏的目的。有些非恶意、但有臭虫的程序可能不小心修改ill其他程序的数据，就会使其他程序崩溃。而使用虚拟地址空间可保证一个任务的失败不影响其他任务的执行。\r 2.\t内存使用效率低：由于没有有效的内存管理机制，通常需要一个程序执行时，监控程序就将整个程序装载进内存然后执行。内存不够时会发生大量的数据交换，效率低下。\r 3.\t程序运行的地址不稳定：因为程序每次需要装入运行时，我们都需要给他从内存中分配一块足够大的内存空间区域，这个区域位置不确定；这给程序的编写造成一定的麻烦，因为程序在编写时，它访问的数据和指令跳转时的目标地址很多都市固定的，这涉及到重定位问题。\r\r解决问题的思路就是增加中间层，即使用一种间接地址访问方法。我们把程序给出的地址看作是一种虚拟地址，然后通过某种映射，将虚拟地址转 换为物理地址。这样，只要我们能够妥善控制这个虚拟地址到物理地址的映射过程，就可以保证任意一个程序所能够访问的物理内存区域跟另一个程序相互不重叠，以达到地址空间隔离的效果。物理地址空间是真真实实存在的；虚拟地址空间是指虚拟的，而且每个进程只能访问自己的地址空间，这样就有效的做到了进程的隔离。\r\r## 分段：\n\n解决了第一个和第三个问题。首先，它做到了地址的隔离，如果程序访问越界，将会被硬件判断为非法访问，拒绝这个地址请求，并将这个请求报告给操作系统或者监控程序。再者，对于每个程序员来说，无论他们被分配到物理地址的那个区域，对于程序来说都是透明的。他们不需要关心物理地址的变化。\t但分段没有解决内存使用效率问题；分段对内存区域的映射还是按照程序为单位；如果内存不足，被换入换出到磁盘的都是整个程序，这样势必会造成大量的磁盘访问操作，从而严重影响速度。这种方法换是显得比较粗糙，粒度比较大。\t\r事实上，根据程序的局部性原理，当一个程序在运行时，在某个段内，它只是频繁的用到一小部分数据，也就是说，程序的很多数据其实在一段时间内都是不会被用到的。人们很自然的想到了更小粒度的内存分割和映射的方法，使得程序的局部性原理得到充分的利用，大大提高了内存使用率，这种方法就是分页。\r##\t 分页：\n提高了内存的使用率，减少了内存碎片的产生；保护也是页映射的目的之一。简单来说就是每个页可以设置权限属性，只有操作系统有权限修改这些属性。MMU都集成在CPU的内部了，不会以独立的部件存在。\r\r\r# 线程基础\n\r线程：有时被称为轻量级的进程（LWP）,是程序执行流的最小单位。一个标准的线程是由线程ID\\当前指令指针（PC）、寄存器集合和堆栈组成。通常意义上，一个进程由一到多个线程组成，各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）以及一些进程级的资源（打开的文件和信号）。\n\t\r使用多线程的原因：\r 1.\t某个操作可能会陷入长时间的等待，等待的线程会进入睡眠状态，无法继续执行，多线程执行可以有效的利用等待的时间。典型的例子是等待网络响应，这可能要花费数秒。\r 2.\t某个操作（计算）会消耗大量的时间，如果只有一个线程，程序和用户之间的交互会中断。多线程可以让一个线程负责交互，另一个线程负责计算。\r 3.\t程序本身就要求并发操作。、\r 4.\t多CPU或多核计算机，本身具备同时执行多个线程的能力，因此单个线程程序无法全面的发挥计算机的全部计算能力。\r 5.\t相对于多进程应用，多线程在数据共享方面效率要高得多。\r\r# 线程的访问权限\n\r线程的访问非常自由，它可以访问进程内存空间内的所有数据，甚至包括其他线程的堆栈（如果他知道其他线程的堆栈地址，这是很少见的情况），但实际运用中线程也拥有自己的私有存储空间：\n\t\r 1.\t栈：尽管并非完全无法被其他线程访问，但一般情况下仍然可以认为是私有数据。\r 2.\t线程局部存储，是某些操作系统为线程单独提供的私有空间，但通常只具有很有限的容量。\r 3.\t寄存器：寄存器是执行流的基本数据，因此为线程私有。\r\r# 从C程序员的角度看，数据在线程之间是否私有：\r\r私有：局部变量、函数参数、TLS线程局部存储数据\r\t\n线程之间共享进程所有：全局变量、堆上的数据、函数里的静态变量、程序代码，任何程序都有权读取并执行任何代码、打开的文件。\r\t\r线程调度：一个不断在处理器上切换不同线程的的行为。线程通常至少拥有三种状态：运行、就绪、等待。\r\t\nIO密集型线程：频繁等待的线程；CPU密集型线程：很少等待的线程；IO密集型的线程总比cpu密集型的线程容易得到优先级的提升。\r\t\r\r对于linux来说，线程并不是一个通用的概念；linux对多线程支持颇为贫乏；事实上，在linux内核中并不存在真正意义上的线程的概念。Linux将所有可执行的实体称为任务（TASK）,无论是进程换是线程。每一个任务概念上都类似于一个单进程的线程，具有内存空间、执行实体、文件资源。不过，linux下不同任务之间可以选择共享内存空间，因而在实际意义上，共享同一个内存空间的多个任务构成了一个进程，这些任务也就成为了这个进程里的线程。在linux下，用以下方法可以创建一个新的任务。\n\r| 系统调用 | 作用 |  效果 |\n|---|:--|:--|\r| fork | 复制当前进程 | 新的任务启动并和本任务一起从fork返回，本任务返回的是新任务的pid,新任务返回0。Fork速度非常快，因为采用了写时复制。Fork只能产生本任务的镜像。| \r| exec | 使用新的可执行映像覆盖当前可执行映像 | Fork+exec启动别的新任务。|\r| Clone | 创建子进程并从指定位置开始执行 |  产生新的线程使用clone。从指定的位置开始执行，并且（可选）共享当前的内存空间和文件等。如此就可以在实际效果上产生一个线程。|\r\r# 线程安全\n\r同步：为了避免多个线程同时读写同一个数据而产生不可预料的结果，我们需要将各个线程对同一个数据的访问同步。所谓的同步，既是指在一个线程访问数据未结束的时候，其他线程不得对同一个数据进行访问。如此，对数据的访问被原子化了。\r同步的方式：\n\r1.\t锁、\r2.\t二元信号量、（多元）信号量（对于允许多个线程并发访问的资源，它是一个很好的选择；一个初始值为n的信号量允许N个线程并发访问。）\r3.\t互斥量：和二元信号量很类似，资源进同时只能被一个线程访问。不同的是，信号量在整个系统可以被任意线程获取并释放。而互斥量则要求那个线程获取了互斥量，那个线程就要负责释放这个锁。\r4.\t临界区：是比互斥量更加严格的同步手段。把临界区的锁获取称为进入临界区，释放称为离开临界区。临界区和互斥量与信号量的区别在于，互斥量和信号量在系统的任何进程里都是可见的，也就是说，一个进程创建了一个互斥量或者信号量，另一个进程试图获取该锁是合法的。然而，临界区的作用范围仅限于本进程，其他进程无法获取该锁。除此之外，临界区胡互斥量具有相同的性质。\r5.\t读写锁：适用于读频繁写少的情况。对于一段数据，多个线程同时读取总是没有问题的，写时必须上锁。\r6.\t条件变量：作用类似一个栅栏。线程有两种操作，等待与唤醒。使用条件变量可以让许多线程一起等待某个事件的发生，当时间发生时，条件变量被唤醒，所有的线程可以一起恢复执行。\r\r# 可重入与线程安全\n\r一个函数要被重入只有两种情况：一是多个线程同时执行这个函数；二是函数自身调用自身。一个函数被重入表示这个函数没有被执行完成，由于外部因素或者内部调用，又一次进入函数执行。一个函数可重入，表明函数重入后不会产生任何不良的后果。一个函数要成为可重入的，必须具有\n\n如下几个特点：\n\t\r1.\t不使用任何（局部）静态或全局的非const变量。\r2.\t不返回任何（局部）静态或者全局的非const变量的指针。\r3.\t仅依赖于调用方提供的参数。\r4.\t不依赖任何单个资源的锁。\r5.\t不调用任何可重入的函数。\n\r可重入是并发的强力保障，一个可重入的函数可以在多线程环境下放心使用。\r\r## 过度优化\n\rVolatile关键字:一是阻止编译器为了提高速度将一个变量缓存到寄存器中而不写回；二是阻止编译器调整volatile变量的指令顺序。\rBarrier：因为即使volatile可以阻止编译器调整顺序，也无法阻止CPU动态调度换序。现在并不存在可移植的阻止换序的方法。通常情况下是通过调用CPU提供的一条指令，这条指令被称为barrier。它可以阻止cpu将该指令之前的指令交换到它之后，反之亦然。Barrier指令的作用类似于一个拦水坝，阻止换序穿透这个大坝。\r\r# 三种线程模型\n\rWindows和linux，都是在内核里提供线程的支持。内核线程，这里的内核线程和linux内核里的kernel_thread并不是一回事，它和我们之前讨论的一样，由多个处理器或调度器来实现并发。然而用户实际使用的的线程不是内核线程，而是存在于用户态的用户线程。用户线程并不一定在操作系统内核内对应着同样数量的内核线程。\r用户态多线程库的实现\n\r1. 一对一模型：用户线程具有和内核线程一致的优点，线程之间的并发，是真正的并发。一个线程阻塞，其他线程不会受到影响。一对一模型可以让多线程程序在多处理器的系统上有跟好的体现。一般直接使用API或系统调用创建的线程均为一对一的线程。\n\n>缺点：一是由于许多操作系统限制了内核线程的数量，因此一对一线程会让用户的线程数量受到限制。二是许多操作系统内核线程调度时，上下文切换开销大，导致用户线程的执行效率下降。\n\r2. 多对一模型：线程间的切换由用户态的代码来进行，线程切换的速度要快许多，但是一个用户线程阻塞，那么所有线程都将无法执行，因此此时内核里的线程也随之阻塞了。多对一模型的好处就是高效的上下文切换和几乎无限制的线程数量。\r3. 多对多模型：一个用户线程阻塞并不会使得所有用户线程阻塞，因为此时还有别的线程可以被调度来执行。另外，多对多模型对用户线程的数量没有什么限制，在多处理器上，线程也能得到一定性能的提升。\r","slug":"程序员自我修养简记","published":1,"updated":"2017-09-02T10:11:18.000Z","layout":"post","photos":[],"link":"","_id":"cjd4d1a0s0027ryx4rj7dx1ip","content":"<h1 id=\"计算机基础\"><a href=\"#计算机基础\" class=\"headerlink\" title=\"计算机基础\"></a>计算机基础</h1><ol>\n<li>对于系统程序开发者来说，计算机三个部件最为关键：CPU、内存、I/O控制芯片。</li>\n<li>高速的北桥芯片：为了协调CPU、内存和高速的图形设备。此时慢速的I/O总线已经无法满足需求。</li>\n<li>低速设备的南桥芯片：由于北桥芯片运行速度非常高，于是人们有设计了低速设备的南桥芯片，磁盘、usb、键盘、鼠标等设备都连接在南桥芯片上，由南桥芯片将他们汇总后链接到北桥上。</li>\n<li>SMP(对称多处理器)多CPU的计算机；简单的来讲就是每个CPU在系统中所处的地位和发挥的功能是一样的，是相互对称的。使用场景：大型数据库、网络服务器上，他们要求同时处理大量的请求，而这些请求时相互独立的，所以多处理器就可以最大效能的发挥作用。多处理器最多的应用场合时这些商用的服务器和需要处理大量计算的环境。（CPU频率碰到了天花板4GHZ,才出现了SMP）.</li>\n<li>多核处理器：实际上就是SMP的简化版。这是由于多处理器成本高，所以厂商将多个处理器“合并在一起打包出售”，这些被打包的处理器之间共享比较昂贵的缓存部件，只保留多个核心；并且以一个处理器的外包装进行出售，价格比单核处理器只贵一点。当然他们在缓存共享方面有细微的差别，但是从程序员的角度来看，他们的区别很小，逻辑上看他们是完全相同的。</li>\n<li>系统软件：传统意义上一般将用于管理计算机本身的软件称为系统软件，以区别普通的应用程序。系统软件可以分为两块；一块是平台性的，比如，操作系统内核、驱动程序、运行库和数以千记得系统工具；另一块是用于程序开发的，比如，编译器、链接器、汇编器等开发工具和开发库。</li>\n<li>计算机系统软件体系结构采用一种层的结构：计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。</li>\n<li><p>接口：每个层次之间都必须要相互通信，则需要一个通信协议，我们一般将其称为接口。接口下面那层是提供者，上层是使用者。除了硬件和应用程序，其他层都是中间层，每个中间层都是对它下面的那层的包装与扩展。正是由于这些中间层的存在，使得应用程序和硬件之间保持相对独立。</p>\n</li>\n<li><p>在软件体系结构中：位于最高层的是应用程序。从整个层次结构上来看，开发工具与应用程序属于同一层，因为他们都使用同一接口，那就是操作系统应用程序编程接口。应用程序接口的提供者是运行库。<br>运行库使用操作系统提供的系统调用接口，系统调用接口往往以软中断的方式提供；比如，linux使用0x80号中断作为系统调用接口。<br>硬件规格: 操作系统内核层对于硬件层来说是硬件接口的使用者，而硬件是接口的定义者，硬件的接口的定义决定了操作系统的内核，具体来讲就是驱动程序如何操作硬件，如何与硬件通讯，这种接口被叫做硬件规格。</p>\n</li>\n<li><p>操作系统：一个功能是提供抽象的接口，另外一个主要功能就是管理硬件资源。</p>\n</li>\n<li>多道程序的设计：编写一个监控程序，当某个程序暂时无需使用CPU时，监控程序就把另外的正在等待CPU资源的程序启动起来，使得CPU能够充分利用起来，这种被称为多到程序。</li>\n<li>分时系统：每个程序运行一段时间后都主动让出CPU给其他的程序，使得一段时间内每个程序都有机会运行一小段时间。</li>\n<li>多任务系统：操作系统接管了所有的硬件资源，并且本身运行在一个受硬件保护的级别，每个进程都有自己的独立空间，使得进程之间的地址相互隔离。CPU由操作系统同一分配，每个进程都会根据进程优先级的高低都有机会得到CPU.但是，如果运行超出了一定的时间，操作系统会暂停该进程，将CPU资源分配给其他的等待运行的进程，这种CPU分配方式为抢占式。</li>\n<li>驱动程序可以看做事操作系统的一部分，它往往和系统内核一起运行在特权级别，但他与操作系统内核之间有一定的独立性，使得驱动程序有较好的灵活性。操作系统开发者为硬件生产商提供了一系列接口和框架，凡是按照这个接口和框架开发的驱动程序都可以在该操作系统上使用。</li>\n<li>进程的总体目标是希望每个进程从逻辑上看都可以独占计算机的资源。操作系统的多任务功能使得CPU能够在多个进程之间共享；从进程的角度看好像是他独占了CPU而不用考虑与其他进程分享CPU的事。操作系统的I/O抽象模型也很好的实现I/O设备的共享和抽象。内存通过虚拟地址空间；分段分页来实现共享。</li>\n</ol>\n<h1 id=\"为什么要虚拟内存：\"><a href=\"#为什么要虚拟内存：\" class=\"headerlink\" title=\"为什么要虚拟内存：\"></a>为什么要虚拟内存：</h1><p>如果程序直接在物理内存上使用，直接访问物理地址将带来很多问题：</p>\n<ol>\n<li>地址空间不隔离：所有程序都访问物理地址，程序所使用的内存空间不相互隔离，恶意的程序可以很容易改写其他程序的内存数据，以达到破坏的目的。有些非恶意、但有臭虫的程序可能不小心修改ill其他程序的数据，就会使其他程序崩溃。而使用虚拟地址空间可保证一个任务的失败不影响其他任务的执行。</li>\n<li>内存使用效率低：由于没有有效的内存管理机制，通常需要一个程序执行时，监控程序就将整个程序装载进内存然后执行。内存不够时会发生大量的数据交换，效率低下。</li>\n<li>程序运行的地址不稳定：因为程序每次需要装入运行时，我们都需要给他从内存中分配一块足够大的内存空间区域，这个区域位置不确定；这给程序的编写造成一定的麻烦，因为程序在编写时，它访问的数据和指令跳转时的目标地址很多都市固定的，这涉及到重定位问题。</li>\n</ol>\n<p>解决问题的思路就是增加中间层，即使用一种间接地址访问方法。我们把程序给出的地址看作是一种虚拟地址，然后通过某种映射，将虚拟地址转 换为物理地址。这样，只要我们能够妥善控制这个虚拟地址到物理地址的映射过程，就可以保证任意一个程序所能够访问的物理内存区域跟另一个程序相互不重叠，以达到地址空间隔离的效果。物理地址空间是真真实实存在的；虚拟地址空间是指虚拟的，而且每个进程只能访问自己的地址空间，这样就有效的做到了进程的隔离。</p>\n<h2 id=\"分段：\"><a href=\"#分段：\" class=\"headerlink\" title=\"分段：\"></a>分段：</h2><p>解决了第一个和第三个问题。首先，它做到了地址的隔离，如果程序访问越界，将会被硬件判断为非法访问，拒绝这个地址请求，并将这个请求报告给操作系统或者监控程序。再者，对于每个程序员来说，无论他们被分配到物理地址的那个区域，对于程序来说都是透明的。他们不需要关心物理地址的变化。    但分段没有解决内存使用效率问题；分段对内存区域的映射还是按照程序为单位；如果内存不足，被换入换出到磁盘的都是整个程序，这样势必会造成大量的磁盘访问操作，从而严重影响速度。这种方法换是显得比较粗糙，粒度比较大。<br>事实上，根据程序的局部性原理，当一个程序在运行时，在某个段内，它只是频繁的用到一小部分数据，也就是说，程序的很多数据其实在一段时间内都是不会被用到的。人们很自然的想到了更小粒度的内存分割和映射的方法，使得程序的局部性原理得到充分的利用，大大提高了内存使用率，这种方法就是分页。</p>\n<h2 id=\"分页：\"><a href=\"#分页：\" class=\"headerlink\" title=\"分页：\"></a>分页：</h2><p>提高了内存的使用率，减少了内存碎片的产生；保护也是页映射的目的之一。简单来说就是每个页可以设置权限属性，只有操作系统有权限修改这些属性。MMU都集成在CPU的内部了，不会以独立的部件存在。</p>\n<h1 id=\"线程基础\"><a href=\"#线程基础\" class=\"headerlink\" title=\"线程基础\"></a>线程基础</h1><p>线程：有时被称为轻量级的进程（LWP）,是程序执行流的最小单位。一个标准的线程是由线程ID\\当前指令指针（PC）、寄存器集合和堆栈组成。通常意义上，一个进程由一到多个线程组成，各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）以及一些进程级的资源（打开的文件和信号）。</p>\n<p>使用多线程的原因：</p>\n<ol>\n<li>某个操作可能会陷入长时间的等待，等待的线程会进入睡眠状态，无法继续执行，多线程执行可以有效的利用等待的时间。典型的例子是等待网络响应，这可能要花费数秒。</li>\n<li>某个操作（计算）会消耗大量的时间，如果只有一个线程，程序和用户之间的交互会中断。多线程可以让一个线程负责交互，另一个线程负责计算。</li>\n<li>程序本身就要求并发操作。、</li>\n<li>多CPU或多核计算机，本身具备同时执行多个线程的能力，因此单个线程程序无法全面的发挥计算机的全部计算能力。</li>\n<li>相对于多进程应用，多线程在数据共享方面效率要高得多。</li>\n</ol>\n<h1 id=\"线程的访问权限\"><a href=\"#线程的访问权限\" class=\"headerlink\" title=\"线程的访问权限\"></a>线程的访问权限</h1><p>线程的访问非常自由，它可以访问进程内存空间内的所有数据，甚至包括其他线程的堆栈（如果他知道其他线程的堆栈地址，这是很少见的情况），但实际运用中线程也拥有自己的私有存储空间：</p>\n<ol>\n<li>栈：尽管并非完全无法被其他线程访问，但一般情况下仍然可以认为是私有数据。</li>\n<li>线程局部存储，是某些操作系统为线程单独提供的私有空间，但通常只具有很有限的容量。</li>\n<li>寄存器：寄存器是执行流的基本数据，因此为线程私有。</li>\n</ol>\n<h1 id=\"从C程序员的角度看，数据在线程之间是否私有：\"><a href=\"#从C程序员的角度看，数据在线程之间是否私有：\" class=\"headerlink\" title=\"从C程序员的角度看，数据在线程之间是否私有：\"></a>从C程序员的角度看，数据在线程之间是否私有：</h1><p>私有：局部变量、函数参数、TLS线程局部存储数据</p>\n<p>线程之间共享进程所有：全局变量、堆上的数据、函数里的静态变量、程序代码，任何程序都有权读取并执行任何代码、打开的文件。</p>\n<p>线程调度：一个不断在处理器上切换不同线程的的行为。线程通常至少拥有三种状态：运行、就绪、等待。</p>\n<p>IO密集型线程：频繁等待的线程；CPU密集型线程：很少等待的线程；IO密集型的线程总比cpu密集型的线程容易得到优先级的提升。</p>\n<p>对于linux来说，线程并不是一个通用的概念；linux对多线程支持颇为贫乏；事实上，在linux内核中并不存在真正意义上的线程的概念。Linux将所有可执行的实体称为任务（TASK）,无论是进程换是线程。每一个任务概念上都类似于一个单进程的线程，具有内存空间、执行实体、文件资源。不过，linux下不同任务之间可以选择共享内存空间，因而在实际意义上，共享同一个内存空间的多个任务构成了一个进程，这些任务也就成为了这个进程里的线程。在linux下，用以下方法可以创建一个新的任务。</p>\n<table>\n<thead>\n<tr>\n<th>系统调用</th>\n<th style=\"text-align:left\">作用</th>\n<th style=\"text-align:left\">效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>fork</td>\n<td style=\"text-align:left\">复制当前进程</td>\n<td style=\"text-align:left\">新的任务启动并和本任务一起从fork返回，本任务返回的是新任务的pid,新任务返回0。Fork速度非常快，因为采用了写时复制。Fork只能产生本任务的镜像。</td>\n</tr>\n<tr>\n<td>exec</td>\n<td style=\"text-align:left\">使用新的可执行映像覆盖当前可执行映像</td>\n<td style=\"text-align:left\">Fork+exec启动别的新任务。</td>\n</tr>\n<tr>\n<td>Clone</td>\n<td style=\"text-align:left\">创建子进程并从指定位置开始执行</td>\n<td style=\"text-align:left\">产生新的线程使用clone。从指定的位置开始执行，并且（可选）共享当前的内存空间和文件等。如此就可以在实际效果上产生一个线程。</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h1><p>同步：为了避免多个线程同时读写同一个数据而产生不可预料的结果，我们需要将各个线程对同一个数据的访问同步。所谓的同步，既是指在一个线程访问数据未结束的时候，其他线程不得对同一个数据进行访问。如此，对数据的访问被原子化了。<br>同步的方式：</p>\n<ol>\n<li>锁、</li>\n<li>二元信号量、（多元）信号量（对于允许多个线程并发访问的资源，它是一个很好的选择；一个初始值为n的信号量允许N个线程并发访问。）</li>\n<li>互斥量：和二元信号量很类似，资源进同时只能被一个线程访问。不同的是，信号量在整个系统可以被任意线程获取并释放。而互斥量则要求那个线程获取了互斥量，那个线程就要负责释放这个锁。</li>\n<li>临界区：是比互斥量更加严格的同步手段。把临界区的锁获取称为进入临界区，释放称为离开临界区。临界区和互斥量与信号量的区别在于，互斥量和信号量在系统的任何进程里都是可见的，也就是说，一个进程创建了一个互斥量或者信号量，另一个进程试图获取该锁是合法的。然而，临界区的作用范围仅限于本进程，其他进程无法获取该锁。除此之外，临界区胡互斥量具有相同的性质。</li>\n<li>读写锁：适用于读频繁写少的情况。对于一段数据，多个线程同时读取总是没有问题的，写时必须上锁。</li>\n<li>条件变量：作用类似一个栅栏。线程有两种操作，等待与唤醒。使用条件变量可以让许多线程一起等待某个事件的发生，当时间发生时，条件变量被唤醒，所有的线程可以一起恢复执行。</li>\n</ol>\n<h1 id=\"可重入与线程安全\"><a href=\"#可重入与线程安全\" class=\"headerlink\" title=\"可重入与线程安全\"></a>可重入与线程安全</h1><p>一个函数要被重入只有两种情况：一是多个线程同时执行这个函数；二是函数自身调用自身。一个函数被重入表示这个函数没有被执行完成，由于外部因素或者内部调用，又一次进入函数执行。一个函数可重入，表明函数重入后不会产生任何不良的后果。一个函数要成为可重入的，必须具有</p>\n<p>如下几个特点：</p>\n<ol>\n<li>不使用任何（局部）静态或全局的非const变量。</li>\n<li>不返回任何（局部）静态或者全局的非const变量的指针。</li>\n<li>仅依赖于调用方提供的参数。</li>\n<li>不依赖任何单个资源的锁。</li>\n<li>不调用任何可重入的函数。</li>\n</ol>\n<p>可重入是并发的强力保障，一个可重入的函数可以在多线程环境下放心使用。</p>\n<h2 id=\"过度优化\"><a href=\"#过度优化\" class=\"headerlink\" title=\"过度优化\"></a>过度优化</h2><p>Volatile关键字:一是阻止编译器为了提高速度将一个变量缓存到寄存器中而不写回；二是阻止编译器调整volatile变量的指令顺序。<br>Barrier：因为即使volatile可以阻止编译器调整顺序，也无法阻止CPU动态调度换序。现在并不存在可移植的阻止换序的方法。通常情况下是通过调用CPU提供的一条指令，这条指令被称为barrier。它可以阻止cpu将该指令之前的指令交换到它之后，反之亦然。Barrier指令的作用类似于一个拦水坝，阻止换序穿透这个大坝。</p>\n<h1 id=\"三种线程模型\"><a href=\"#三种线程模型\" class=\"headerlink\" title=\"三种线程模型\"></a>三种线程模型</h1><p>Windows和linux，都是在内核里提供线程的支持。内核线程，这里的内核线程和linux内核里的kernel_thread并不是一回事，它和我们之前讨论的一样，由多个处理器或调度器来实现并发。然而用户实际使用的的线程不是内核线程，而是存在于用户态的用户线程。用户线程并不一定在操作系统内核内对应着同样数量的内核线程。<br>用户态多线程库的实现</p>\n<ol>\n<li>一对一模型：用户线程具有和内核线程一致的优点，线程之间的并发，是真正的并发。一个线程阻塞，其他线程不会受到影响。一对一模型可以让多线程程序在多处理器的系统上有跟好的体现。一般直接使用API或系统调用创建的线程均为一对一的线程。</li>\n</ol>\n<blockquote>\n<p>缺点：一是由于许多操作系统限制了内核线程的数量，因此一对一线程会让用户的线程数量受到限制。二是许多操作系统内核线程调度时，上下文切换开销大，导致用户线程的执行效率下降。</p>\n</blockquote>\n<ol>\n<li>多对一模型：线程间的切换由用户态的代码来进行，线程切换的速度要快许多，但是一个用户线程阻塞，那么所有线程都将无法执行，因此此时内核里的线程也随之阻塞了。多对一模型的好处就是高效的上下文切换和几乎无限制的线程数量。</li>\n<li>多对多模型：一个用户线程阻塞并不会使得所有用户线程阻塞，因为此时还有别的线程可以被调度来执行。另外，多对多模型对用户线程的数量没有什么限制，在多处理器上，线程也能得到一定性能的提升。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"计算机基础\"><a href=\"#计算机基础\" class=\"headerlink\" title=\"计算机基础\"></a>计算机基础</h1><ol>\n<li>对于系统程序开发者来说，计算机三个部件最为关键：CPU、内存、I/O控制芯片。</li>\n<li>高速的北桥芯片：为了协调CPU、内存和高速的图形设备。此时慢速的I/O总线已经无法满足需求。</li>\n<li>低速设备的南桥芯片：由于北桥芯片运行速度非常高，于是人们有设计了低速设备的南桥芯片，磁盘、usb、键盘、鼠标等设备都连接在南桥芯片上，由南桥芯片将他们汇总后链接到北桥上。</li>\n<li>SMP(对称多处理器)多CPU的计算机；简单的来讲就是每个CPU在系统中所处的地位和发挥的功能是一样的，是相互对称的。使用场景：大型数据库、网络服务器上，他们要求同时处理大量的请求，而这些请求时相互独立的，所以多处理器就可以最大效能的发挥作用。多处理器最多的应用场合时这些商用的服务器和需要处理大量计算的环境。（CPU频率碰到了天花板4GHZ,才出现了SMP）.</li>\n<li>多核处理器：实际上就是SMP的简化版。这是由于多处理器成本高，所以厂商将多个处理器“合并在一起打包出售”，这些被打包的处理器之间共享比较昂贵的缓存部件，只保留多个核心；并且以一个处理器的外包装进行出售，价格比单核处理器只贵一点。当然他们在缓存共享方面有细微的差别，但是从程序员的角度来看，他们的区别很小，逻辑上看他们是完全相同的。</li>\n<li>系统软件：传统意义上一般将用于管理计算机本身的软件称为系统软件，以区别普通的应用程序。系统软件可以分为两块；一块是平台性的，比如，操作系统内核、驱动程序、运行库和数以千记得系统工具；另一块是用于程序开发的，比如，编译器、链接器、汇编器等开发工具和开发库。</li>\n<li>计算机系统软件体系结构采用一种层的结构：计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。</li>\n<li><p>接口：每个层次之间都必须要相互通信，则需要一个通信协议，我们一般将其称为接口。接口下面那层是提供者，上层是使用者。除了硬件和应用程序，其他层都是中间层，每个中间层都是对它下面的那层的包装与扩展。正是由于这些中间层的存在，使得应用程序和硬件之间保持相对独立。</p>\n</li>\n<li><p>在软件体系结构中：位于最高层的是应用程序。从整个层次结构上来看，开发工具与应用程序属于同一层，因为他们都使用同一接口，那就是操作系统应用程序编程接口。应用程序接口的提供者是运行库。<br>运行库使用操作系统提供的系统调用接口，系统调用接口往往以软中断的方式提供；比如，linux使用0x80号中断作为系统调用接口。<br>硬件规格: 操作系统内核层对于硬件层来说是硬件接口的使用者，而硬件是接口的定义者，硬件的接口的定义决定了操作系统的内核，具体来讲就是驱动程序如何操作硬件，如何与硬件通讯，这种接口被叫做硬件规格。</p>\n</li>\n<li><p>操作系统：一个功能是提供抽象的接口，另外一个主要功能就是管理硬件资源。</p>\n</li>\n<li>多道程序的设计：编写一个监控程序，当某个程序暂时无需使用CPU时，监控程序就把另外的正在等待CPU资源的程序启动起来，使得CPU能够充分利用起来，这种被称为多到程序。</li>\n<li>分时系统：每个程序运行一段时间后都主动让出CPU给其他的程序，使得一段时间内每个程序都有机会运行一小段时间。</li>\n<li>多任务系统：操作系统接管了所有的硬件资源，并且本身运行在一个受硬件保护的级别，每个进程都有自己的独立空间，使得进程之间的地址相互隔离。CPU由操作系统同一分配，每个进程都会根据进程优先级的高低都有机会得到CPU.但是，如果运行超出了一定的时间，操作系统会暂停该进程，将CPU资源分配给其他的等待运行的进程，这种CPU分配方式为抢占式。</li>\n<li>驱动程序可以看做事操作系统的一部分，它往往和系统内核一起运行在特权级别，但他与操作系统内核之间有一定的独立性，使得驱动程序有较好的灵活性。操作系统开发者为硬件生产商提供了一系列接口和框架，凡是按照这个接口和框架开发的驱动程序都可以在该操作系统上使用。</li>\n<li>进程的总体目标是希望每个进程从逻辑上看都可以独占计算机的资源。操作系统的多任务功能使得CPU能够在多个进程之间共享；从进程的角度看好像是他独占了CPU而不用考虑与其他进程分享CPU的事。操作系统的I/O抽象模型也很好的实现I/O设备的共享和抽象。内存通过虚拟地址空间；分段分页来实现共享。</li>\n</ol>\n<h1 id=\"为什么要虚拟内存：\"><a href=\"#为什么要虚拟内存：\" class=\"headerlink\" title=\"为什么要虚拟内存：\"></a>为什么要虚拟内存：</h1><p>如果程序直接在物理内存上使用，直接访问物理地址将带来很多问题：</p>\n<ol>\n<li>地址空间不隔离：所有程序都访问物理地址，程序所使用的内存空间不相互隔离，恶意的程序可以很容易改写其他程序的内存数据，以达到破坏的目的。有些非恶意、但有臭虫的程序可能不小心修改ill其他程序的数据，就会使其他程序崩溃。而使用虚拟地址空间可保证一个任务的失败不影响其他任务的执行。</li>\n<li>内存使用效率低：由于没有有效的内存管理机制，通常需要一个程序执行时，监控程序就将整个程序装载进内存然后执行。内存不够时会发生大量的数据交换，效率低下。</li>\n<li>程序运行的地址不稳定：因为程序每次需要装入运行时，我们都需要给他从内存中分配一块足够大的内存空间区域，这个区域位置不确定；这给程序的编写造成一定的麻烦，因为程序在编写时，它访问的数据和指令跳转时的目标地址很多都市固定的，这涉及到重定位问题。</li>\n</ol>\n<p>解决问题的思路就是增加中间层，即使用一种间接地址访问方法。我们把程序给出的地址看作是一种虚拟地址，然后通过某种映射，将虚拟地址转 换为物理地址。这样，只要我们能够妥善控制这个虚拟地址到物理地址的映射过程，就可以保证任意一个程序所能够访问的物理内存区域跟另一个程序相互不重叠，以达到地址空间隔离的效果。物理地址空间是真真实实存在的；虚拟地址空间是指虚拟的，而且每个进程只能访问自己的地址空间，这样就有效的做到了进程的隔离。</p>\n<h2 id=\"分段：\"><a href=\"#分段：\" class=\"headerlink\" title=\"分段：\"></a>分段：</h2><p>解决了第一个和第三个问题。首先，它做到了地址的隔离，如果程序访问越界，将会被硬件判断为非法访问，拒绝这个地址请求，并将这个请求报告给操作系统或者监控程序。再者，对于每个程序员来说，无论他们被分配到物理地址的那个区域，对于程序来说都是透明的。他们不需要关心物理地址的变化。    但分段没有解决内存使用效率问题；分段对内存区域的映射还是按照程序为单位；如果内存不足，被换入换出到磁盘的都是整个程序，这样势必会造成大量的磁盘访问操作，从而严重影响速度。这种方法换是显得比较粗糙，粒度比较大。<br>事实上，根据程序的局部性原理，当一个程序在运行时，在某个段内，它只是频繁的用到一小部分数据，也就是说，程序的很多数据其实在一段时间内都是不会被用到的。人们很自然的想到了更小粒度的内存分割和映射的方法，使得程序的局部性原理得到充分的利用，大大提高了内存使用率，这种方法就是分页。</p>\n<h2 id=\"分页：\"><a href=\"#分页：\" class=\"headerlink\" title=\"分页：\"></a>分页：</h2><p>提高了内存的使用率，减少了内存碎片的产生；保护也是页映射的目的之一。简单来说就是每个页可以设置权限属性，只有操作系统有权限修改这些属性。MMU都集成在CPU的内部了，不会以独立的部件存在。</p>\n<h1 id=\"线程基础\"><a href=\"#线程基础\" class=\"headerlink\" title=\"线程基础\"></a>线程基础</h1><p>线程：有时被称为轻量级的进程（LWP）,是程序执行流的最小单位。一个标准的线程是由线程ID\\当前指令指针（PC）、寄存器集合和堆栈组成。通常意义上，一个进程由一到多个线程组成，各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）以及一些进程级的资源（打开的文件和信号）。</p>\n<p>使用多线程的原因：</p>\n<ol>\n<li>某个操作可能会陷入长时间的等待，等待的线程会进入睡眠状态，无法继续执行，多线程执行可以有效的利用等待的时间。典型的例子是等待网络响应，这可能要花费数秒。</li>\n<li>某个操作（计算）会消耗大量的时间，如果只有一个线程，程序和用户之间的交互会中断。多线程可以让一个线程负责交互，另一个线程负责计算。</li>\n<li>程序本身就要求并发操作。、</li>\n<li>多CPU或多核计算机，本身具备同时执行多个线程的能力，因此单个线程程序无法全面的发挥计算机的全部计算能力。</li>\n<li>相对于多进程应用，多线程在数据共享方面效率要高得多。</li>\n</ol>\n<h1 id=\"线程的访问权限\"><a href=\"#线程的访问权限\" class=\"headerlink\" title=\"线程的访问权限\"></a>线程的访问权限</h1><p>线程的访问非常自由，它可以访问进程内存空间内的所有数据，甚至包括其他线程的堆栈（如果他知道其他线程的堆栈地址，这是很少见的情况），但实际运用中线程也拥有自己的私有存储空间：</p>\n<ol>\n<li>栈：尽管并非完全无法被其他线程访问，但一般情况下仍然可以认为是私有数据。</li>\n<li>线程局部存储，是某些操作系统为线程单独提供的私有空间，但通常只具有很有限的容量。</li>\n<li>寄存器：寄存器是执行流的基本数据，因此为线程私有。</li>\n</ol>\n<h1 id=\"从C程序员的角度看，数据在线程之间是否私有：\"><a href=\"#从C程序员的角度看，数据在线程之间是否私有：\" class=\"headerlink\" title=\"从C程序员的角度看，数据在线程之间是否私有：\"></a>从C程序员的角度看，数据在线程之间是否私有：</h1><p>私有：局部变量、函数参数、TLS线程局部存储数据</p>\n<p>线程之间共享进程所有：全局变量、堆上的数据、函数里的静态变量、程序代码，任何程序都有权读取并执行任何代码、打开的文件。</p>\n<p>线程调度：一个不断在处理器上切换不同线程的的行为。线程通常至少拥有三种状态：运行、就绪、等待。</p>\n<p>IO密集型线程：频繁等待的线程；CPU密集型线程：很少等待的线程；IO密集型的线程总比cpu密集型的线程容易得到优先级的提升。</p>\n<p>对于linux来说，线程并不是一个通用的概念；linux对多线程支持颇为贫乏；事实上，在linux内核中并不存在真正意义上的线程的概念。Linux将所有可执行的实体称为任务（TASK）,无论是进程换是线程。每一个任务概念上都类似于一个单进程的线程，具有内存空间、执行实体、文件资源。不过，linux下不同任务之间可以选择共享内存空间，因而在实际意义上，共享同一个内存空间的多个任务构成了一个进程，这些任务也就成为了这个进程里的线程。在linux下，用以下方法可以创建一个新的任务。</p>\n<table>\n<thead>\n<tr>\n<th>系统调用</th>\n<th style=\"text-align:left\">作用</th>\n<th style=\"text-align:left\">效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>fork</td>\n<td style=\"text-align:left\">复制当前进程</td>\n<td style=\"text-align:left\">新的任务启动并和本任务一起从fork返回，本任务返回的是新任务的pid,新任务返回0。Fork速度非常快，因为采用了写时复制。Fork只能产生本任务的镜像。</td>\n</tr>\n<tr>\n<td>exec</td>\n<td style=\"text-align:left\">使用新的可执行映像覆盖当前可执行映像</td>\n<td style=\"text-align:left\">Fork+exec启动别的新任务。</td>\n</tr>\n<tr>\n<td>Clone</td>\n<td style=\"text-align:left\">创建子进程并从指定位置开始执行</td>\n<td style=\"text-align:left\">产生新的线程使用clone。从指定的位置开始执行，并且（可选）共享当前的内存空间和文件等。如此就可以在实际效果上产生一个线程。</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h1><p>同步：为了避免多个线程同时读写同一个数据而产生不可预料的结果，我们需要将各个线程对同一个数据的访问同步。所谓的同步，既是指在一个线程访问数据未结束的时候，其他线程不得对同一个数据进行访问。如此，对数据的访问被原子化了。<br>同步的方式：</p>\n<ol>\n<li>锁、</li>\n<li>二元信号量、（多元）信号量（对于允许多个线程并发访问的资源，它是一个很好的选择；一个初始值为n的信号量允许N个线程并发访问。）</li>\n<li>互斥量：和二元信号量很类似，资源进同时只能被一个线程访问。不同的是，信号量在整个系统可以被任意线程获取并释放。而互斥量则要求那个线程获取了互斥量，那个线程就要负责释放这个锁。</li>\n<li>临界区：是比互斥量更加严格的同步手段。把临界区的锁获取称为进入临界区，释放称为离开临界区。临界区和互斥量与信号量的区别在于，互斥量和信号量在系统的任何进程里都是可见的，也就是说，一个进程创建了一个互斥量或者信号量，另一个进程试图获取该锁是合法的。然而，临界区的作用范围仅限于本进程，其他进程无法获取该锁。除此之外，临界区胡互斥量具有相同的性质。</li>\n<li>读写锁：适用于读频繁写少的情况。对于一段数据，多个线程同时读取总是没有问题的，写时必须上锁。</li>\n<li>条件变量：作用类似一个栅栏。线程有两种操作，等待与唤醒。使用条件变量可以让许多线程一起等待某个事件的发生，当时间发生时，条件变量被唤醒，所有的线程可以一起恢复执行。</li>\n</ol>\n<h1 id=\"可重入与线程安全\"><a href=\"#可重入与线程安全\" class=\"headerlink\" title=\"可重入与线程安全\"></a>可重入与线程安全</h1><p>一个函数要被重入只有两种情况：一是多个线程同时执行这个函数；二是函数自身调用自身。一个函数被重入表示这个函数没有被执行完成，由于外部因素或者内部调用，又一次进入函数执行。一个函数可重入，表明函数重入后不会产生任何不良的后果。一个函数要成为可重入的，必须具有</p>\n<p>如下几个特点：</p>\n<ol>\n<li>不使用任何（局部）静态或全局的非const变量。</li>\n<li>不返回任何（局部）静态或者全局的非const变量的指针。</li>\n<li>仅依赖于调用方提供的参数。</li>\n<li>不依赖任何单个资源的锁。</li>\n<li>不调用任何可重入的函数。</li>\n</ol>\n<p>可重入是并发的强力保障，一个可重入的函数可以在多线程环境下放心使用。</p>\n<h2 id=\"过度优化\"><a href=\"#过度优化\" class=\"headerlink\" title=\"过度优化\"></a>过度优化</h2><p>Volatile关键字:一是阻止编译器为了提高速度将一个变量缓存到寄存器中而不写回；二是阻止编译器调整volatile变量的指令顺序。<br>Barrier：因为即使volatile可以阻止编译器调整顺序，也无法阻止CPU动态调度换序。现在并不存在可移植的阻止换序的方法。通常情况下是通过调用CPU提供的一条指令，这条指令被称为barrier。它可以阻止cpu将该指令之前的指令交换到它之后，反之亦然。Barrier指令的作用类似于一个拦水坝，阻止换序穿透这个大坝。</p>\n<h1 id=\"三种线程模型\"><a href=\"#三种线程模型\" class=\"headerlink\" title=\"三种线程模型\"></a>三种线程模型</h1><p>Windows和linux，都是在内核里提供线程的支持。内核线程，这里的内核线程和linux内核里的kernel_thread并不是一回事，它和我们之前讨论的一样，由多个处理器或调度器来实现并发。然而用户实际使用的的线程不是内核线程，而是存在于用户态的用户线程。用户线程并不一定在操作系统内核内对应着同样数量的内核线程。<br>用户态多线程库的实现</p>\n<ol>\n<li>一对一模型：用户线程具有和内核线程一致的优点，线程之间的并发，是真正的并发。一个线程阻塞，其他线程不会受到影响。一对一模型可以让多线程程序在多处理器的系统上有跟好的体现。一般直接使用API或系统调用创建的线程均为一对一的线程。</li>\n</ol>\n<blockquote>\n<p>缺点：一是由于许多操作系统限制了内核线程的数量，因此一对一线程会让用户的线程数量受到限制。二是许多操作系统内核线程调度时，上下文切换开销大，导致用户线程的执行效率下降。</p>\n</blockquote>\n<ol>\n<li>多对一模型：线程间的切换由用户态的代码来进行，线程切换的速度要快许多，但是一个用户线程阻塞，那么所有线程都将无法执行，因此此时内核里的线程也随之阻塞了。多对一模型的好处就是高效的上下文切换和几乎无限制的线程数量。</li>\n<li>多对多模型：一个用户线程阻塞并不会使得所有用户线程阻塞，因为此时还有别的线程可以被调度来执行。另外，多对多模型对用户线程的数量没有什么限制，在多处理器上，线程也能得到一定性能的提升。</li>\n</ol>\n"}],"PostAsset":[{"_id":"source/_posts/linux-文件系统/image1.png","slug":"image1.png","post":"cjd4d1a0c0016ryx48od9pqbc","modified":0,"renderable":0},{"_id":"source/_posts/linux-文件系统/mbr.png","slug":"mbr.png","post":"cjd4d1a0c0016ryx48od9pqbc","modified":0,"renderable":0},{"_id":"source/_posts/linux-文件系统/图片4.png","slug":"图片4.png","post":"cjd4d1a0c0016ryx48od9pqbc","modified":0,"renderable":0},{"_id":"source/_posts/linux-文件系统/图片5.png","slug":"图片5.png","post":"cjd4d1a0c0016ryx48od9pqbc","modified":0,"renderable":0},{"_id":"source/_posts/linux-文件系统/图片6.png","slug":"图片6.png","post":"cjd4d1a0c0016ryx48od9pqbc","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cjd4d19zb0000ryx4vpd414b4","category_id":"cjd4d19zj0004ryx4g5zsh2vu","_id":"cjd4d19zr000eryx4j160tifw"},{"post_id":"cjd4d19zu000iryx4l8tr6wic","category_id":"cjd4d19zo000bryx4d49a659z","_id":"cjd4d19zy000pryx4mdf4nulk"},{"post_id":"cjd4d19zm0008ryx4gkeqyiet","category_id":"cjd4d19zt000gryx4ixbxhe5m","_id":"cjd4d1a00000rryx4u6drhvr2"},{"post_id":"cjd4d19zw000kryx482ovciyo","category_id":"cjd4d19zo000bryx4d49a659z","_id":"cjd4d1a06000wryx43bzdsvzk"},{"post_id":"cjd4d19zx000oryx4zjs20et5","category_id":"cjd4d19zo000bryx4d49a659z","_id":"cjd4d1a07000zryx4tcn0j4bq"},{"post_id":"cjd4d19zo000aryx4euuudxgh","category_id":"cjd4d19zw000mryx43l5bx77n","_id":"cjd4d1a080013ryx44r3acq2n"},{"post_id":"cjd4d1a00000uryx40ti3sb51","category_id":"cjd4d19zo000bryx4d49a659z","_id":"cjd4d1a0c0015ryx4g76o43mb"},{"post_id":"cjd4d19zq000dryx42ow7qeyf","category_id":"cjd4d1a00000sryx4okn04cf5","_id":"cjd4d1a0e0019ryx4wp6ibzhs"},{"post_id":"cjd4d1a070011ryx4wnr3poi1","category_id":"cjd4d19zw000mryx43l5bx77n","_id":"cjd4d1a0f001bryx45w8yhq82"},{"post_id":"cjd4d1a080014ryx4gvnubet8","category_id":"cjd4d19zw000mryx43l5bx77n","_id":"cjd4d1a0g001fryx48mgynopx"},{"post_id":"cjd4d19zk0006ryx42z578232","category_id":"cjd4d19zo000bryx4d49a659z","_id":"cjd4d1a0h001iryx4an5pwlrc"},{"post_id":"cjd4d19zk0006ryx42z578232","category_id":"cjd4d1a080012ryx496bigu8n","_id":"cjd4d1a0k001nryx4eeastfrz"},{"post_id":"cjd4d1a0c0016ryx48od9pqbc","category_id":"cjd4d19zw000mryx43l5bx77n","_id":"cjd4d1a0l001qryx4n03ycrcg"},{"post_id":"cjd4d19zr000fryx47wmprb2t","category_id":"cjd4d1a00000sryx4okn04cf5","_id":"cjd4d1a0l001sryx40qfy04zq"},{"post_id":"cjd4d1a0f001cryx4yuei8l4j","category_id":"cjd4d1a00000sryx4okn04cf5","_id":"cjd4d1a0o001xryx4wbqtv65w"},{"post_id":"cjd4d1a0g001gryx4ftw2evzx","category_id":"cjd4d19zw000mryx43l5bx77n","_id":"cjd4d1a0p0020ryx4u30sba9i"},{"post_id":"cjd4d1a06000xryx4idqoxv4u","category_id":"cjd4d1a0f001dryx4pbr8p0qh","_id":"cjd4d1a0s0024ryx4cej58dvm"},{"post_id":"cjd4d1a0e001aryx4htiz4np7","category_id":"cjd4d1a0j001lryx468db8iao","_id":"cjd4d1a0s0026ryx4ewnvpkne"},{"post_id":"cjd4d1a0l001rryx4dd57j9zp","category_id":"cjd4d19zt000gryx4ixbxhe5m","_id":"cjd4d1a0t002aryx4z77yj18a"},{"post_id":"cjd4d1a0m001vryx4f1l31ew9","category_id":"cjd4d19zt000gryx4ixbxhe5m","_id":"cjd4d1a0u002cryx4g6kch96o"},{"post_id":"cjd4d1a0o001yryx4i4fl4c9j","category_id":"cjd4d19zw000mryx43l5bx77n","_id":"cjd4d1a0u002gryx4qqfbxo3c"},{"post_id":"cjd4d1a0q0021ryx4mynxdnap","category_id":"cjd4d19zt000gryx4ixbxhe5m","_id":"cjd4d1a0v002hryx4v0nn324j"},{"post_id":"cjd4d1a0s0027ryx4rj7dx1ip","category_id":"cjd4d19zw000mryx43l5bx77n","_id":"cjd4d1a0v002jryx4maoqamif"},{"post_id":"cjd4d1a0s0025ryx4tlc50cx8","category_id":"cjd4d1a0u002eryx493wmue1v","_id":"cjd4d1a0x002qryx4eaz2cfdg"}],"PostTag":[{"post_id":"cjd4d19zb0000ryx4vpd414b4","tag_id":"cjd4d19zk0005ryx4anvyljv4","_id":"cjd4d19zv000jryx4vknof7tf"},{"post_id":"cjd4d19zb0000ryx4vpd414b4","tag_id":"cjd4d19zo000cryx4pu0gunsr","_id":"cjd4d19zw000lryx4iddg8oxe"},{"post_id":"cjd4d19zk0006ryx42z578232","tag_id":"cjd4d19zt000hryx4q4dprnat","_id":"cjd4d1a06000vryx47qfmrpfa"},{"post_id":"cjd4d19zk0006ryx42z578232","tag_id":"cjd4d19zx000nryx4ogbuatct","_id":"cjd4d1a07000yryx4ft2h1gs8"},{"post_id":"cjd4d19zm0008ryx4gkeqyiet","tag_id":"cjd4d19zx000nryx4ogbuatct","_id":"cjd4d1a0h001hryx4z0ixi8ku"},{"post_id":"cjd4d19zm0008ryx4gkeqyiet","tag_id":"cjd4d1a070010ryx49b2leivi","_id":"cjd4d1a0j001kryx48m766rzd"},{"post_id":"cjd4d19zm0008ryx4gkeqyiet","tag_id":"cjd4d1a0d0017ryx4kfthf3lz","_id":"cjd4d1a0k001pryx4o03b9axx"},{"post_id":"cjd4d19zo000aryx4euuudxgh","tag_id":"cjd4d1a0g001eryx4dfja2mee","_id":"cjd4d1a0o001wryx4tr1dpo8t"},{"post_id":"cjd4d19zo000aryx4euuudxgh","tag_id":"cjd4d1a0k001mryx4qzqvb6ii","_id":"cjd4d1a0p001zryx4b9fjxsfd"},{"post_id":"cjd4d19zq000dryx42ow7qeyf","tag_id":"cjd4d1a0l001uryx4ueugffsw","_id":"cjd4d1a0u002bryx4idtut2vq"},{"post_id":"cjd4d19zq000dryx42ow7qeyf","tag_id":"cjd4d1a0r0023ryx4owdqqsxq","_id":"cjd4d1a0u002dryx4we7q7ten"},{"post_id":"cjd4d19zr000fryx47wmprb2t","tag_id":"cjd4d1a0t0029ryx4js8wl526","_id":"cjd4d1a0w002lryx4fxopppfj"},{"post_id":"cjd4d19zr000fryx47wmprb2t","tag_id":"cjd4d1a0u002fryx41tmtpomw","_id":"cjd4d1a0w002nryx4lrpvbdz0"},{"post_id":"cjd4d19zu000iryx4l8tr6wic","tag_id":"cjd4d1a0v002kryx4oqu8kpwg","_id":"cjd4d1a0x002rryx450g1emfn"},{"post_id":"cjd4d19zu000iryx4l8tr6wic","tag_id":"cjd4d19zt000hryx4q4dprnat","_id":"cjd4d1a0x002tryx4cqtqukuc"},{"post_id":"cjd4d19zw000kryx482ovciyo","tag_id":"cjd4d1a0x002pryx4kywvm1qu","_id":"cjd4d1a0y002xryx40y35neic"},{"post_id":"cjd4d19zw000kryx482ovciyo","tag_id":"cjd4d19zt000hryx4q4dprnat","_id":"cjd4d1a0z002yryx46ehpvtm7"},{"post_id":"cjd4d19zw000kryx482ovciyo","tag_id":"cjd4d1a0x002uryx4a6z7gdea","_id":"cjd4d1a0z0030ryx4366qi9j6"},{"post_id":"cjd4d19zx000oryx4zjs20et5","tag_id":"cjd4d19zt000hryx4q4dprnat","_id":"cjd4d1a0z0031ryx45zg8pcb8"},{"post_id":"cjd4d19zx000oryx4zjs20et5","tag_id":"cjd4d1a0y002wryx4g7b5rbjc","_id":"cjd4d1a0z0033ryx4zpwmnktj"},{"post_id":"cjd4d1a00000uryx40ti3sb51","tag_id":"cjd4d19zt000hryx4q4dprnat","_id":"cjd4d1a0z0034ryx4e1rvfg2u"},{"post_id":"cjd4d1a00000uryx40ti3sb51","tag_id":"cjd4d1a0z002zryx498m3ts6y","_id":"cjd4d1a100036ryx454kd7ic1"},{"post_id":"cjd4d1a06000xryx4idqoxv4u","tag_id":"cjd4d1a0z0032ryx40q1jysz6","_id":"cjd4d1a100037ryx45ik93ger"},{"post_id":"cjd4d1a070011ryx4wnr3poi1","tag_id":"cjd4d1a0g001eryx4dfja2mee","_id":"cjd4d1a100039ryx475g3amdl"},{"post_id":"cjd4d1a080014ryx4gvnubet8","tag_id":"cjd4d1a0g001eryx4dfja2mee","_id":"cjd4d1a11003cryx4smgplxhw"},{"post_id":"cjd4d1a080014ryx4gvnubet8","tag_id":"cjd4d1a10003aryx4y3wukk4x","_id":"cjd4d1a11003dryx4mq50rwf0"},{"post_id":"cjd4d1a0c0016ryx48od9pqbc","tag_id":"cjd4d1a0g001eryx4dfja2mee","_id":"cjd4d1a12003gryx4yie3egcq"},{"post_id":"cjd4d1a0c0016ryx48od9pqbc","tag_id":"cjd4d1a11003eryx4jrs6x6c5","_id":"cjd4d1a12003hryx4jrj4jstg"},{"post_id":"cjd4d1a0e001aryx4htiz4np7","tag_id":"cjd4d1a11003fryx4nd43jj6e","_id":"cjd4d1a12003jryx4uwyki33s"},{"post_id":"cjd4d1a0f001cryx4yuei8l4j","tag_id":"cjd4d1a0t0029ryx4js8wl526","_id":"cjd4d1a12003lryx4c1qttqtx"},{"post_id":"cjd4d1a0g001gryx4ftw2evzx","tag_id":"cjd4d1a0g001eryx4dfja2mee","_id":"cjd4d1a13003oryx4w9se2rpp"},{"post_id":"cjd4d1a0g001gryx4ftw2evzx","tag_id":"cjd4d1a12003kryx4wcdrsoor","_id":"cjd4d1a13003pryx4hzqoe0dw"},{"post_id":"cjd4d1a0g001gryx4ftw2evzx","tag_id":"cjd4d1a12003mryx4i6k00x0h","_id":"cjd4d1a13003rryx4tbz732mu"},{"post_id":"cjd4d1a0l001rryx4dd57j9zp","tag_id":"cjd4d19zx000nryx4ogbuatct","_id":"cjd4d1a150040ryx4aja4v0zn"},{"post_id":"cjd4d1a0l001rryx4dd57j9zp","tag_id":"cjd4d1a14003wryx4kgqdlpdg","_id":"cjd4d1a150041ryx4y0ynnhk3"},{"post_id":"cjd4d1a0m001vryx4f1l31ew9","tag_id":"cjd4d1a15003zryx4k8iktnu6","_id":"cjd4d1a170044ryx4volp3hn1"},{"post_id":"cjd4d1a0m001vryx4f1l31ew9","tag_id":"cjd4d1a160042ryx4wyku8ovg","_id":"cjd4d1a170045ryx40qe19w66"},{"post_id":"cjd4d1a0o001yryx4i4fl4c9j","tag_id":"cjd4d1a160043ryx4zmgcqwus","_id":"cjd4d1a180048ryx40jynzggf"},{"post_id":"cjd4d1a0o001yryx4i4fl4c9j","tag_id":"cjd4d1a0g001eryx4dfja2mee","_id":"cjd4d1a180049ryx4y8o5ds96"},{"post_id":"cjd4d1a0o001yryx4i4fl4c9j","tag_id":"cjd4d1a170046ryx4cek8lh34","_id":"cjd4d1a19004bryx4t1sxjdqm"},{"post_id":"cjd4d1a0q0021ryx4mynxdnap","tag_id":"cjd4d1a170047ryx4ctyvriov","_id":"cjd4d1a1a004dryx4w6rt3qtm"},{"post_id":"cjd4d1a0q0021ryx4mynxdnap","tag_id":"cjd4d1a18004aryx4nenpf27z","_id":"cjd4d1a1a004eryx4nrkp89g6"},{"post_id":"cjd4d1a0s0025ryx4tlc50cx8","tag_id":"cjd4d1a19004cryx4jvwo9qwy","_id":"cjd4d1a1a004gryx4llk71scr"},{"post_id":"cjd4d1a0s0027ryx4rj7dx1ip","tag_id":"cjd4d1a0g001eryx4dfja2mee","_id":"cjd4d1a1b004hryx4rnrlpzgw"},{"post_id":"cjd4d1a0s0027ryx4rj7dx1ip","tag_id":"cjd4d1a1a004fryx4nuv7uh6b","_id":"cjd4d1a1b004iryx4zilnt41j"}],"Tag":[{"name":"IDEA","_id":"cjd4d19zk0005ryx4anvyljv4"},{"name":"DEBUG","_id":"cjd4d19zo000cryx4pu0gunsr"},{"name":"C++","_id":"cjd4d19zt000hryx4q4dprnat"},{"name":"JAVA","_id":"cjd4d19zx000nryx4ogbuatct"},{"name":"JVM","_id":"cjd4d1a070010ryx49b2leivi"},{"name":"JIT","_id":"cjd4d1a0d0017ryx4kfthf3lz"},{"name":"LINUX","_id":"cjd4d1a0g001eryx4dfja2mee"},{"name":"启动过程","_id":"cjd4d1a0k001mryx4qzqvb6ii"},{"name":"Spring","_id":"cjd4d1a0l001uryx4ueugffsw"},{"name":"IOC","_id":"cjd4d1a0r0023ryx4owdqqsxq"},{"name":"spring","_id":"cjd4d1a0t0029ryx4js8wl526"},{"name":"mvc","_id":"cjd4d1a0u002fryx41tmtpomw"},{"name":"模板","_id":"cjd4d1a0v002kryx4oqu8kpwg"},{"name":"多态","_id":"cjd4d1a0x002pryx4kywvm1qu"},{"name":"面向对象","_id":"cjd4d1a0x002uryx4a6z7gdea"},{"name":"继承","_id":"cjd4d1a0y002wryx4g7b5rbjc"},{"name":"类","_id":"cjd4d1a0z002zryx498m3ts6y"},{"name":"git","_id":"cjd4d1a0z0032ryx40q1jysz6"},{"name":"内存管理","_id":"cjd4d1a10003aryx4y3wukk4x"},{"name":"文件系统","_id":"cjd4d1a11003eryx4jrs6x6c5"},{"name":"maven","_id":"cjd4d1a11003fryx4nd43jj6e"},{"name":"进程","_id":"cjd4d1a12003kryx4wcdrsoor"},{"name":"线程","_id":"cjd4d1a12003mryx4i6k00x0h"},{"name":"tag1","_id":"cjd4d1a13003nryx4d7hxw130"},{"name":"tag2","_id":"cjd4d1a13003qryx4k9wnvg2z"},{"name":"代码规范","_id":"cjd4d1a14003wryx4kgqdlpdg"},{"name":"单元测试","_id":"cjd4d1a15003zryx4k8iktnu6"},{"name":"JACOCO","_id":"cjd4d1a160042ryx4wyku8ovg"},{"name":"X86","_id":"cjd4d1a160043ryx4zmgcqwus"},{"name":"编译原理","_id":"cjd4d1a170046ryx4cek8lh34"},{"name":"接口","_id":"cjd4d1a170047ryx4ctyvriov"},{"name":"抽象类","_id":"cjd4d1a18004aryx4nenpf27z"},{"name":"设计模式","_id":"cjd4d1a19004cryx4jvwo9qwy"},{"name":"程序员自我修养","_id":"cjd4d1a1a004fryx4nuv7uh6b"}]}}