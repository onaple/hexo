---
title: JIT
comments: true
tags:
  - JAVA
  - JVM
  - JIT
categories:
  - JAVA
date: 2017-09-09 17:41:33
update: 2017-09-09 17:41:33

---

# JIT（just in time,即时编译技术）  

## JIT的出现

通常javac将程序源代码编译，转换成java字节码，JVM通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢。为了提高执行速度，引入了JIT技术。

## JVM的三种执行模式

1. 解释模式：对于解释执行，不经过jit直接由解释器解释执行所有字节码，执行效率不高。
2. 编译模式：编译执行不加筛选的将全部代码进行编译机器码不论其执行频率是否有编译价值，在程序响应时间的限制下，编译器没法采用编译耗时较高的优化技术（因为JIT的编译是首次运行或启动的时候进行的！），所以，在纯编译执行模式下的java程序执行效率跟C/C++也是具有较大差距的。
3. 混合模式：源代码经javac编译成字节码，class文件；程序字节码经过JIT环境变量进行判断，是否属于“热点代码”（多次调用的方法，或循环等）；如是，走JIT编译为具体硬件处理器（如sparc、intel）机器码；如否，则直接由解释器解释执行。

新版本的jvm默认都是采用混合执行模式，优势：当程序需要迅速启动和执行的时候，解析器首先发挥作用，省去编译的时间，立即执行。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。
 
## JIT编辑器（即时编译器（Just In Time Compiler) 简称JIT）

1. Java JIT（just in time）即时编译器。但此编译器与通常说的javac那个编译器不同，它其实是将字节码编译为硬件可执行的机器码的。
2. JIT编译器（即时编译器），当虚拟机发现某个方法或代码块运行特别频繁时，就会把这些代码认定为“Hot Spot Code”（热点代码），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，完成这项任务的正是JIT编译器。
3. HotSpot虚拟机中内置了两个JIT编译器：Client Complier和Server Complier，分别用在客户端和服务端，目前主流的HotSpot虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作。
4. Client Compiler和Server Compiler会实现分层编译（JDK 1.7默认有）。
	* 第0层 程序解析执行，解析器不开启性能监控，可触发第一层编译。
	* 第1层 编译成本地相关代码，进行简单优化
	* 第2层 除编译成本地相关代码外，还进行成编译耗时较长的优化。
	* Client Compiler获得更高的编译速度 Server Compiler获得更好的编译质量，无须承担性能监控的任务
4. 编译器编译的“热点代码”有两类：两种情况，编译器都是以整个方法作为编译对象。
	* 被多次调用的方法。
	* 被多次调用的循环体。

5. Hot Spot Detection（热点探测）是不是需要触发即时编译，需要进行热点探测。  
 	目前主要的热点 判定方式有以下两种
 	
 * 基于采样的热点探测：采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那这段方法代码就是“热点代码”。这种探测方法的好处是实现简单高效，还可以很容易地获取方法调用关系，缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。
 * 基于计数器的热点探测：采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，如果执行次数超过一定的阀值，就认为它是“热点方法”。这种统计方法实现复杂一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果相对更加精确严谨。

6. 在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两个计数器：方法调用计数器和回边计数器。
 * 方法调用计数器用来统计方法调用的次数，在默认设置下，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间内方法被调用的次数。
 * 回边计数器用于统计一个方法中循环体代码执行的次数（准确地说，应该是回边的次数，因为并非所有的循环都是回边），在字节码中遇到控制流向后跳转的指令就称为“回边”。
 
  在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阀值，当计数器的值超过了阀值，就会触发JIT编译。触发了JIT编译后，在默认设置下，执行引擎并不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被编译器编译完成为止（编译工作在后台线程中进行）。当编译工作完成后，下一次调用该方法或代码时，就会使用已编译的版本。
 
  
## 作用

能够加速java程序的执行速度。由于JIT对每条字节码都进行编译，造成了编译过程负担过重。为了避免这种情况，当前的JIT只对经常执行的字节码进行编译，如循环等。
 
 
## JVM编译优化技术-----逃逸分析

逃逸分析：当一个对象被定义后，可能被外部方法引用，例如被当作参数传递到其他方法中，称为方法逃逸。可以被其他线程访问，这个称为线程逃逸。若能证明这个对象不会逃逸到其他方法或线程中，就可以进行高效的优化。

1. 栈上分配　 在堆上分配对象内存，回收整理内存需要消耗时间，若在栈上分配内存将是个不错的主意。被对象占用的空间就可以随帧栈的就出栈而销毁。大量的对象随方法的结束而自动销毁，GC也减轻压力。
2. 同步消除　　 若不会线程逃逸，不会有竞争，方法上的同步措施就会消除。
3. 标量替换　 JAVA的原始类型无法再分就是一个标量，对象就是聚合量。对象若可以被拆分成标量，直接在栈上分配，就是类似栈上分配内存，甚至分配到高速缓存中。

逃逸分析不成熟的原因：不能保证逃逸分析的性能收益大于它的消耗。

## 其他优化技术
JDK设计团队，几乎把所有的优化措施都集中在即时编译器中。一般认为，编译器的本地会比javac的产生的字节码更优秀。
常见的优化技术很多：例如公共表达式的消除，数组边界检查的消除，方法的内联（最重要的优化技术）。
