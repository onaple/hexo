---

title: LINUX启动过程
comments: true
tags:
  - LINUX
  - 启动过程
categories:
  - LINUX
date: 2017-09-02 15:34:27
update: 2017-09-02 15:34:27

---


> linux开机启动过程,必须经过加载BOIS、读取MBR、Boot Loader、加载内核、启动init进程并确定运行等级、执行初始化脚本、启动内核模块、执行对应运行等级的初始化脚本、个性化设置、进入登录状态的这十个步骤

# 一、 BIOS (Basic Input Output System)基本输入输出系统

1. 按下电源按钮触发CPU的reset引脚。CS寄存器会设值为0xffff;eip = 0x0000	。此时CPU会从内存的0xffff0处执行代码。此处就是一条跳转到BIOS的指令
2. BIOS读取CMOS了解硬件情况，开机自检，并对硬件初始化，然后将控制权交给MBR程序。

# 二、MBR（Master Boot Record）主引导记录

0. MBR是在Boot Sector（512字节）里的446字节。那Boot Sector是什么呢，他是引导扇区，在磁盘上占512字节，其中包括MBR（446字节）、DPT（磁盘分区表64子节）、BRID（引导记录表示2字节）。
1. BIOS会将Boot Sector里的所有内容读到地址是0x7c00的内存位置。（Boot Sector就是BIOS在读取CMOS时被设为启动设备的第一扇区）
2. BIOS首先会检验BRID是不是0x55AA,是的话才会将控制权交给MBR。
3. 由于MBR只有446个字节，所以它只是个跳板，然后把控制权交给GRUB

# 三、 GRUB （Grand Unified BootLoader）牛逼的统一引导加载器

1. BootLoader是什么呢？他是在操作系统内核运行前运行的一小段程序，他负责将操作系统的内核加载到内存，然后将电脑的控制权交给操作系统。同时还会搜集电脑的硬件信息、初始化硬件设备、安排内存布局等。
2. GRUB的特点：
	* 动态可配置化的，它在启动时读取配置信息，且允许启动时修改。
	* 提供菜单供用户选择要启动的操作系统。
	* 支持多种语言、支持链式启动。
	* 拥有丰富的控制台命令与用户交互、支持的操作系统非常广泛。
	
3. GRUB2的工作流程

     它比较霸道，必须提供1M的内存空间，来放置他的核心代码，位置无所谓，但必须在2T以内，否则找不到。

	* 第一阶段：占用MBR的坑（这是对付BISO的唯一方法）。编译好的代码叫boot.img（512字节）；他去那1M的空间找diskboot.img代码。
	* 第二阶段：diskboot.img是第二阶段的代码，大小也是512字节。是GRUB核心文件的第一个扇区。这个阶段的代码就是继续将core.img文件余下的部分读到内存，然后继续执行。
	* 第三阶段：开始加载GRUB内核模块。这样做的好处是core.img可以做的很小，可配置性和可扩展性非常高。
	* 第四阶段：启动操作界面，供用户选择要启动的操作系统。
	
	（内核启动参数的的传递）

# 四、加载内核

0. Bootloader在保护模式下（32位字长、32位寻址）直接交权给内核。
1. 内核调用startup\_32对自己解压缩。
2. 跳转到startup\_32这个函数继续执行。（注：这两个函数虽然同名，但是是不一样的）。 
>  这个startup\_32函数它代表了Linux的第一个进程process0的开始。这里，他会决定Linux的布局；Linux了解了自己将要与什么样的CPU在一起；会把由BIOS提供和BootLoader们整理的资料放入内存的第一个分页；同时为中断做好准备；如果是64位系统，将把长模式开启，最后会跳到Linux内核的主函数start\_kernel。开启内核的生命之旅。

3. start\_kernel函数位于init/mian.c这个文件中。它大部分时间是在为Linux内核准备必要的数据结构。比如：用于内存管理的数据结构，用于任务调度的数据结构，用于处理中断的数据结构，用于处理文件系统的数据结构。经过这些初始化后，Linux此时已经具有了一个操作系统应该具备的功能。
4. start\_kernel内核线程会创建一个名为kernel\_init的内核线程。然后进入自己的归宿cpu\_idle函数,进入无休止的循环当中。这个cpu\_idle函数就是我们常见的CPU占用率经常是99%的进程。进程PID为0.它会一直调用CPU的idle指令，让CPU降温且省电，优先级是很低的。
5. kernel\_init内核线程是新的Linux这么叫的，老得叫init内核线程。这是Linux的第二个进程，也是init的PID一定是1的由来。（在新的内核代码中，由于必须在创建kernel\_init之前创建另一个内核线程来做一些更重要的事，所以不得不先创建kernel\_init，并把它锁起来，然后再创建新的内核线程，然后等他执行完后再解锁。否则init的PID会变为2）。
6. kernel\_init内核线程比较重要的工作就是让Linux内核开始与外面进行沟通。比如：给硬件加载驱动程序、初始化网络堆栈、在多CPU系统中让其他CPU开始工作，寻找用户的根文件系统。
7. kernel\_init内核线程等一切都稳妥后，会调用用户空间的第一个进程init程序。此时，内核初始化完成。


# 五、 启动init进程并确定运行等级

1. 内核通过initramfs启动init进程。
2. initramfs是一个使用gzip压缩的cpi\_o打包文件，内核会将它的内容装入一个tmpfs，这就不需要附带任何文件系统驱动就能工作了。
3. initramfs直接启动init进程，initramfs是由bootloader准备好，告诉内核它在什么位置。内核知道后，直接启动initramfs中的init进程。接下来找根文件系统就交给init进程了。
4. init进程会根据用户设定的一个运行级别来对Linux系统进行初始化。比如：启动对应运行级别的服务进程，配置网络等。init进程会接受用户的 CTRL + Alt + Del 令Linux系统重新启动；也可以切换运行级别。当用户要关闭Linux系统时，init进程会将未来得及保存的文件保存好。init会收养孤儿进程。还可以保护某些进程不被kill。是Linux的守护神。