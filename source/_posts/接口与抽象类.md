---
title: 接口与抽象类
comments: true
tags:
  - 接口
  - 抽象类
categories:
  - JAVA
date: 2017-09-09 11:11:45
update: 2017-09-09 11:11:45

---

# 设计层面上的区别

1. 接口是对动作的抽象，抽象类是对根源的抽象。抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。
2. 抽象类主要用来抽象类别,接口主要用来抽象功能.当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。
3. 抽象类是对事物的抽象（类的抽象），接口是对行为的抽象。**继承是一个 “是不是”的关系，而接口实现则是 “有没有”的关系**。


抽象类是用来捕捉子类的通用特性的 。它不能被实例化，只能被用作子类的超类。抽象类是被用来创建继承层级里子类的模板。

# 接口
1. 接口是抽象方法的集合。如果一个类实现了某个接口，那么它就继承了这个接口的抽象方法。这就像**契约模式**，如果实现了这个接口，那么就必须确保使用这些方法。接口只是一种形式，接口自身不能做任何事情。
2. 接口，在表面上是由几个没有主体代码的方法定义组成的集合体，有唯一的名称，可以被类或其他接口所实现。
3. 接口是一组规则的集合，它规定了实现本接口的类或接口必须拥有的一组规则。体现了自然界“如果你是……则必须能……”的理念。
4. 接口是在一定粒度视图上同类事物的抽象表示。注意这里我强调了在一定粒度视图上，因为“同类事物”这个概念是相对的，它因为粒度视图不同而不同。



# 抽象类
1. 抽象类里面的抽象方法必须全部被子类实现，如果子类不能全部实现，那么子类必须也是抽象类。接口里面的方法也必须全部被子类实现，如果子类不能实现那么子类必须是抽象类。
抽象类中的方法都要被实现，所以抽象方法不能是静态的static，也不能是私有的private。
2. 如果一个类里面有抽象方法，那么这个类一定是抽象类。抽象类里面可以没有抽象方法。




## 抽象类中的修饰符
抽象类中的抽象方法（其前有abstract修饰）不能用private、static、synchronized、native访问修饰符修饰。

原因如下：

1. 抽象方法没有方法体，是用来被继承的，所以不能用private修饰；
2. static修饰的方法可以通过类名来访问该方法（即该方法的方法体），抽象方法用static修饰没有意义；
3. 使用synchronized关键字是为该方法加一个锁。。而如果该关键字修饰的方法是static方法。则使用的锁就是class变量的锁。如果是修饰类方法。则用this变量锁。但是抽象类不能实例化对象，因为该方法不是在该抽象类中实现的。是在其子类实现的。所以。锁应该归其子类所有。所以。抽象方法也就不能用synchronized关键字修饰了；
4. native，这个东西本身就和abstract冲突，他们都是方法的声明，只是一个吧方法实现移交给子类，另一个是移交给本地操作系统。如果同时出现，就相当于即把实现移交给子类，又把实现移交给本地操作系统，那到底谁来实现具体方法呢？


## 接口修饰符：
1. 接口中的变量会被隐式地指定为public static final变量（定义成其他类型，如private会报错），同时也意味着变量必须进行初始化。接口中的方法会被隐式地指定为public abstract方法（用其他关键字，比如private、protected、static、 final等会报错）
2. 通俗的讲，你认为是要变化的东西，就放在你自己的实现中，不能放在接口中去，接口只是对一类事物的属性和行为更高层次的抽象。对修改关闭，对扩展（不同的实现 implements）开放，**接口是对开闭原则的一种体现**。
3. 接口用于描述系统对外提供的所有服务,因此接口中的成员常量和方法都必须是公开(public)类型的,确保外部使用者能访问它们；
4. 接口仅仅描述系统能做什么,但不指明如何去做,所以接口中的方法都是抽象(abstract)方法；
接口不涉及和任何具体实例相关的细节,因此接口没有构造方法,不能被实例化,没有实例变量，只有静态（static）变量。
5. 接口的中的变量是所有实现类共有的，既然共有，肯定是不变的东西，因为变化的东西也不能够算共有。所以变量是不可变(final)类型，也就是常量了。







